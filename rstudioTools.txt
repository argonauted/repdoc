   [1] ".rs.rpc.generate_app_name"                         ".rs.scalarListFromFrame"                          
   [3] ".rs.assignWorkingData"                             ".rs.reticulate.replTeardown"                      
   [5] ".rs.deparse"                                       ".rs.scoreMatches"                                 
   [7] ".rs.websiteOutputDir"                              ".rs.environmentIsLocal"                           
   [9] ".rs.getCompletionsActiveFrame"                     ".rs.showDiagnostics"                              
  [11] ".rs.showPresentationHelpDoc"                       ".rs.odbcBundleCheckPrereqsOsx"                    
  [13] "debugSource"                                       ".rs.invokePlumberWindowViewer"                    
  [15] ".rs.defaultLibraryPath"                            ".rs.getAnywhere"                                  
  [17] ".rs.getVar"                                        ".rs.api.eventTypes"                               
  [19] ".rs.registerUserCommand"                           ".rs.python.getCompletions"                        
  [21] ".rs.sql.defunctConnections"                        ".rs.api.updateDialog"                             
  [23] ".rs.rpc.python_interpreter_info"                   ".rs.isPackageHyperlinkSafe"                       
  [25] ".rs.listIndexedFolders"                            ".rs.explorer.inspectPythonValue"                  
  [27] ".rs.invokeShinyPaneViewer"                         ".rs.tryMatchCall"                                 
  [29] ".rs.rpc.is_package_hyperlink_safe"                 ".rs.explorer.inspectPythonDict"                   
  [31] ".rs.removeTheme"                                   ".rs.quarto.editorConfig"                          
  [33] ".rs.getAutoSnapshotCmd"                            ".rs.connectionObserver.connectionOpened"          
  [35] ".rs.graphics.supportedBackends"                    ".rs.rpc.connect_rsconnect_account"                
  [37] ".rs.api.unregisterChunkCallback"                   ".rs.api.convertTheme"                             
  [39] ".rs.isSourceCall"                                  ".rs.appendCompletions"                            
  [41] ".rs.emitPackageInformation"                        ".rs.files.savedBindings"                          
  [43] ".rs.showHelpTopicFunction"                         ".rs.notebookConditions.onWarning"                 
  [45] ".rs.getS3MethodsForFunction"                       ".rs.api.stopJob"                                  
  [47] ".rs.format"                                        ".rs.strsplit"                                     
  [49] ".rs.rpc.renv_init"                                 ".rs.api.sendRequest"                              
  [51] ".rs.add_operator_color"                            ".rs.base64encode"                                 
  [53] ".rs.api.setSelectionRanges"                        ".rs.asCaseInsensitiveRegex"                       
  [55] ".rs.odbcBundleCheckPrereqsBrew"                    ".rs.getIndexedFiles"                              
  [57] ".rs.rVersionString"                                ".rs.getThemes"                                    
  [59] ".rs.recordHtmlWidget"                              ".rs.api.viewer"                                   
  [61] ".rs.lineDataList"                                  ".rs.rpc.search"                                   
  [63] ".rs.reticulate.describeObjectType"                 ".rs.getCustomRenderFunction"                      
  [65] ".rs.api.documentSaveAll"                           ".rs.hasPythonStackTrace"                          
  [67] ".rs.jsonEscapeString"                              ".rs.parseStyles"                                  
  [69] ".rs.python.invalidInterpreter"                     ".rs.rpc.get_set_ref_class_call"                   
  [71] ".rs.whichIsSubsequence"                            ".rs.python.getFunctionArguments"                  
  [73] ".rs.fromJSON"                                      ".rs.getRMemoryUsed"                               
  [75] ".rs.initHelp"                                      ".rs.api.tutorialRun"                              
  [77] ".rs.rpc.stan_get_completions"                      ".rs.rpc.get_dplyr_join_completions_string"        
  [79] ".rs.bookdown.frontMatterValue"                     ".rs.initHtmlCapture"                              
  [81] ".rs.rpc.get_new_connection_context"                ".rs.onAvailablePackagesStale"                     
  [83] ".rs.odbcBundleOdbcinstPathUseHome"                 ".rs.renv.readLockfilePackages"                    
  [85] ".rs.api.systemUsername"                            ".rs.api.terminalKill"                             
  [87] ".rs.rpc.get_rmd_output_info"                       ".rs.readUiPref"                                   
  [89] ".rs.api.previewRd"                                 ".rs.isKnitrObject"                                
  [91] ".rs.availablePackages"                             ".rs.api.selectionGet"                             
  [93] ".rs.includesForLinkingTo"                          ".rs.parseLinkingTo"                               
  [95] ".rs.extractRmdFromNotebook"                        ".rs.isDefaultTheme"                               
  [97] ".rs.profilesPath"                                  ".rs.quartoFileResources"                          
  [99] ".rs.hasFileMonitor"                                ".rs.rpc.get_theme_name"                           
 [101] ".rs.isValidShortcut"                               ".rs.connectionFiles"                              
 [103] ".rs.uniqueLibraryPaths"                            ".rs.python.tokenize"                              
 [105] ".rs.explorer.cache"                                ".rs.reticulate.describeObjectContents"            
 [107] ".rs.platform.isLinux"                              ".rs.getPackageFunction"                           
 [109] ".rs.forceUnloadForPackageInstall"                  ".rs.rpc.get_args"                                 
 [111] ".rs.flattenFrame"                                  ".rs.python.tokenizationRules"                     
 [113] ".rs.sql.getCompletionsKeywords"                    ".rs.getDataTableSpecialSymbolsCompletions"        
 [115] ".rs.setErrorManagementType"                        ".rs.getCompletionsGetOption"                      
 [117] ".rs.attachDataFile"                                ".rs.parseDictElement"                             
 [119] ".rs.enqueClientEvent"                              ".rs.createZipFile"                                
 [121] ".rs.getObjectContents"                             ".rs.rpc.stop_profiling"                           
 [123] ".rs.sql.keywords"                                  ".rs.toolsEnv"                                     
 [125] ".rs.readIniFile"                                   ".rs.reticulate.detectChanges"                     
 [127] ".rs.listZipFile"                                   ".rs.setNotebookGraphicsOption"                    
 [129] ".rs.saveLibPaths"                                  ".rs.getCompletionsSingleBracket"                  
 [131] ".rs.emptyNamedList"                                ".rs.rnbHooks.print.knit_asis"                     
 [133] ".rs.attemptRoxygenTagCompletion"                   ".rs.packagesLoaded"                               
 [135] ".rs.functionNameFromCall"                          ".rs.rpc.cpp_source_file"                          
 [137] ".rs.tutorial.installPackageDependencies"           ".rs.resolveFormalsImpl"                           
 [139] ".rs.describeObject"                                ".rs.findViewingEnv"                               
 [141] ".rs.files.restoreBindings"                         ".rs.connectionReadDSN"                            
 [143] ".rs.rpc.stop_shiny_app"                            ".rs.stan.getCompletions"                          
 [145] ".rs.getHelpFunction"                               ".rs.getDataTableUnnamedArgumentCompletions"       
 [147] ".rs.symbolLookupEnv"                               ".rs.stan.getArguments"                            
 [149] ".rs.reRmdChunkEnd"                                 ".rs.rpc.convert_to_yaml"                          
 [151] ".rs.api.getLastActiveEditorContext"                ".rs.getActiveArgument"                            
 [153] ".rs.getDplyrJoinCompletions"                       ".rs.clangPCHPath"                                 
 [155] ".rs.dataViewer.shouldUseObjectExplorer"            ".rs.registerNotifyHook"                           
 [157] ".rs.writePrefInternal"                             ".rs.knitrChunkOptions"                            
 [159] ".rs.explorer.setCacheEntry"                        ".rs.rpc.get_package_news_url"                     
 [161] ".rs.setOption"                                     ".rs.userCommands"                                 
 [163] ".rs.scalar"                                        ".rs.showLintMarkers"                              
 [165] ".rs.api.terminalCreate"                            ".rs.parseCss"                                     
 [167] ".rs.truncate"                                      ".rs.selectFuzzyMatches"                           
 [169] ".rs.functionHasSrcRef"                             ".rs.downloadAvailablePackages"                    
 [171] ".rs.api.showDialog"                                ".rs.ensureWriteableUserLibrary"                   
 [173] ".rs.valueAsStringImpl"                             ".rs.haveSecureDownloadFileMethod"                 
 [175] ".rs.ensureScalarCharacter"                         ".rs.rpc.launch_embedded_shiny_connection_ui"      
 [177] ".rs.rpc.list_all_files"                            ".rs.scalarListFromList"                           
 [179] ".rs.python.configuredInterpreterPath"              ".rs.S3Originals"                                  
 [181] ".rs.listFiles"                                     ".rs.explorer.objectName"                          
 [183] ".rs.reticulate.describeObject"                     ".rs.connectionUnregisterOdbcinstDriver"           
 [185] ".rs.invokeHook"                                    ".rs.detectFreeVars_Call"                          
 [187] ".rs.saveOptions"                                   "source.with.encoding"                             
 [189] ".rs.notebookConditions.connectCall"                ".rs.rnb.renderConsoleData"                        
 [191] ".rs.enumerate"                                     ".rs.extractRmdChunkInformation"                   
 [193] ".rs.writeUserState"                                ".rs.api.dictionariesPath"                         
 [195] ".rs.insecureDownloadWarning"                       ".rs.completeUrl"                                  
 [197] ".rs.rpc.get_shiny_viewer_type"                     ".rs.rpc.rmd_output_format"                        
 [199] ".rs.isEmptyCompletion"                             "RStudio.Version"                                  
 [201] ".rs.htmlEscape"                                    ".rs.restoreGlobalEnvFromFile"                     
 [203] ".rs.renv.refresh"                                  ".rs.create_terminal_viewport_rule"                
 [205] ".rs.assembleDataImportName"                        ".rs.isGlobalTheme"                                
 [207] ".rs.reticulate.initialize"                         ".rs.api.translateLocalUrl"                        
 [209] ".rs.isNullExternalPointer"                         ".rs.odbcBundleValidate"                           
 [211] ".rs.ignoreNextLoadedPackageCheck"                  ".rs.rpc.validate_cran_repo"                       
 [213] ".rs.api.addJob"                                    ".rs.valueDescriptionImpl"                         
 [215] ".rs.runSqlForDataCapture"                          ".rs.connectionOdbcInstallerPath"                  
 [217] ".rs.toJSON"                                        ".rs.getShinyViewerType"                           
 [219] ".rs.resolveObjectFromFunctionCall"                 ".rs.getRgbColor"                                  
 [221] ".rs.tutorial.registryGet"                          ".rs.markdown.acCompletionTypes"                   
 [223] ".rs.rpc.convert_from_yaml"                         ".rs.api.highlightUi"                              
 [225] ".rs.api.askForSecret"                              ".rs.setInternet2"                                 
 [227] ".rs.invokeShinyWindowViewer"                       ".rs.rpc.get_set_method_call"                      
 [229] ".rs.valueFromStr"                                  ".rs.parseColor"                                   
 [231] ".rs.mget"                                          ".rs.parseCRANReposList"                           
 [233] ".rs.addGlobalFunction"                             ".rs.odbcBundleCheckPrereqsUnixodbc"               
 [235] ".rs.forceUnloadPackage"                            ".rs.markdown.getCompletionsHref"                  
 [237] ".rs.api.runScriptJob"                              ".rs.parseYamlOpt"                                 
 [239] ".rs.Rd2HTML"                                       ".rs.resolveFormals"                               
 [241] ".rs.isExternalPointer"                             ".rs.rpc.update_odbc_installers"                   
 [243] ".rs.python.getCompletionsArguments"                ".rs.odbcBundleName"                               
 [245] ".rs.scrapeHtmlAttributes"                          ".rs.packageHelpEncodingDefault"                   
 [247] ".rs.success"                                       ".rs.rpc.get_new_odbc_connection_context"          
 [249] ".rs.editor"                                        ".rs.hydrateCacheFromNotebook"                     
 [251] ".rs.previewSql"                                    ".rs.api.getActiveDocumentContext"                 
 [253] ".rs.transposeList"                                 ".rs.rpc.get_rsconnect_lint_results"               
 [255] ".rs.getCompletionsFromShinyUI"                     ".rs.rpc.tutorial_metadata"                        
 [257] ".rs.rpc.tutorial_started"                          ".rs.api.getThemes"                                
 [259] ".rs.replaceBinding"                                ".rs.systemToUtf8"                                 
 [261] ".rs.python.getPythonVersion"                       ".rs.addFirstRunDocumentsForTemplate"              
 [263] ".rs.renv.listPackages"                             ".rs.askForSecret"                                 
 [265] "RStudioGD"                                         ".rs.api.restartSession"                           
 [267] ".rs.get"                                           ".rs.api.closeAllSourceBuffersWithoutSaving"       
 [269] ".rs.connectionFilesPath"                           ".rs.getNativeSymbols"                             
 [271] ".rs.rpc.preview_data_import"                       ".rs.rpc.has_shinytest_results"                    
 [273] ".rs.parseTmTheme"                                  ".rs.haveAdvancedSteppingCommands"                 
 [275] ".rs.makeCompletions"                               ".rs.stripSurrounding"                             
 [277] ".rs.assign"                                        ".rs.executeChunkCallback"                         
 [279] ".rs.formatListForDialog"                           ".rs.connectionPreviewObject"                      
 [281] ".rs.error"                                         ".rs.dialogIcon"                                   
 [283] ".rs.connectionReadOdbc"                            ".rs.setCRANRepos"                                 
 [285] ".rs.addFunction"                                   ".rs.rpc.uninstall_odbc_driver"                    
 [287] ".rs.listJsonRpcHandlers"                           ".rs.libclang.generateCompilerDefinitions"         
 [289] ".rs.rnb.outputSourcePng"                           ".rs.resolveAliasedPath"                           
 [291] ".rs.python.isPython3"                              ".rs.runUserDefinedEngine"                         
 [293] ".rs.findRtoolsInstaller"                           ".rs.getCompletionsDollar"                         
 [295] ".rs.getSetRefClassSymbols"                         ".rs.tutorial.stopTutorial"                        
 [297] ".rs.inferReticulatePython"                         ".rs.getKnitParamsForDocument"                     
 [299] ".rs.api.getActiveProject"                          ".rs.getHelp"                                      
 [301] ".rs.extractRCode"                                  ".rs.rnb.cachePathFromRmdPath"                     
 [303] ".rs.db.listTables"                                 ".rs.parseDataFile"                                
 [305] ".rs.extractElement"                                ".rs.packageHelpEncoding"                          
 [307] ".rs.api.getConsoleEditorContext"                   ".rs.rpc.get_pending_actions"                      
 [309] ".rs.getNames"                                      ".rs.rnb.generateRandomChunkId"                    
 [311] ".rs.removeCachedData"                              ".rs.tutorial.launchBrowser"                       
 [313] ".rs.setPrintMarginColor"                           ".rs.findGlobalData"                               
 [315] ".rs.fileInfo"                                      ".rs.docDeployList"                                
 [317] ".rs.notebookConditions.onMessage"                  ".rs.downloadFileExtraWithCurlArgs"                
 [319] ".rs.listIndexedFiles"                              ".rs.readShinytestResultRds"                       
 [321] ".rs.rpc.explorer_end_inspect"                      ".rs.rnbHooks.print.htmlwidget"                    
 [323] ".rs.tutorial.enqueueClientEvent"                   ".rs.reRmdChunkBegin"                              
 [325] ".rs.multiCols"                                     ".rs.api.selectionSet"                             
 [327] ".rs.python.execute"                                ".rs.explorer.createContext"                       
 [329] ".rs.quietPackratStatus"                            ".rs.readSourceDocument"                           
 [331] ".rs.odbcBundleDownload"                            ".rs.registerNotebookErrHandler"                   
 [333] ".rs.tutorial.onSuspend"                            ".rs.safeAsEnvironment"                            
 [335] ".rs.python.token"                                  ".rs.getCompletionsNamespace"                      
 [337] ".rs.reticulate.viewHook"                           ".rs.explorer.isPythonObjectExpandable"            
 [339] ".rs.api.askForPassword"                            ".rs.notebookConditions.connectImpl"               
 [341] ".rs.getSourceDocumentProperties"                   ".rs.onAvailablePackagesReady"                     
 [343] ".rs.showHelpTopic"                                 ".rs.utf8ToSystem"                                 
 [345] ".rs.rpc.stan_run_diagnostics"                      ".rs.getR6ClassGeneratorMethod"                    
 [347] ".rs.themes_rainbow_indent_guides"                  ".rs.getCompletionsShinySession"                   
 [349] ".rs.nse.primitives"                                ".rs.connectionInstallerInfo"                      
 [351] ".rs.connectionObserver.connectionError"            ".rs.rpc.forget_rsconnect_deployments"             
 [353] ".rs.doShinyUICompletions"                          ".rs.python.moduleCache"                           
 [355] ".rs.explorer.inspectPythonObject"                  ".rs.environmentName"                              
 [357] ".rs.clearVar"                                      ".rs.checkBuildTools"                              
 [359] ".rs.insecureReposWarning"                          ".rs.registerUnsupported"                          
 [361] ".rs.registerReplaceHook"                           ".rs.rpc.get_custom_help"                          
 [363] ".rs.python.getCondaEnvironmentInfo"                ".rs.explorer.fireEvent"                           
 [365] ".rs.recordUserTraceback"                           ".rs.api.savePlotAsImage"                          
 [367] ".rs.hasSecret"                                     ".rs.getDataTableColumnsCompletions"               
 [369] ".rs.validateParams"                                ".rs.stepsAtLine"                                  
 [371] ".rs.quarto.renderPreview"                          ".rs.getHelpColumn"                                
 [373] ".rs.odbcBundleRegisterOSX"                         ".rs.create_line_marker_rule"                      
 [375] ".rs.odbcOdbcInstLibPath"                           ".rs.doStripSurrounding"                           
 [377] ".rs.getHTMLCapabilities"                           ".rs.nBytes"                                       
 [379] ".rs.rpc.markdown_get_completions"                  ".rs.api.setJobProgress"                           
 [381] ".rs.initTools"                                     ".rs.rpc.iconvlist"                                
 [383] ".rs.callSafely"                                    ".rs.api.readPreference"                           
 [385] ".rs.askForPassword"                                ".rs.addGlobalVariable"                            
 [387] ".rs.initGraphicsDevice"                            ".rs.api.setJobState"                              
 [389] ".rs.releaseHtmlCapture"                            ".rs.defaultChunkOptions"                          
 [391] ".rs.reticulate.listAttributes"                     ".rs.api.insertText"                               
 [393] ".rs.selectStartsWith"                              ".rs.getFunctionSourceRefs"                        
 [395] ".rs.tutorial.registryCreate"                       ".rs.rpc.is_package_installed"                     
 [397] ".rs.api.documentOpen"                              ".rs.python.inferObjectTypes"                      
 [399] ".rs.isPackified"                                   ".rs.embeddedViewer"                               
 [401] ".rs.rpc.replace_comment_header"                    ".rs.internal.removeTheme"                         
 [403] ".rs.reticulate.explorerCache"                      ".rs.isPackageInstalled"                           
 [405] ".rs.performsNonstandardEvaluationImpl"             ".rs.explorer.close"                               
 [407] ".rs.GEcopyDisplayList"                             ".rs.evalWithAvailableArguments"                   
 [409] ".rs.formatDataColumn"                              ".rs.reticulate.listLoadedModules"                 
 [411] ".rs.reticulate.describeObjectLength"               ".rs.getActiveFrame"                               
 [413] ".rs.tutorial.findTutorials"                        ".rs.connectionExecuteAction"                      
 [415] ".rs.api.initializeProject"                         ".rs.rnb.renderVerbatimConsoleInput"               
 [417] ".rs.doGetIndex"                                    ".rs.rpc.stan_get_arguments"                       
 [419] ".rs.removeWorkingData"                             ".rs.python.findCondaBinary"                       
 [421] ".rs.tutorial.openExistingTutorial"                 ".rs.scanFiles"                                    
 [423] ".rs.getDataTableJCompletions"                      ".rs.rnb.getHtmlCaptureContext"                    
 [425] ".rs.convertTmTheme"                                ".rs.withChangedExtension"                         
 [427] ".rs.libclang.defaultCompilerIncludeDirectories"    ".rs.api.terminalBusy"                             
 [429] ".rs.api.addJobOutput"                              ".rs.add_keyword_color"                            
 [431] ".rs.devModeOn"                                     ".rs.subsetCompletions"                            
 [433] ".rs.assembleDataImportParameters"                  ".rs.api.eventTargets"                             
 [435] ".rs.platform.isMacos"                              ".rs.normalizePath"                                
 [437] ".rs.explorer.inspectObject"                        ".rs.sortCompletions"                              
 [439] ".rs.lintRFile"                                     ".rs.packageVersionString"                         
 [441] ".rs.getHelpPackage"                                ".rs.getCompletionType"                            
 [443] ".rs.setCRANReposAtStartup"                         ".rs.viewDataFrame"                                
 [445] ".rs.expandPkgDependencies"                         ".rs.fromYAML"                                     
 [447] ".rs.odbcBundleOsName"                              ".rs.getSignature"                                 
 [449] ".rs.python.getVirtualEnvironmentInfo"              ".rs.previewDataFrame"                             
 [451] ".rs.quartoFileProject"                             ".rs.api.bundledDictionariesPath"                  
 [453] ".rs.sql.isTableScopedKeyword"                      ".rs.isPackratModeOn"                              
 [455] ".rs.selectIsSubsequence"                           ".rs.libPathsAppend"                               
 [457] ".rs.rnbHooks.print.shiny.tag"                      ".rs.api.documentId"                               
 [459] ".rs.getNAMESPACEImportedSymbols"                   ".rs.connectionUnregisterWindowsDriver"            
 [461] ".rs.rpc.get_plumber_viewer_type"                   ".rs.rpc.renv_actions"                             
 [463] ".rs.parseSecondaryReposIni"                        ".rs.explorer.restoreCache"                        
 [465] ".rs.rpc.profile_sources"                           ".rs.topoSortPackages"                             
 [467] ".rs.rpc.get_user_from_token"                       ".rs.getCompletionsInstallPackages"                
 [469] ".rs.stan.extractFromNamespace"                     ".rs.python.emptyCompletions"                      
 [471] ".rs.isDataTableExtractCall"                        ".rs.withTimeLimit"                                
 [473] ".rs.isPackageVersionInstalled"                     ".rs.valueContents"                                
 [475] ".rs.getRCompletions"                               ".rs.isCustomCompletionsEnabled"                   
 [477] ".rs.rpc.follow_help_topic"                         ".rs.restoreOptions"                               
 [479] ".rs.downloadAllDictionaries"                       ".rs.connectionReadSnippets"                       
 [481] ".rs.rAddinsEnv"                                    ".rs.api.navigateToFile"                           
 [483] ".rs.mergeLists"                                    ".rs.invokePlumberPaneViewer"                      
 [485] ".rs.getSecretService"                              ".rs.rpc.prepare_for_addin"                        
 [487] ".rs.base64decode"                                  ".rs.environmentList"                              
 [489] ".rs.getCustomRCompletions"                         ".rs.addApiFunction"                               
 [491] ".rs.r.keywords"                                    ".rs.createCommentBgRule"                          
 [493] ".rs.tutorial.registry"                             ".rs.parseQuitArguments"                           
 [495] ".rs.api.setJobStatus"                              ".rs.explorer.tags"                                
 [497] ".rs.isS3Generic"                                   ".rs.readUserPref"                                 
 [499] ".rs.stopf"                                         ".rs.api.buildToolsCheck"                          
 [501] ".rs.writeUiPref"                                   ".rs.readlineCompletions"                          
 [503] ".rs.connectionReadWindowsRegistry"                 ".rs.rpc.open_profile"                             
 [505] ".rs.setOptionDefault"                              ".rs.listDatasetsProvidedByPackage"                
 [507] ".rs.connectionOdbcRStudioDriver"                   ".rs.reticulate.matplotlib.onLoaded"               
 [509] ".rs.tutorial.registryKey"                          ".rs.rnb.htmlCaptureHooks"                         
 [511] ".rs.odbcBundleWriteIni"                            ".rs.rpc.python_active_interpreter"                
 [513] ".rs.connectionHasInstaller"                        ".rs.db.listSchemas"                               
 [515] ".rs.getRArch"                                      ".rs.parseArrayElement"                            
 [517] ".rs.getCompletionsFunction"                        ".rs.updatePackageEvents"                          
 [519] ".rs.builtWithRtoolsGcc493"                         ".rs.S3Overrides"                                  
 [521] ".rs.breakOnAnyError"                               ".rs.rnb.pagedTableHtml"                           
 [523] ".rs.rstudioapi.processRequestImpl"                 ".rs.showPresentation"                             
 [525] ".rs.api.documentNew"                               ".rs.rpc.save_active_document"                     
 [527] ".rs.rpc.connection_test"                           ".rs.doShinyServerCompletions"                     
 [529] ".rs.getFunctionArgumentNames"                      ".rs.unquote"                                      
 [531] ".rs.initializeProjectFromTemplate"                 ".rs.python.tokenCursor"                           
 [533] ".rs.internalLintEngine"                            ".rs.resolveEnvironment"                           
 [535] ".rs.sql.getCompletionsTables"                      ".rs.discoverPackageDependencies"                  
 [537] ".rs.topicsEnv"                                     ".rs.initializeDataViewer"                         
 [539] ".rs.rpc.create_aliased_path"                       ".rs.createMarkersFromLint"                        
 [541] ".rs.beforePackageUnloaded"                         ".rs.retrieveSecret"                               
 [543] ".rs.api.userIdentity"                              ".rs.connectionListObjects"                        
 [545] ".rs.jsonProperty"                                  ".rs.api.removeTheme"                              
 [547] ".rs.dirExists"                                     ".rs.getProjectDirectory"                          
 [549] ".rs.rememberSecret"                                ".rs.reticulate.replBusy"                          
 [551] ".rs.getRChainCompletions"                          ".rs.rpc.python_find_interpreters"                 
 [553] ".rs.restorePreviousPath"                           ".rs.breakOnUserError"                             
 [555] ".rs.finishExpression"                              ".rs.rpc.get_help_at_cursor"                       
 [557] ".rs.nrow"                                          ".rs.rpc.transform_snippet"                        
 [559] ".rs.rnb.setHtmlCaptureContext"                     ".rs.surround"                                     
 [561] ".rs.packageNewsURLsEnv"                            ".rs.python.keywords"                              
 [563] ".rs.saveGraphics"                                  ".rs.formatDataColumnNumeric"                      
 [565] ".rs.handleNotebookError"                           ".rs.loadUserCommands"                             
 [567] ".rs.objectClass"                                   ".rs.availableRSymbols"                            
 [569] ".rs.getThemeDirFromUrl"                            ".rs.makeHelpCall"                                 
 [571] ".rs.isPackageLoaded"                               ".rs.getCompletionsAttr"                           
 [573] ".rs.readPackageDescription"                        ".rs.python.initialize"                            
 [575] ".rs.explorer.inspectDefault"                       ".rs.WorkingDataEnv"                               
 [577] ".rs.notebookChunkCallbacks"                        ".rs.saveEnvironment"                              
 [579] ".rs.updateSetting"                                 ".rs.explorer.types"                               
 [581] ".rs.rpc.explorer_inspect_object"                   ".rs.defaultLibPathIsWriteable"                    
 [583] ".rs.api.setPersistentValue"                        ".rs.resolveAliasedSymbol"                         
 [585] ".rs.escapeForRegex"                                ".rs.formatRowNames"                               
 [587] ".rs.activeConnections"                             ".rs.readUserState"                                
 [589] ".rs.regexMatches"                                  ".rs.rpc.preview_sql"                              
 [591] ".rs.rpc.get_auth_token"                            ".rs.odbcBundleRegistryDelete"                     
 [593] ".rs.rpc.get_deployment_files"                      ".rs.rnbHooks.print.knit_image_paths"              
 [595] ".rs.setVar"                                        ".rs.attachConflicts"                              
 [597] ".rs.getIndexedFilesAndFolders"                     ".rs.shinyServerCompletions"                       
 [599] ".rs.tutorial.findTutorialsImpl"                    ".rs.getRSConnectDeployments"                      
 [601] ".rs.api.sendToConsole"                             ".rs.scriptActions"                                
 [603] ".rs.slice"                                         ".rs.rnbHooks.print.html"                          
 [605] ".rs.rpc.default_sql_connection_name"               ".rs.toDataFrame"                                  
 [607] ".rs.newDesktopGraphicsDevice"                      ".rs.getInferredCompletions"                       
 [609] ".rs.rpc.preview_data_import_clean"                 ".rs.createAliasedPath"                            
 [611] ".rs.extractNativeSymbols"                          ".rs.connectionReadOdbcEntry"                      
 [613] ".rs.parsePackageDependencies"                      ".rs.addCachedData"                                
 [615] ".rs.odbcBundleRegistryAdd"                         ".rs.rpc.check_for_package_updates"                
 [617] ".rs.explorer.objectSize"                           ".rs.pager"                                        
 [619] ".rs.invokePlumberWindowExternal"                   ".rs.python.listModules"                           
 [621] ".rs.connectionSupportedPackages"                   ".rs.hasVar"                                       
 [623] ".rs.isDownloadMethodSecure"                        ".rs.sql.getCompletionsIdentifiers"                
 [625] ".rs.isREADME"                                      ".rs.rpc.is_function"                              
 [627] ".rs.python.getParameterHelp"                       ".rs.replayNotebookPlots"                          
 [629] ".rs.listFilesFuzzy"                                ".rs.makeDeploymentList"                           
 [631] ".rs.rpc.extract_chunk_options"                     ".rs.explorer.callCustomInspector"                 
 [633] ".rs.rpc.get_vignette_title"                        ".rs.parseStringElement"                           
 [635] ".rs.getCompletionsDoubleBracket"                   ".rs.extractChunkInnerCode"                        
 [637] ".rs.describeCols"                                  ".rs.reticulate.hookedMatplotlibModules"           
 [639] ".rs.cppSourceFile"                                 ".rs.odbcBundleFindDriver"                         
 [641] ".rs.markdownToHTML"                                ".rs.enqueLoadedPackageUpdates"                    
 [643] ".rs.matchCall"                                     ".rs.connectionOdbcInstallPath"                    
 [645] ".rs.reticulate.replIsActive"                       ".rs.getPackageInformation"                        
 [647] ".rs.withBuildTools"                                ".rs.renvCache"                                    
 [649] ".rs.python.findWindowsPython"                      ".rs.restoreGraphics"                              
 [651] ".rs.findConnectionName"                            ".rs.findShinyTestsDir"                            
 [653] ".rs.isRtoolsOnPath"                                ".rs.createDefaultShellRd"                         
 [655] ".rs.rstudioapi.processRequest"                     ".rs.setCRANReposFromSettings"                     
 [657] ".rs.addJsonRpcHandler"                             ".rs.makePrimitiveWrapper"                         
 [659] ".rs.expandDependencies"                            ".rs.objectType"                                   
 [661] ".rs.registerPackageLoadHook"                       ".rs.explorer.isValidInspectionResult"             
 [663] ".rs.loadedPackageUpdates"                          ".rs.connectionObserver.connectionUpdated"         
 [665] ".rs.markdown.resolveCompletionRoot"                ".rs.extractFunctionNameFromCall"                  
 [667] ".rs.reticulate.onPythonInitialized"                ".rs.lint"                                         
 [669] ".rs.api.addTheme"                                  ".rs.CachedDataEnv"                                
 [671] ".rs.showErrorMessage"                              ".rs.rpc.loaded_package_updates_required"          
 [673] ".rs.api.unregisterCommandCallback"                 ".rs.api.terminalClear"                            
 [675] ".rs.getSrcref"                                     ".rs.rpc.get_secondary_repos"                      
 [677] ".rs.formCompletionVector"                          ".rs.rpc.has_orphaned_accounts"                    
 [679] ".rs.odbcBundleExtract"                             ".rs.writeUserPref"                                
 [681] ".rs.tutorial.onResume"                             ".rs.getS4MethodsForFunction"                      
 [683] ".rs.defaultHttpUserAgent"                          ".rs.stringBuilder"                                
 [685] ".rs.explorer.refresh"                              ".rs.api.documentPath"                             
 [687] ".rs.internal.addTheme"                             ".rs.findCustomHelpContext"                        
 [689] ".rs.hasColumns"                                    ".rs.getRmdPublishDetails"                         
 [691] ".rs.getSingleClass"                                ".rs.isLocalTheme"                                 
 [693] ".rs.prepareViewerData"                             ".rs.rpc.clear_profile"                            
 [695] ".rs.valueContentsImpl"                             ".rs.platform.isWindows"                           
 [697] ".rs.explorer.defaultRowLimit"                      ".rs.api.buildToolsInstall"                        
 [699] ".rs.api.buildToolsExec"                            ".rs.profileResources"                             
 [701] ".rs.api.terminalVisible"                           ".rs.odbcBundleReadIni"                            
 [703] ".rs.packageVersion"                                ".rs.api.getPackageDependencies"                   
 [705] ".rs.api.addJobProgress"                            ".rs.explorer.getCachedObject"                     
 [707] ".rs.reYamlOptChunkBegin"                           ".rs.extractHTMLBodyElement"                       
 [709] ".rs.getRmdRuntime"                                 ".rs.pathRelativeToWorkingDir"                     
 [711] ".rs.api.diagnosticsReport"                         ".rs.unloadPackage"                                
 [713] ".rs.getHelpFromObject"                             ".rs.tutorial.runTutorial"                         
 [715] ".rs.RdLoadMacros"                                  ".rs.python.getCompletionsKeys"                    
 [717] ".rs.odbcBundleCheckPrereqsWindows"                 ".rs.rpc.record_command_execution"                 
 [719] ".rs.convertTheme"                                  ".rs.rpc.python_go_to_definition"                  
 [721] ".rs.getActivePythonStackTrace"                     ".rs.getSourceIndexCompletions"                    
 [723] ".rs.getHelpDataTableSpecialSymbol"                 ".rs.rpc.get_completions"                          
 [725] ".rs.secureDownloadMethod"                          ".rs.rpc.get_server_urls"                          
 [727] ".rs.rpc.get_data_preview"                          ".rs.setDefaultChunkOptions"                       
 [729] ".rs.callAs"                                        ".rs.add_content"                                  
 [731] ".rs.connectionObserver.connectionOpenedImpl"       ".rs.pyStackItemToLineDataList"                    
 [733] ".rs.shinyUICompletions"                            ".rs.sql.listTables"                               
 [735] ".rs.validateAndTransformLocation"                  ".rs.rnbHooks.print.shiny.tag.list"                
 [737] ".rs.python.generateHtmlHelp"                       ".rs.breakOnError"                                 
 [739] ".rs.hasExternalPointer"                            ".rs.rnb.outputSourceHtml"                         
 [741] ".rs.registerHook"                                  ".rs.api.removeJob"                                
 [743] ".rs.rnb.outputSource"                              ".rs.python.getCompletionsFiles"                   
 [745] ".rs.rpc.package_skeleton"                          ".rs.rpc.show_custom_help_topic"                   
 [747] ".rs.getTemplateYamlFile"                           ".rs.getCompletionsRMarkdownParams"                
 [749] ".rs.initDataCapture"                               ".rs.api.getSourceEditorContext"                   
 [751] ".rs.api.registerChunkCallback"                     ".rs.getProjectTemplateRegistry"                   
 [753] ".rs.asBuildPath"                                   ".rs.createNotebookFromCacheData"                  
 [755] ".rs.reticulate.enqueueClientEvent"                 ".rs.rpc.analyze_project"                          
 [757] ".rs.canonicalizePath"                              ".rs.viewHook"                                     
 [759] ".rs.rpc.suggest_topics"                            ".rs.python.findPythonInterpretersInKnownLocations"
 [761] ".rs.explorer.createChildContext"                   ".rs.isFunction"                                   
 [763] ".rs.explorer.inspectPythonList"                    ".rs.python.findPythonCondaEnvironments"           
 [765] ".rs.initSecureDownload"                            ".rs.getR6ClassSymbols"                            
 [767] ".rs.getCompletionsVignettes"                       ".rs.deparseFunction"                              
 [769] ".rs.dataCaptureOverrides"                          ".rs.enqueEditorClientEvent"                       
 [771] ".rs.usingUtf8Charset"                              ".rs.sourceFileFromRef"                            
 [773] ".rs.restartR"                                      ".rs.odbcBundleDriverIniPath"                      
 [775] ".rs.callWithRDS"                                   ".rs.detectFreeVars_Leaf"                          
 [777] ".rs.explorer.removeCacheEntry"                     ".rs.randomString"                                 
 [779] ".rs.findDataFrame"                                 ".rs.rpc.tutorial_stop"                            
 [781] ".rs.compile_theme"                                 ".rs.getRmdOutputInfo"                             
 [783] ".rs.httpdPort"                                     ".rs.registerFunctionEditor"                       
 [785] ".rs.getFunctionSteps"                              ".rs.api.tutorialLaunchBrowser"                    
 [787] ".rs.updateRStudioIDEPackage"                       ".rs.strip_color_from_field"                       
 [789] ".rs.mightBeShinyFunction"                          ".rs.getDataTableNamedArgumentCompletions"         
 [791] ".rs.getUseMethodGeneric"                           ".rs.tutorial.registryFind"                        
 [793] ".rs.showHelpTopicArgument"                         ".rs.format_css_color"                             
 [795] ".rs.reticulate.describeObjectContentsImpl"         ".rs.api.terminalActivate"                         
 [797] ".rs.registerHistoryFunctions"                      ".rs.isSubsequence"                                
 [799] ".rs.listInferredPackages"                          ".rs.python.getCompletionsImportsFrom"             
 [801] ".rs.api.terminalContext"                           ".rs.rpc.get_issue_url"                            
 [803] ".rs.getCachedAvailablePackages"                    ".rs.valueAsString"                                
 [805] ".rs.detachConflicts"                               ".rs.api.writeRStudioPreference"                   
 [807] ".rs.listBuilder"                                   ".rs.rpc.init_default_user_library"                
 [809] ".rs.formatDataColumnDefault"                       ".rs.rpc.get_cran_actives"                         
 [811] ".rs.rsconnectDeployList"                           ".rs.reticulate.replHook"                          
 [813] ".rs.connectionReadPackages"                        ".rs.api.getThemeInfo"                             
 [815] ".rs.getHelpDataFrame"                              ".rs.packageHelpEncodingEnv"                       
 [817] ".rs.evaluateChunkOptions"                          ".rs.userPrompt"                                   
 [819] ".rs.reticulateEvents"                              ".rs.odbcBundleRegistryRemove"                     
 [821] ".rs.reticulate.isFunction"                         ".rs.getPlumberViewerType"                         
 [823] ".rs.getPackageVersion"                             ".rs.unquoteImpl"                                  
 [825] ".rs.libPathsString"                                ".rs.reticulate.describeObjectValue"               
 [827] ".rs.rpc.explorer_begin_inspect"                    ".rs.getAllOutputFormats"                          
 [829] ".rs.logWarningMessage"                             ".rs.resolveFormalsImplS3Dispatch"                 
 [831] ".rs.listPackagesPackrat"                           ".rs.python.getNumpyFunctionArguments"             
 [833] ".rs.rpc.ignore_next_loaded_package_check"          ".rs.python.extractCurrentExpression"              
 [835] ".rs.setFunctionBreakpoints"                        ".rs.rpc.get_help"                                 
 [837] ".rs.setLintEngine"                                 ".rs.api.tutorialStop"                             
 [839] ".rs.readFile"                                      ".rs.api.bugReport"                                
 [841] ".rs.bookdown.renderedOutputPath"                   ".rs.invokeRpc"                                    
 [843] ".rs.listIndexedFilesAndFolders"                    ".rs.api.selectDirectory"                          
 [845] ".rs.rpc.show_help_topic"                           ".rs.trimWhitespace"                               
 [847] ".rs.addTheme"                                      ".rs.availablePackagesState"                       
 [849] ".rs.getCustomHelpUrl"                              ".rs.getFunctionImpl"                              
 [851] ".rs.create_terminal_rule"                          ".rs.disableSaveCompression"                       
 [853] ".rs.handlerLookupError"                            ".rs.autoDownloadMethod"                           
 [855] ".rs.rpc.detect_free_vars"                          ".rs.invokeShinyWindowExternal"                    
 [857] ".rs.knitParams"                                    ".rs.lastCharacterIs"                              
 [859] ".rs.getCompletionsLibraryContextArgumentNames"     ".rs.rpc.get_custom_parameter_help"                
 [861] ".rs.prependToPath"                                 ".rs.notebookVersion"                              
 [863] ".rs.createNotebookGraphicsDevice"                  ".rs.api.userDictionariesPath"                     
 [865] ".rs.rpc.has_shinytest_dependencies"                ".rs.validateConnection"                           
 [867] ".rs.validateAndNormalizeEncoding"                  ".rs.python.getCompletionsImports"                 
 [869] ".rs.loadPackage"                                   ".rs.removeS3Override"                             
 [871] ".rs.spinScript"                                    ".rs.api.versionInfo"                              
 [873] ".rs.withCache"                                     ".rs.explorer.objectDesc"                          
 [875] ".rs.getUntracedFunction"                           ".rs.explorer.inspectS4"                           
 [877] ".rs.logErrorMessage"                               ".rs.describeCall"                                 
 [879] ".rs.doListIndex"                                   ".rs.generateFunctionInformation"                  
 [881] ".rs.objectAttributes"                              ".rs.readDataCapture"                              
 [883] ".rs.pathPackage"                                   ".rs.addS3Override"                                
 [885] ".rs.forceUnloadPackageImpl"                        ".rs.shellViewPdf"                                 
 [887] ".rs.executeDebugSource"                            ".rs.reticulate.resolveModule"                     
 [889] ".rs.readApiPref"                                   ".rs.rpc.assemble_data_import"                     
 [891] ".rs.installBuildTools"                             ".rs.packageHelpEncodingImpl"                      
 [893] ".rs.rpc.copy_profile"                              ".rs.quarto.servePort"                             
 [895] ".rs.connectionObserver.connectionClosed"           ".rs.odbcIsWow"                                    
 [897] ".rs.lintDirectory"                                 ".rs.isCRANReposFromSettings"                      
 [899] ".rs.namedVectorAsList"                             ".rs.rpc.get_function_steps"                       
 [901] ".rs.swap"                                          ".rs.endsWith"                                     
 [903] ".rs.readPrefInternal"                              ".rs.assignCachedData"                             
 [905] ".rs.getCompletionsPythonVirtualEnvironments"       ".rs.slotNames"                                    
 [907] ".rs.odbcBundleOdbcinstPathWithOdbcinst"            ".rs.api.terminalExitCode"                         
 [909] ".rs.reticulate.replInitialize"                     ".rs.environmentCallFrameName"                     
 [911] ".rs.getFunctionSourceCode"                         ".rs.rpc.get_rsconnect_account_list"               
 [913] ".rs.rpc.get_package_citations"                     ".rs.getCompletionsNativeRoutine"                  
 [915] ".rs.python.findPythonVirtualEnvironments"          ".rs.which"                                        
 [917] ".rs.getThemeName"                                  ".rs.availablePackagesPendingEnv"                  
 [919] ".rs.createNotebookFromCache"                       ".rs.sanitizeCall"                                 
 [921] ".rs.showSecureDownloadWarning"                     ".rs.recode"                                       
 [923] ".rs.rpc.get_package_install_context"               ".rs.api.writePreference"                          
 [925] ".rs.onAvailablePackagesCached"                     ".rs.api.terminalRunning"                          
 [927] ".rs.rpc.discover_package_dependencies"             ".rs.connectionObserver.traceback"                 
 [929] ".rs.odbcOsBitness"                                 ".rs.onAvailablePackagesPending"                   
 [931] ".rs.rnb.engineToCodeClass"                         ".rs.addins.removeShinyResponseFilter"             
 [933] ".rs.rpc.ensure_file_exists"                        ".rs.stan.copySourceDatabaseToTempfile"            
 [935] ".rs.saveCachedData"                                ".rs.pendingActions"                               
 [937] ".rs.getDataTableByCompletions"                     ".rs.bugReport"                                    
 [939] ".rs.heredoc"                                       ".rs.getCompletionsData"                           
 [941] ".rs.explorer.inspectFunction"                      ".rs.loadedPackagesAndDependencies"                
 [943] ".rs.simulateSourceRefs"                            ".rs.api.terminalList"                             
 [945] ".rs.rpc.get_output_preview"                        ".rs.getS4MethodNamespaceName"                     
 [947] ".rs.rnb.encode"                                    ".rs.sql.getCompletionsFields"                     
 [949] ".rs.odbcBundleInstall"                             ".rs.rpc.register_user_token"                      
 [951] ".rs.hookedPackages"                                ".rs.setNotebookMargins"                           
 [953] ".rs.db.listFields"                                 ".rs.findBreakpointSteps"                          
 [955] ".rs.api.terminalSend"                              ".rs.explorer.createHandle"                        
 [957] ".rs.makeSourceEquivFunction"                       ".rs.initDefaultUserLibrary"                       
 [959] ".rs.explorer.inspectorRegistry"                    ".rs.internal.convertTheme"                        
 [961] ".rs.python.getPythonDescription"                   ".rs.rnb.outputSourceConsole"                      
 [963] ".rs.findNext"                                      ".rs.callSummary"                                  
 [965] ".rs.python.interpreterInfo"                        ".rs.hasConnectAccount"                            
 [967] ".rs.odbcBundleRegisterWindows"                     ".rs.saveGraphicsSnapshot"                         
 [969] ".rs.invokeShinyTutorialViewer"                     ".rs.rpc.show_vignette"                            
 [971] ".rs.suspendSession"                                ".rs.api.selectFile"                               
 [973] ".rs.getDollarNamesMethod"                          ".rs.activateGraphicsDevice"                       
 [975] ".rs.valueDescription"                              ".rs.isTraced"                                     
 [977] ".rs.getSecondaryRepos"                             ".rs.python.findPythonInterpreters"                
 [979] ".rs.executeFunctionInChildProcess"                 ".rs.sql.getCompletions"                           
 [981] ".rs.parseSecondaryReposJson"                       ".rs.explorer.viewObject"                          
 [983] ".rs.formatDataColumnList"                          ".rs.sql.getCompletionsSchemas"                    
 [985] ".rs.api.executeCommand"                            ".rs.getPackageRStudioProtocol"                    
 [987] ".rs.rpc.get_packrat_status"                        ".rs.objectsOnSearchPath"                          
 [989] ".rs.reticulate.matplotlib.showHook"                ".rs.connectionListColumns"                        
 [991] ".rs.rnb.saveHtmlToCache"                           ".rs.themes_static_rules"                          
 [993] ".rs.isViewOverride"                                ".rs.rnb.resolveActiveChunkId"                     
 [995] ".rs.explorer.inspectObjectAttributes"              ".rs.api.sourceMarkers"                            
 [997] ".rs.getConnectionObject"                           ".rs.cutpoints"                                    
 [999] ".rs.acContextTypes"                                ".rs.python.getHelp"                               
 [ reached getOption("max.print") -- omitted 265 entries ]
$.rs.rpc.generate_app_name
function (appTitle, appPath, account) 
{
    name <- ""
    valid <- TRUE
    error <- ""
    tryCatch({
        name <- rsconnect::generateAppName(appTitle = appTitle, 
            appPath = appPath, account = account)
    }, error = function(e) {
        valid <<- FALSE
        error <<- e$message
    })
    list(name = .rs.scalar(name), valid = .rs.scalar(valid), 
        error = .rs.scalar(error))
}
<environment: 0x000001883f4b86b8>

$.rs.scalarListFromFrame
function (frame) 
{
    ret <- list()
    if (is.null(frame)) 
        return(ret)
    cols <- names(frame)
    for (i in seq_len(nrow(frame))) {
        row <- lapply(cols, function(col) {
            if (is.null(frame[i, col])) 
                NULL
            else .rs.scalar(unlist(frame[i, col]))
        })
        names(row) <- cols
        ret[[i]] <- row
    }
    return(ret)
}
<environment: 0x000001883f4b86b8>

$.rs.assignWorkingData
function (cacheKey, obj) 
{
    assign(cacheKey, obj, .rs.WorkingDataEnv)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.replTeardown
function () 
{
    .rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$REPL_TEARDOWN, 
        list())
}
<environment: 0x000001883f4b86b8>

$.rs.deparse
function (object, width.cutoff = 500L, nlines = -1L, collapse = " ") 
{
    deparsed <- deparse(expr = object, width.cutoff = width.cutoff, 
        nlines = nlines)
    deparsed <- gsub("`<(.*?)>`", "<\\1>", deparsed, perl = TRUE)
    paste(deparsed, collapse = collapse)
}
<environment: 0x000001883f4b86b8>

$.rs.scoreMatches
function (strings, string) 
{
    .Call("rs_scoreMatches", strings, string)
}
<environment: 0x000001883f4b86b8>

$.rs.websiteOutputDir
function (siteDir) 
{
    siteGenerator <- rmarkdown::site_generator(siteDir)
    if (!is.null(siteGenerator)) 
        if (siteGenerator$output_dir != ".") 
            file.path(siteDir, siteGenerator$output_dir)
        else siteDir
    else siteDir
}
<environment: 0x000001883f4b86b8>

$.rs.environmentIsLocal
function (env) 
{
    while (!identical(env, emptyenv())) {
        env = parent.env(env)
        if (identical(env, globalenv())) 
            return(TRUE)
    }
    return(FALSE)
}
<bytecode: 0x000001883fd126d8>
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsActiveFrame
function (token, envir) 
{
    currentEnv <- envir
    encounteredEnvs <- list()
    completions <- character()
    types <- numeric()
    empty <- emptyenv()
    while (!(identical(currentEnv, empty) || identical(currentEnv, 
        .GlobalEnv) || identical(currentEnv, .BaseNamespaceEnv))) {
        for (i in seq_along(encounteredEnvs)) {
            if (identical(currentEnv, encounteredEnvs[[i]])) 
                return(.rs.emptyCompletions())
        }
        objects <- objects(currentEnv, all.names = TRUE)
        completions <- c(completions, objects)
        types <- c(types, vapply(objects, USE.NAMES = FALSE, 
            FUN.VALUE = numeric(1), function(object) {
                tryCatch(.rs.getCompletionType(get(object, envir = currentEnv, 
                  inherits = TRUE)), error = function(e) .rs.acCompletionTypes$UNKNOWN)
            }))
        encounteredEnvs <- c(encounteredEnvs, currentEnv)
        currentEnv <- parent.env(currentEnv)
    }
    keep <- .rs.fuzzyMatches(completions, token)
    .rs.makeCompletions(token = token, results = completions[keep], 
        type = types[keep])
}
<bytecode: 0x000001884101d328>
<environment: 0x000001883f4b86b8>

$.rs.showDiagnostics
function () 
{
    diagPath <- shQuote(.rs.normalizePath("~/rstudio-diagnostics"))
    sysName <- Sys.info()[["sysname"]]
    if (identical(sysName, "Windows")) 
        shell.exec(diagPath)
    else if (identical(sysName, "Darwin")) 
        system(paste("open", diagPath))
    else if (nzchar(Sys.which("nautilus"))) 
        system(paste("nautilus", diagPath))
}
<environment: 0x000001883f4b86b8>

$.rs.showPresentationHelpDoc
function (doc) 
{
    if (!is.character(doc)) 
        stop("doc must be of type character")
    invisible(.Call(getNativeSymbolInfo("rs_showPresentationHelpDoc", 
        PACKAGE = ""), doc))
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleCheckPrereqsOsx
function () 
{
    if (!.rs.odbcBundleCheckPrereqsUnixodbc()) {
        if (!.rs.odbcBundleCheckPrereqsBrew()) {
            stop("unixODBC is required but missing, you can install from http://www.unixodbc.org/. ", 
                "Alternatively, install Brew and RStudio will install unixODBC automatically, ", 
                "you can install Brew by running: ", "/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"")
        }
        message("Installing unixODBC...")
        system2("brew", args = list("install", "unixodbc"))
    }
    if (!.rs.odbcBundleCheckPrereqsUnixodbc()) 
        stop("Failed to install unixODBC, please install from www.unixodbc.org")
}
<environment: 0x000001883f4b86b8>

$debugSource
function (fileName, echo = FALSE, encoding = "unknown", local = FALSE) 
{
    invisible(.Call("rs_debugSourceFile", enc2utf8(fileName), 
        encoding, local))
}
<environment: 0x000001883f4b86b8>

$.rs.invokePlumberWindowViewer
function (url) 
{
    invisible(.Call("rs_plumberviewer", url, getwd(), "window", 
        PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"plumberViewerType")
[1] "window"

$.rs.defaultLibraryPath
function () 
{
    .libPaths()[1]
}
<environment: 0x000001883f4b86b8>

$.rs.getAnywhere
function (name, envir = parent.frame()) 
{
    result <- NULL
    if (!length(name)) 
        return(NULL)
    if (is.character(name) && (length(name) != 1 || name == "")) 
        return(NULL)
    if (is.character(name) && regexpr("(", name, fixed = TRUE) > 
        0) 
        return(FALSE)
    quietly <- function(expr) {
        withCallingHandlers(tryCatch(expr, error = function(e) NULL), 
            warning = function(e) invokeRestart("muffleWarning"), 
            message = function(e) invokeRestart("muffleMessage"))
    }
    if (is.character(name) && is.character(envir)) {
        pos <- match(envir, search(), nomatch = -1L)
        if (pos >= 0) {
            object <- quietly(get(name, pos = pos))
            if (!is.null(object)) 
                return(.rs.resolveAliasedSymbol(object))
        }
        if (envir %in% loadedNamespaces()) {
            object <- quietly(get(name, envir = asNamespace(envir)))
            if (!is.null(object)) 
                return(.rs.resolveAliasedSymbol(object))
        }
    }
    if (is.character(name)) {
        name <- quietly(parse(text = .rs.stripSurrounding(name)))
        if (is.null(name)) 
            return(NULL)
    }
    if (is.language(name)) 
        result <- quietly(eval(name, envir = envir))
    .rs.resolveAliasedSymbol(result)
}
<bytecode: 0x000001883c83b818>
<environment: 0x000001883f4b86b8>

$.rs.getVar
function (name) 
{
    envir <- .rs.toolsEnv()
    fullName <- paste(".rs.", name, sep = "")
    envir[[fullName]]
}
<environment: 0x000001883f4b86b8>

$.rs.api.eventTypes
$.rs.api.eventTypes$TYPE_UNKNOWN
[1] 0

$.rs.api.eventTypes$TYPE_GET_EDITOR_SELECTION
[1] 1

$.rs.api.eventTypes$TYPE_SET_EDITOR_SELECTION
[1] 2

$.rs.api.eventTypes$TYPE_DOCUMENT_ID
[1] 3

$.rs.api.eventTypes$TYPE_DOCUMENT_OPEN
[1] 4

$.rs.api.eventTypes$TYPE_DOCUMENT_NEW
[1] 5

$.rs.api.eventTypes$TYPE_FILES_PANE_NAVIGATE
[1] 6

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.registerUserCommand
function (name, shortcuts, fn, overwrite = TRUE) 
{
    if (length(name) != 1 || !is.character(name)) 
        stop("'name' should be a length-one character vector")
    if (!overwrite && exists(name, envir = .rs.userCommands)) {
        stop("'", name, "' is already bound to a command; use 'overwrite = TRUE'", 
            "to overwrite with the new command definition.")
    }
    shortcuts <- unlist(lapply(shortcuts, .rs.normalizeKeyboardShortcut))
    .rs.userCommands[[name]] <- fn
    .Call("rs_registerUserCommand", .rs.scalar(name), shortcuts)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletions
function (line, ctx) 
{
    re_import <- paste("^[[:space:]]*", "(?:from|import)", "[[:space:]]+", 
        "([[:alnum:]._]*)$", sep = "")
    matches <- regmatches(line, regexec(re_import, line, perl = TRUE))[[1]]
    if (length(matches) == 2) 
        return(.rs.python.getCompletionsImports(matches[[2]]))
    re_import_from <- paste("^[[:space:]]*", "from", "[[:space:]]+", 
        "([[:alnum:]._]+)", "[[:space:]]+", "import", "[[:space:]]+", 
        "\\(?", "[[:space:]]*", "([^)]*)", sep = "")
    matches <- regmatches(line, regexec(re_import_from, line, 
        perl = TRUE))[[1]]
    if (length(matches) == 3) {
        module <- matches[[2]]
        imports <- matches[[3]]
        token <- ""
        if (nzchar(imports)) 
            token <- gsub(".*[[:space:],]", "", imports)
        return(.rs.python.getCompletionsImportsFrom(module, token))
    }
    tokens <- .rs.python.tokenize(code = line, exclude = c("whitespace", 
        "comment"), keep.unknown = FALSE)
    if (length(tokens) == 0) 
        return(.rs.python.emptyCompletions())
    cursor <- .rs.python.tokenCursor(tokens)
    cursor$moveToOffset(length(tokens))
    token <- cursor$peek()
    if (token$type %in% "string") {
        if (!cursor$moveToPreviousToken()) 
            return(.rs.python.getCompletionsFiles(token$value))
        if (cursor$tokenValue() == "[") {
            saved <- cursor$peek()
            if (!cursor$moveToPreviousToken()) 
                return(.rs.python.emptyCompletions())
            if (!cursor$moveToStartOfEvaluation()) 
                return(.rs.python.emptyCompletions())
            lhs <- substring(line, cursor$tokenOffset(), saved$offset - 
                1)
            rhs <- gsub("^['\"]|['\"]$", "", token$value)
            tokens <- .rs.python.tokenize(lhs)
            lparen <- Find(function(token) token$value == "(", 
                tokens)
            if (!is.null(lparen)) 
                return(.rs.python.emptyCompletions())
            return(.rs.python.getCompletionsKeys(lhs, rhs))
        }
        return(.rs.python.getCompletionsFiles(token$value))
    }
    maybe_function <- cursor$peek(0)$value %in% c("(", ",") || 
        cursor$peek(-1)$value %in% c("(", ",")
    if (maybe_function) {
        offset <- cursor$cursorOffset()
        repeat {
            if (cursor$bwdToMatchingBracket()) {
                if (!cursor$moveToPreviousToken()) 
                  break
                next
            }
            if (cursor$tokenValue() == "(" && cursor$moveToPreviousToken() && 
                (cursor$tokenValue() == "]" || cursor$tokenType() %in% 
                  "identifier")) {
                endToken <- cursor$peek()
                cursor$moveToStartOfEvaluation()
                startToken <- cursor$peek()
                start <- startToken$offset
                end <- endToken$offset + nchar(endToken$value) - 
                  1
                source <- substring(line, start, end)
                rhs <- if (token$type %in% "identifier") 
                  token$value
                else ""
                return(.rs.python.getCompletionsArguments(source, 
                  rhs))
            }
            if (!cursor$moveToPreviousToken()) 
                break
        }
        cursor$moveToOffset(offset)
    }
    repeat {
        if (cursor$bwdToMatchingBracket()) {
            if (!cursor$moveToPreviousToken()) 
                break
            next
        }
        if (cursor$tokenType() %in% c("string", "identifier") || 
            cursor$tokenValue() %in% ".") {
            lastType <- cursor$tokenType()
            if (!cursor$moveToPreviousToken()) 
                break
            if (lastType == cursor$tokenType()) {
                cursor$moveToNextToken()
                break
            }
            next
        }
        if (!cursor$moveToNextToken()) 
            return(.rs.python.emptyCompletions())
        break
    }
    source <- substring(line, cursor$tokenOffset())
    .rs.python.getCompletionsMain(source, ctx)
}
<environment: 0x000001883f4b86b8>

$.rs.sql.defunctConnections
<environment: 0x000001883f37fd78>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.api.updateDialog
function (...) 
{
    scalarValues <- lapply(list(...), .rs.scalar)
    .rs.enqueClientEvent("update_new_connection_dialog", scalarValues)
    invisible(NULL)
}
<environment: 0x000001883fd39340>

$.rs.rpc.python_interpreter_info
function (pythonPath) 
{
    .rs.python.describeInterpreter(pythonPath)
}
<environment: 0x000001883f4b86b8>

$.rs.isPackageHyperlinkSafe
function (packageName) 
{
    allowed <- setdiff(c(.packages(), "testthat", "rlang", "devtools", 
        "usethis"), c("base", "stats", "utils"))
    .rs.scalar(packageName %in% allowed)
}
<environment: 0x000001883f4b86b8>

$.rs.listIndexedFolders
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L) 
{
    .rs.doListIndex("rs_listIndexedFolders", term, inDirectory, 
        maxCount)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectPythonValue
function (object, context = .rs.explorer.createContext()) 
{
    children <- NULL
    if (context$recursive) {
        children <- if (.rs.explorer.tags$ATTRIBUTES %in% context$tags) 
            .rs.explorer.inspectPythonObject(object, context)
        else if (inherits(object, "python.builtin.dict")) 
            .rs.explorer.inspectPythonDict(object, context)
        else if (.rs.reticulate.isStructSeq(object)) 
            .rs.explorer.inspectPythonObject(object, context)
        else if (inherits(object, c("python.builtin.tuple", "python.builtin.list"))) 
            .rs.explorer.inspectPythonList(object, context)
        else .rs.explorer.inspectPythonObject(object, context)
    }
    .rs.explorer.createInspectionResult(object, context, children)
}
<environment: 0x000001883f4b86b8>

$.rs.invokeShinyPaneViewer
function (url) 
{
    invisible(.Call("rs_shinyviewer", url, getwd(), "pane", NULL, 
        PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"shinyViewerType")
[1] "pane"

$.rs.tryMatchCall
function (method, call) 
{
    tryCatch(suppressWarnings(match.call(method, call)), error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.is_package_hyperlink_safe
function (packageName) 
{
    .rs.isPackageHyperlinkSafe(packageName)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectPythonDict
function (object, context = .rs.explorer.createContext()) 
{
    children <- vector("list", 0L)
    reticulate::iterate(object, function(key) {
        if (!inherits(key, c("python.builtin.str", "python.builtin.int"))) 
            return()
        item <- reticulate::py_get_item(object, key, silent = TRUE)
        if (is.null(item)) 
            return()
        name <- as.character(key)
        access <- sprintf("#[\"%s\"]", name)
        tags <- character()
        childContext <- .rs.explorer.createChildContext(context, 
            name, access, tags)
        children[[length(children) + 1]] <<- .rs.explorer.inspectObject(item, 
            childContext)
    })
    children
}
<environment: 0x000001883f4b86b8>

$.rs.removeTheme
function (name, themeList) 
{
    currentTheme <- .rs.api.getThemeInfo()$editor
    lowerCaseName <- tolower(name)
    if (is.null(themeList[[lowerCaseName]])) {
        stop("The specified theme \"", name, "\" does not exist.")
    }
    if (identical(lowerCaseName, tolower(currentTheme))) {
        nextTheme <- if (themeList[[lowerCaseName]]$isDark) 
            "Tomorrow Night"
        else "TextMate (default)"
        warning("Removing the active theme - setting the current theme to ", 
            nextTheme)
        .rs.applyTheme(nextTheme, themeList)
    }
    filePath <- .rs.getThemeDirFromUrl(themeList[[lowerCaseName]]$url)
    if (is.null(filePath)) {
        stop("Please verify that the theme is installed as a custom theme.")
    }
    if (!file.remove(filePath)) {
        if (file.exists(filePath)) {
            justFileName <- basename(filePath)
            actualPath <- normalizePath(filePath, mustWork = FALSE, 
                winslash = "/")
            globalPath <- normalizePath(.rs.getThemeInstallDir(TRUE), 
                mustWork = FALSE, winslash = "/")
            if (identical(file.path(globalPath, justFileName), 
                actualPath)) {
                stop("The specified theme is installed for all users. Please contact your system administrator to remove the theme.")
            }
            else {
                stop("Please check your file system permissions.")
            }
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.quarto.editorConfig
function (editor) 
{
    scalarChar <- function(x) .rs.scalar(as.character(x))
    if (!is.null(editor$mode)) {
        editor$mode <- scalarChar(editor$mode)
    }
    if (is.list(editor$markdown)) {
        if (!is.null(editor$markdown$wrap)) {
            editor$markdown$wrap <- scalarChar(editor$markdown$wrap)
        }
        if (!is.null(editor$markdown$canonical)) {
            editor$markdown$canonical <- scalarChar(editor$markdown$canonical)
        }
        if (is.list(editor$markdown$references)) {
            if (!is.null(editor$markdown$references$location)) {
                editor$markdown$references$location <- scalarChar(editor$markdown$references$location)
            }
            if (!is.null(editor$markdown$references$prefix)) {
                editor$markdown$references$prefix <- scalarChar(editor$markdown$references$prefix)
            }
            if (!is.null(editor$markdown$references$links)) {
                editor$markdown$references$links <- .rs.scalar(as.logical(editor$markdown$references$links))
            }
        }
    }
    return(editor)
}
<environment: 0x000001883f4b86b8>

$.rs.getAutoSnapshotCmd
function (dir) 
{
    paste(packrat:::buildSnapshotHookCall(dir), collapse = "; ")
}
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.connectionOpened
function (type, host, displayName, icon = NULL, connectCode, 
    disconnect, listObjectTypes, listObjects, listColumns, previewObject, 
    connectionObject, actions = NULL) 
{
    tryCatch(.rs.connectionObserver.connectionOpenedImpl(type, 
        host, displayName, icon, connectCode, disconnect, listObjectTypes, 
        listObjects, listColumns, previewObject, connectionObject, 
        actions), error = .rs.connectionObserver.connectionError)
}
<environment: 0x000001883f4b86b8>

$.rs.graphics.supportedBackends
function () 
{
    c(if (Sys.info()[["sysname"]] == "Windows") "windows", if (.rs.hasCapability("aqua")) "quartz", 
        if (.rs.hasCapability("cairo")) c("cairo", "cairo-png"), 
        "ragg")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.connect_rsconnect_account
function (accountCmd) 
{
    cmd <- parse(text = accountCmd)
    eval(cmd, envir = globalenv())
}
<environment: 0x000001883f4b86b8>

$.rs.api.unregisterChunkCallback
function (id = NULL) 
{
    if (length(.rs.notebookChunkCallbacks) == 0) 
        warning("No registered callbacks found")
    else if (!is.null(id) && !exists(id, envir = .rs.notebookChunkCallbacks)) 
        warning("Handle not found.")
    else {
        id <- ls(envir = .rs.notebookChunkCallbacks)
        rm(list = id, envir = .rs.notebookChunkCallbacks)
    }
}
<environment: 0x000001883fe2ea38>

$.rs.api.convertTheme
function (themePath, add = TRUE, outputLocation = NULL, apply = FALSE, 
    force = FALSE, globally = FALSE) 
{
    missingLibraryMsg <- "Taking this action requires the %pkg% library. Please run 'install.packages(\"%pkg%\")' before continuing."
    if (!suppressWarnings(require("xml2", quietly = TRUE))) {
        stop(gsub("%pkg%", "xml2", missingLibraryMsg, fixed = TRUE))
    }
    tryCatch(.rs.convertTheme(themePath, add, outputLocation, 
        apply, force, globally), error = function(e) {
        stop("Unable to convert the tmTheme to an rstheme. ", 
            e$message)
    })
}
<environment: 0x000001883f3ce588>

$.rs.isSourceCall
function (call) 
{
    symbols <- list(quote(source), quote(debugSource))
    fun <- call[[1L]]
    for (symbol in symbols) if (identical(fun, symbol)) 
        return(TRUE)
    FALSE
}
<environment: 0x000001883f4b86b8>

$.rs.appendCompletions
function (old, new) 
{
    old[["suggestOnAccept"]] <- .rs.appendCompletionsOptionalElement(old, 
        new, "suggestOnAccept", FALSE)
    for (name in c("results", "packages", "quote", "type", "meta", 
        "context")) old[[name]] <- c(old[[name]], new[[name]])
    drop <- intersect(which(duplicated(old$results)), which(duplicated(old$packages)))
    if (length(drop)) {
        for (name in c("results", "packages", "quote", "type", 
            "meta", "context")) old[[name]] <- old[[name]][-c(drop)]
        if (!is.null(old[["suggestOnAccept"]])) {
            old[["suggestOnAccept"]] <- old[["suggestOnAccept"]][-c(drop)]
        }
    }
    if (length(new$token) && new$token != "") 
        old$token <- new$token
    if (length(new$fguess) && new$fguess != "") 
        old$fguess <- new$fguess
    if (length(new$excludeOtherCompletions) && new$excludeOtherCompletions) 
        old$excludeOtherCompletions <- new$excludeOtherCompletions
    if (length(new$excludeOtherArgumentCompletions) && new$excludeOtherArgumentCompletions) 
        old$excludeOtherArgumentCompletions <- new$excludeOtherArgumentCompletions
    if (length(new$overrideInsertParens) && new$overrideInsertParens) 
        old$overrideInsertParens <- new$overrideInsertParens
    if (length(new$cacheable) && !new$cacheable) 
        old$cacheable <- new$cacheable
    if (length(new$helpHandler)) 
        old$helpHandler <- new$helpHandler
    old
}
<bytecode: 0x000001883fcc5a38>
<environment: 0x000001883f4b86b8>

$.rs.emitPackageInformation
function (package) 
{
    invisible(capture.output(suppressPackageStartupMessages(suppressWarnings({
        has00LOCK <- FALSE
        for (libPath in .libPaths()) {
            globalLockPath <- file.path(libPath, "00LOCK")
            pkgLockPath <- file.path(libPath, paste("00LOCK", 
                basename(package), sep = "-"))
            if (file.exists(globalLockPath) || file.exists(pkgLockPath)) {
                has00LOCK <- TRUE
                break
            }
        }
        success <- if (has00LOCK) FALSE else library(package, 
            character.only = TRUE, quietly = TRUE, logical.return = TRUE)
    }))))
    if (!success) 
        return(.rs.emptyFunctionInfo())
    ns <- asNamespace(package)
    exports <- getNamespaceExports(ns)
    objects <- mget(exports, ns, inherits = TRUE)
    isFunction <- vapply(objects, FUN.VALUE = logical(1), USE.NAMES = FALSE, 
        is.function)
    functions <- objects[isFunction]
    types <- vapply(objects, FUN.VALUE = numeric(1), USE.NAMES = FALSE, 
        .rs.getCompletionType)
    functionInfo <- lapply(functions, .rs.generateFunctionInformation)
    datasets <- .rs.listDatasetsProvidedByPackage(package)
    output <- list(package = I(package), exports = exports, types = types, 
        function_info = functionInfo, datasets = datasets)
    flush.console()
    json <- paste("#!json:", .rs.toJSON(output))
    writeLines(c("", json, ""))
    flush.console()
    invisible(output)
}
<environment: 0x000001883f4b86b8>

$.rs.files.savedBindings
<environment: 0x000001883da43770>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.showHelpTopicFunction
function (topic, package) 
{
    if (is.null(package) && grepl(":{2,3}", topic, perl = TRUE)) {
        splat <- strsplit(topic, ":{2,3}", perl = TRUE)[[1]]
        topic <- splat[[2]]
        package <- splat[[1]]
    }
    if (!is.null(package)) 
        requireNamespace(package, quietly = TRUE)
    call <- .rs.makeHelpCall(topic, package)
    print(eval(call, envir = parent.frame()))
}
<environment: 0x000001883f4b86b8>

$.rs.notebookConditions.onWarning
function (condition) 
{
    prefix <- gettext("Warning:", domain = "R")
    message <- paste(condition$message, collapse = "\n")
    full <- paste(prefix, message)
    .Call("rs_signalNotebookCondition", 1L, full, PACKAGE = "(embedding)")
    invokeRestart("muffleWarning")
}
<environment: 0x000001883f4b86b8>

$.rs.getS3MethodsForFunction
function (func, envir = parent.frame()) 
{
    tryCatch({
        call <- call("methods", func)
        as.character(suppressWarnings(eval(call, envir = envir)))
    }, error = function(e) character())
}
<environment: 0x000001883f4b86b8>

$.rs.api.stopJob
function (job) 
{
    .rs.api.executeJobAction(job, "stop")
}
<environment: 0x000001883f089550>

$.rs.format
function (object, ...) 
{
    if (is.symbol(object)) 
        as.character(object)
    else base::format.default(object, ...)
}
<environment: 0x000001883f4b86b8>

$.rs.strsplit
function (x, pattern, ..., simplify = TRUE) 
{
    m <- gregexpr(pattern, x, ...)
    matches <- regmatches(x, m, invert = TRUE)
    if (simplify && length(matches) == 1) 
        matches[[1]]
    else matches
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.renv_init
function (project) 
{
    .rs.executeFunctionInChildProcess(callback = .rs.renv.initCallback, 
        data = list(repos = getOption("repos")), workingDir = project)
}
<environment: 0x000001883f4b86b8>

$.rs.api.sendRequest
function (request) 
{
    .Call("rs_sendApiRequest", request, PACKAGE = "(embedding)")
}
<environment: 0x000001883fe49d90>

$.rs.add_operator_color
function (content, name, isDark = FALSE, overrideMap = list()) 
{
    color <- overrideMap[[name]]
    if (is.null(color)) 
        color <- if (isDark) 
            "#AAAAAA"
        else "#888888"
    .rs.add_content(content, ".ace_keyword.ace_operator {", "  color: %s !important;", 
        "}", replace = color)
}
<environment: 0x000001883f4b86b8>

$.rs.base64encode
function (data, binary = FALSE) 
{
    .Call("rs_base64encode", data, binary)
}
<environment: 0x000001883f4b86b8>

$.rs.api.setSelectionRanges
function (ranges, id = "") 
{
    ranges <- .rs.validateAndTransformLocation(ranges)
    data <- list(ranges = ranges, id = .rs.scalar(id))
    .rs.enqueEditorClientEvent("set_selection_ranges", data)
    invisible(data)
}
<environment: 0x000001883fd18628>

$.rs.asCaseInsensitiveRegex
function (string) 
{
    if (string == "") 
        return(string)
    splat <- strsplit(string, "", fixed = TRUE)[[1]]
    lowerSplat <- tolower(splat)
    upperSplat <- toupper(splat)
    result <- vapply(1:length(splat), FUN.VALUE = character(1), 
        USE.NAMES = FALSE, function(i) {
            if (lowerSplat[i] == upperSplat[i]) 
                splat[i]
            else paste("[", lowerSplat[i], upperSplat[i], "]", 
                sep = "")
        })
    paste(result, collapse = "")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleCheckPrereqsBrew
function () 
{
    identical(suppressWarnings(system2("brew", stdout = getOption("odbc.installer.verbose", 
        FALSE), stderr = getOption("odbc.installer.verbose", 
        FALSE))), 1L)
}
<environment: 0x000001883f4b86b8>

$.rs.getIndexedFiles
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L) 
{
    .rs.doGetIndex(term, inDirectory, maxCount, .rs.listIndexedFiles)
}
<environment: 0x000001883f4b86b8>

$.rs.rVersionString
function () 
{
    as.character(getRversion())
}
<environment: 0x000001883f4b86b8>

$.rs.getThemes
function () 
{
    themeList <- .Call("rs_getThemes", PACKAGE = "(embedding)")
    for (i in seq_along(themeList)) {
        Encoding(themeList[[i]]$name) <- "UTF-8"
        Encoding(themeList[[i]]$url) <- "UTF-8"
    }
    themeList
}
<environment: 0x000001883f4b86b8>

$.rs.recordHtmlWidget
function (x, htmlfile, depfile) 
{
    .Call("rs_recordHtmlWidget", htmlfile, depfile, list(classes = class(x), 
        sizingPolicy = if (is.list(x)) x$sizingPolicy else list()))
}
<environment: 0x000001883f4b86b8>

$.rs.api.viewer
function (url, height = NULL) 
{
    if (!is.character(url) || (length(url) != 1)) 
        stop("url must be a single element character vector.")
    if (identical(height, "maximize")) 
        height <- -1
    if (!is.null(height) && (!is.numeric(height) || (length(height) != 
        1))) 
        stop("height must be a single element numeric vector or 'maximize'.")
    invisible(.Call("rs_viewer", url, height, PACKAGE = "(embedding)"))
}
<environment: 0x000001883fcf9b98>

$.rs.lineDataList
function (srcref) 
{
    list(line_number = .rs.scalar(srcref[1]), end_line_number = .rs.scalar(srcref[3]), 
        character_number = .rs.scalar(srcref[5]), end_character_number = .rs.scalar(srcref[6]))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.search
function (query) 
{
    exactMatch <- help(query, help_type = "html")
    if (length(exactMatch) == 1) {
        print(exactMatch)
        return()
    }
    fmt <- "help/doc/html/Search?pattern=%s&title=1&keyword=1&alias=1"
    sprintf(fmt, utils::URLencode(query, reserved = TRUE))
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.describeObjectType
function (object) 
{
    builtins <- reticulate::import_builtins(convert = TRUE)
    builtins$type(object)$`__name__`
}
<environment: 0x000001883f4b86b8>

$.rs.getCustomRenderFunction
function (file) 
{
    lines <- readLines(file, warn = FALSE)
    properties <- .rs.getSourceDocumentProperties(file)
    if (identical(properties$encoding, "UTF-8")) 
        Encoding(lines) <- "UTF-8"
    yamlFrontMatter <- tryCatch(rmarkdown:::parse_yaml_front_matter(lines), 
        error = function(e) {
            list()
        })
    if (is.character(yamlFrontMatter[["knit"]])) 
        yamlFrontMatter[["knit"]][[1]]
    else if (!is.null(yamlFrontMatter$runtime) && grepl("^shiny", 
        yamlFrontMatter$runtime)) {
        tryCatch({
            outputFormat <- rmarkdown:::output_format_from_yaml_front_matter(lines)
            formatFunction <- eval(parse(text = outputFormat$name), 
                envir = asNamespace("rmarkdown"))
            if (identical(tolower(tools::file_ext(rmarkdown:::pandoc_output_file("shiny", 
                formatFunction()$pandoc))), "html")) 
                "rmarkdown::run"
            else ""
        }, error = function(e) {
            ""
        })
    }
    else {
        if (!.rs.isREADME(file)) {
            siteGenerator <- tryCatch(rmarkdown::site_generator(file), 
                error = function(e) NULL)
            if (!is.null(siteGenerator)) 
                "rmarkdown::render_site"
            else ""
        }
        else {
            ""
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.documentSaveAll
function () 
{
    .Call("rs_requestDocumentSave", NULL, PACKAGE = "(embedding)")
}
<environment: 0x000001883fd7caf0>

$.rs.hasPythonStackTrace
function (func) 
{
    grepl("^py_call_impl\\(", func) && .rs.isPackageVersionInstalled("reticulate", 
        "0.7.0.9005") && !is.null(reticulate::py_last_error())
}
<environment: 0x000001883f4b86b8>

$.rs.jsonEscapeString
function (value) 
{
    if (is.na(value)) 
        return("null")
    chars <- strsplit(value, "", fixed = TRUE)[[1]]
    chars <- vapply(chars, function(x) {
        if (x %in% c("\"", "\\", "/")) 
            paste("\\", x, sep = "")
        else if (length(charToRaw(x)) == 1 && charToRaw(x) < 
            32) 
            paste("\\u", toupper(format(as.hexmode(as.integer(charToRaw(x))), 
                width = 4)), sep = "")
        else x
    }, character(1))
    paste(chars, sep = "", collapse = "")
}
<environment: 0x000001883f4b86b8>

$.rs.parseStyles
function (styles) 
{
    css <- list()
    fontStyle <- if (is.null(styles$fontStyle)) 
        ""
    else styles$fontStyle
    if (grepl("underline", fontStyle)) {
        css[["text-decoration"]] = "underline"
    }
    if (grepl("italic", fontStyle)) {
        css[["font-style"]] <- "italic"
    }
    if (grepl("bold", fontStyle)) {
        css[["font-weight"]] <- "bold"
    }
    if (!is.null(styles$foreground)) {
        css[["color"]] <- .rs.parseColor(styles$foreground)
    }
    if (!is.null(styles$background)) {
        css[["background-color"]] <- .rs.parseColor(styles$background)
    }
    css
}
<environment: 0x000001883f4b86b8>

$.rs.python.invalidInterpreter
function (path, type, reason) 
{
    list(path = .rs.createAliasedPath(path), type = type, version = NULL, 
        description = NULL, valid = FALSE, reason = reason)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_set_ref_class_call
function (call) 
{
    parsed <- .rs.tryParseCall(call)
    if (is.null(parsed)) 
        return(list())
    matched <- .rs.tryMatchCall(methods::setRefClass, parsed)
    if (is.null(matched)) 
        return(list())
    Class <- .rs.extractElement(matched, "Class", "")
    field.names <- character()
    field.types <- character()
    fields <- .rs.extractElement(matched, "fields")
    if (length(fields) > 1) {
        field.names <- names(fields)[-1]
        field.types <- unlist(lapply(2:length(fields), function(i) {
            if (is.character(fields[[i]])) 
                fields[[i]]
            else ""
        }))
    }
    methods <- .rs.extractElement(matched, "methods")
    method.names <- if (length(methods)) 
        names(methods)[-1]
    else character()
    list(Class = Class, field.names = field.names, field.types = field.types, 
        method.names = method.names)
}
<environment: 0x000001883f4b86b8>

$.rs.whichIsSubsequence
function (strings, string) 
{
    which(.rs.isSubsequence(strings, string))
}
<environment: 0x000001883f4b86b8>

$.rs.python.getFunctionArguments
function (object) 
{
    inspect <- reticulate::import("inspect", convert = TRUE)
    if (inspect$isclass(object)) {
        init <- .rs.tryCatch(reticulate::py_get_attr(object, 
            "__init__"))
        if (inherits(init, "error")) 
            return(.rs.python.emptyCompletions())
        arguments <- .rs.tryCatch(inspect$getargspec(init)$args)
        if (inherits(arguments, "error")) 
            return(.rs.python.emptyCompletions())
        return(setdiff(arguments, "self"))
    }
    methods <- list(function() inspect$getargspec(object)$args, 
        function() .rs.python.getNumpyFunctionArguments(object))
    for (method in methods) {
        arguments <- .rs.tryCatch(method())
        if (!inherits(arguments, "error")) 
            return(arguments)
    }
    character()
}
<environment: 0x000001883f4b86b8>

$.rs.fromJSON
function (string) 
{
    .Call("rs_fromJSON", string)
}
<environment: 0x000001883f4b86b8>

$.rs.getRMemoryUsed
function () 
{
    mem_used <- gc()
    cons_size <- .Machine$sizeof.pointer * 7
    cons_kb <- (mem_used["Ncells", "used"] * cons_size)/1024
    vector_kb <- mem_used["Vcells", "used"]/128
    list(cons = .rs.scalar(round(cons_kb)), vector = .rs.scalar(round(vector_kb)))
}
<environment: 0x000001883f4b86b8>

$.rs.initHelp
function (port, isDesktop) 
{
    setHelpPort <- function() {
        if (.rs.httpdPortIsFunction()) {
            tools:::httpdPort(port)
        }
        else {
            env <- environment(tools::startDynamicHelp)
            unlockBinding("httpdPort", env)
            assign("httpdPort", port, envir = env)
            lockBinding("httpdPort", env)
        }
    }
    if (isDesktop) {
        if (.rs.httpdPort() <= 0L) 
            suppressWarnings(suppressMessages(tools::startDynamicHelp()))
        if (.rs.httpdPort() <= 0L) {
            setHelpPort()
            return(TRUE)
        }
        else {
            return(FALSE)
        }
    }
    else {
        if (.rs.httpdPort() > 0L) 
            suppressMessages(tools::startDynamicHelp(start = FALSE))
        setHelpPort()
        return(TRUE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.tutorialRun
function (name, package, shiny_args = NULL) 
{
    .rs.tutorial.runTutorial(name, package, shiny_args)
}
<environment: 0x000001883fe4e8a0>

$.rs.rpc.stan_get_completions
function (line) 
{
    .rs.stan.getCompletions(line)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_dplyr_join_completions_string
function (token, string, cursorPos) 
{
    result <- tryCatch(expr = {
        parsed <- parse(text = string)[[1]]
        verb <- as.character(parsed[[1]])
        func <- get(verb, envir = asNamespace("dplyr"))
        matched <- .rs.matchCall(func, parsed)
        leftName <- as.character(matched[["x"]])
        rightName <- as.character(matched[["y"]])
        .rs.getDplyrJoinCompletions(token, leftName, rightName, 
            verb, cursorPos, parent.frame())
    }, error = function(e) {
        .rs.emptyCompletions()
    })
    result
}
<environment: 0x000001883f4b86b8>

$.rs.bookdown.frontMatterValue
function (input_dir, value) 
{
    wd <- getwd()
    on.exit(setwd(wd), add = TRUE)
    setwd(input_dir)
    files <- bookdown:::source_files()
    if (length(files) > 0) {
        index <- files[[1]]
        front_matter <- rmarkdown::yaml_front_matter(index)
        if (is.character(front_matter[[value]])) 
            front_matter[[value]]
        else if (is.logical(front_matter[[value]])) 
            paste0("LOGICAL:", front_matter[[value]])
        else character()
    }
    else {
        character()
    }
}
<environment: 0x000001883f4b86b8>

$.rs.initHtmlCapture
function (outputFolder, libraryFolder, chunkOptions) 
{
    .rs.rnb.setHtmlCaptureContext(outputFolder = outputFolder, 
        libraryFolder = libraryFolder, chunkOptions = chunkOptions)
    hooks <- .rs.rnb.htmlCaptureHooks()
    .rs.enumerate(hooks, function(key, value) {
        .rs.addS3Override(key, value)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_new_connection_context
function () 
{
    connectionList <- c(list(), .rs.connectionReadSnippets(), 
        .rs.connectionReadDSN(), .rs.connectionReadPackages(), 
        .rs.connectionReadOdbc(), .rs.connectionReadInstallers(), 
        .rs.connectionReadPackageInstallers())
    connectionList <- Filter(function(e) !is.null(e), connectionList)
    connectionNames <- list()
    for (i in seq_along(connectionList)) {
        entryName <- connectionList[[i]]$name
        if (!is.null(connectionNames[[entryName]])) {
            existingDriver <- connectionNames[[entryName]]
            withRStudioName <- paste(entryName, .rs.connectionOdbcRStudioDriver(), 
                sep = "")
            if (identical(as.character(connectionList[[i]]$type), 
                "Install") && !identical(as.character(existingDriver$installer), 
                "RStudio") && is.null(connectionNames[[withRStudioName]])) {
                connectionList[[i]]$name <- entryName <- .rs.scalar(withRStudioName)
            }
            else {
                connectionList[[i]]$remove <- TRUE
            }
        }
        if (is.null(connectionNames[[entryName]])) {
            connectionNames[[entryName]] <- connectionList[[i]]
        }
    }
    connectionList <- Filter(function(e) !identical(e$remove, 
        TRUE), connectionList)
    context <- list(connectionsList = unname(connectionList))
    context
}
<environment: 0x000001883f4b86b8>

$.rs.onAvailablePackagesStale
function (reposString) 
{
    .rs.availablePackagesEnv[[reposString]] <- NULL
    repos <- getOption("repos")
    repos <- repos[repos != "@CRAN@"]
    paths <- vapply(repos, function(url) {
        sprintf("%s/repos_%s.rds", tempdir(), URLencode(contrib.url(url), 
            TRUE))
    }, FUN.VALUE = character(1))
    if (all(file.exists(paths))) {
        packages <- if (getRversion() >= "3.5") 
            available.packages(max_repo_cache_age = Inf)
        else available.packages()
        attr(packages, "time") <- Sys.time()
        .rs.availablePackagesEnv[[reposString]] <- packages
        packages
    }
    dir <- tempfile("rstudio-available-packages-")
    dir.create(dir, showWarnings = FALSE)
    .rs.availablePackagesPendingEnv[[reposString]] <- dir
    saveRDS(Sys.time(), file = file.path(dir, "time.rds"))
    owd <- setwd(dir)
    on.exit(setwd(owd), add = TRUE)
    template <- .rs.trimCommonIndent("\n      options(repos = %s, pkgType = %s)\n      packages <- available.packages()\n      attr(packages, \"time\") <- Sys.time()\n      saveRDS(packages, file = \"packages.rds\")\n   ")
    script <- sprintf(template, .rs.deparse(getOption("repos")), 
        .rs.deparse(getOption("pkgType")))
    .rs.runAsyncRProcess(script, onCompleted = function(exitStatus) {
        if (exitStatus) 
            return()
        available <- .rs.onAvailablePackagesReady(reposString)
        data <- list(ready = .rs.scalar(TRUE), packages = rownames(available))
        .rs.enqueClientEvent("available_packages_ready", data)
    })
    return(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleOdbcinstPathUseHome
function () 
{
    normalizePath("~/.odbcinst.ini", mustWork = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.renv.readLockfilePackages
function (project) 
{
    lockpath <- file.path(project, "renv.lock")
    lockfile <- renv:::renv_lockfile_read(lockpath)
    packages <- renv:::renv_records(lockfile)
    filtered <- lapply(packages, `[`, c("Package", "Version", 
        "Source"))
    df <- .rs.rbindList(filtered)
    rownames(df) <- NULL
    df
}
<environment: 0x000001883f4b86b8>

$.rs.api.systemUsername
function () 
{
    .Call("rs_systemUsername", PACKAGE = "(embedding)")
}
<environment: 0x000001883fe29cf8>

$.rs.api.terminalKill
function (id) 
{
    if (is.null(id) || !is.character(id)) 
        stop("'id' must be a character vector")
    .Call("rs_terminalKill", id)
    invisible(NULL)
}
<environment: 0x000001883fdcd5e0>

$.rs.rpc.get_rmd_output_info
function (target) 
{
    return(.rs.getRmdOutputInfo(target))
}
<environment: 0x000001883f4b86b8>

$.rs.readUiPref
function (prefName) 
{
    .rs.readPrefInternal("rs_readUserPref", prefName)
}
<environment: 0x000001883f4b86b8>

$.rs.api.previewRd
function (rdFile) 
{
    if (!is.character(rdFile) || (length(rdFile) != 1)) 
        stop("rdFile must be a single element character vector.")
    if (!file.exists(rdFile)) 
        stop("The specified rdFile ' ", rdFile, "' does not exist.")
    invisible(.Call("rs_previewRd", rdFile, PACKAGE = "(embedding)"))
}
<environment: 0x000001883fced398>

$.rs.isKnitrObject
function (object) 
{
    if (!("knitr" %in% loadedNamespaces())) 
        return(FALSE)
    ns <- asNamespace("knitr")
    if (identical(environment(object), ns)) 
        return(TRUE)
    parent <- tryCatch(parent.env(environment(object)), error = function(e) NULL)
    if (identical(parent, ns)) 
        return(TRUE)
    return(FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.availablePackages
function () 
{
    repos <- getOption("repos")
    if (length(repos) == 0) {
        value <- available.packages()
        attr(value, "time") <- Sys.time()
        return(list(state = "CACHED", value = value))
    }
    reposString <- paste(deparse(repos), collapse = " ")
    state <- .rs.availablePackagesState(reposString)
    value <- switch(state, STALE = .rs.onAvailablePackagesStale(reposString), 
        PENDING = .rs.onAvailablePackagesPending(reposString), 
        CACHED = .rs.onAvailablePackagesCached(reposString), 
        NULL)
    list(state = state, value = value)
}
<environment: 0x000001883f4b86b8>

$.rs.api.selectionGet
function (id = NULL) 
{
    payload <- list(doc_id = .rs.scalar(id))
    request <- .rs.api.createRequest(type = .rs.api.eventTypes$TYPE_GET_EDITOR_SELECTION, 
        sync = TRUE, target = .rs.api.eventTargets$TYPE_ACTIVE_WINDOW, 
        payload = payload)
    .rs.api.sendRequest(request)
}
<environment: 0x000001883fe5c520>

$.rs.includesForLinkingTo
function (linkingTo) 
{
    includes <- character()
    linkingTo <- .rs.parseLinkingTo(linkingTo)
    for (pkg in linkingTo) {
        includeDir <- if (identical(pkg, "R")) 
            R.home("include")
        else system.file("include", package = pkg)
        if (file.exists(includeDir)) {
            includes <- c(includes, paste("-I", .rs.asBuildPath(includeDir), 
                sep = ""))
        }
    }
    includes
}
<environment: 0x000001883f4b86b8>

$.rs.parseLinkingTo
function (linkingTo) 
{
    if (is.null(linkingTo)) 
        return(character())
    linkingTo <- strsplit(linkingTo, "\\s*\\,")[[1]]
    result <- gsub("\\s", "", linkingTo)
    gsub("\\(.*", "", result)
}
<environment: 0x000001883f4b86b8>

$.rs.extractRmdFromNotebook
function (notebook) 
{
    parsed <- try(rmarkdown::parse_html_notebook(notebook), silent = TRUE)
    if (inherits(parsed, "try-error") || is.null(parsed$rmd)) {
        return("")
    }
    return(paste(parsed$rmd, collapse = ifelse(identical(.Platform$OS.type, 
        "windows"), "\r\n", "\n")))
}
<environment: 0x000001883f4b86b8>

$.rs.isDefaultTheme
function (themeUrl) 
{
    grepl("^theme/default/.*\\.rstheme$", themeUrl, ignore.case = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.profilesPath
function () 
{
    .Call("rs_profilesPath", PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.quartoFileResources
function (target) 
{
    .Call("rs_quartoFileResources", target)
}
<environment: 0x000001883f4b86b8>

$.rs.hasFileMonitor
function () 
{
    .Call("rs_hasFileMonitor")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_theme_name
function (themeFile) 
{
    Encoding(themeFile) <- "UTF-8"
    lines <- readLines(themeFile, encoding = "UTF-8")
    .rs.scalar(.rs.getThemeName(paste0(lines, collapse = "\n"), 
        themeFile))
}
<environment: 0x000001883f4b86b8>

$.rs.isValidShortcut
function (shortcut) 
{
    if (!is.character(shortcut)) 
        return(FALSE)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.connectionFiles
function (include, defaultPath) 
{
    connectionFiles <- list()
    if (!is.null(defaultPath)) {
        connectionFiles <- list.files(defaultPath)
    }
    files <- lapply(connectionFiles, function(file) {
        fullPath <- file.path(defaultPath, file)
    })
    names(files) <- gsub(include, "", connectionFiles)
    files <- files[grepl(include, files)]
    sapply(files, normalizePath)
}
<environment: 0x000001883f4b86b8>

$.rs.uniqueLibraryPaths
function () 
{
    libPaths <- .libPaths()
    if (!identical(.Platform$OS.type, "windows")) 
        libPaths <- .rs.normalizePath(libPaths)
    uniqueLibPaths <- subset(libPaths, !duplicated(libPaths))
    return(uniqueLibPaths)
}
<environment: 0x000001883f4b86b8>

$.rs.python.tokenize
function (code, exclude = character(), keep.unknown = TRUE) 
{
    tokens <- list()
    rules <- .rs.python.tokenizationRules()
    raw <- charToRaw(code)
    n <- length(raw)
    offset <- 1
    while (offset <= n) {
        matched <- FALSE
        for (rule in rules) {
            pattern <- paste("^(?:", rule$pattern, ")", sep = "")
            match <- grepRaw(pattern, raw, offset = offset, value = TRUE)
            if (length(match) == 0) 
                next
            matched <- TRUE
            token <- .rs.python.token(rawToChar(match), rule$type, 
                offset)
            if (!token$type %in% exclude) 
                tokens[[length(tokens) + 1]] <- token
            offset <- offset + length(match)
            break
        }
        if (!matched) {
            token <- .rs.python.token(rawToChar(raw[[offset]]), 
                "unknown", offset)
            if (keep.unknown) 
                tokens[[length(tokens) + 1]] <- token
            offset <- offset + 1
        }
    }
    class(tokens) <- "tokens"
    tokens
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.cache
<environment: 0x000001883d406cd8>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.reticulate.describeObjectContents
function (object) 
{
    tryCatch(.rs.reticulate.describeObjectContentsImpl(object), 
        error = warning)
}
<environment: 0x000001883f4b86b8>

$.rs.platform.isLinux
[1] FALSE

$.rs.getPackageFunction
function (name, packageName) 
{
    tryCatch(eval(parse(text = paste(packageName, ":::", name, 
        sep = ""))), error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.forceUnloadForPackageInstall
function (pkgs) 
{
    pkgs <- .rs.loadedPackagesAndDependencies(pkgs)
    sapply(pkgs, .rs.forceUnloadPackage)
    pkgs
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_args
function (name, src, helpHandler) 
{
    if (grepl("::", name) && identical(src, "")) {
        bits <- strsplit(name, "::")[[1L]]
        if (length(bits) == 2L) {
            name <- bits[2L]
            src <- bits[1L]
        }
    }
    if (nzchar(helpHandler)) {
        helpHandlerFunc <- tryCatch(eval(parse(text = helpHandler)), 
            error = function(e) NULL)
        if (!is.function(helpHandlerFunc)) 
            return(NULL)
        help <- tryCatch(helpHandlerFunc("completion", name, 
            src), error = function(e) NULL)
        if (is.null(help)) 
            return(NULL)
        signature <- help$signature
        if (!is.null(signature)) {
            paren <- regexpr("\\(", signature)[[1]]
            if (paren != -1) 
                signature <- substring(signature, paren)
        }
        return(.rs.scalar(signature))
    }
    isUtils <- identical(src, "package:utils") || identical(src, 
        "utils")
    if (isUtils) {
        if (identical(name, "write.csv") || identical(name, "write.csv2")) {
            name <- "write.table"
        }
    }
    envir <- .rs.tryCatch(.rs.resolveEnvironment(src))
    if (is.environment(envir)) {
        method <- .rs.tryCatch(get(name, envir = envir, mode = "function"))
        if (is.function(method)) {
            signature <- .rs.getSignature(method)
            result <- sub("function ", "", signature)
            return(.rs.scalar(result))
        }
    }
    envir <- .rs.getActiveFrame()
    object <- .rs.getAnywhere(src, envir = envir)
    if (!is.null(object)) {
        method <- if (inherits(object, "R6ClassGenerator") && 
            identical(name, "new")) {
            object$public_methods$initialize
        }
        else {
            .rs.tryCatch(object[[name]])
        }
        if (is.function(method)) {
            signature <- .rs.getSignature(method)
            result <- sub("function ", "", signature)
            return(.rs.scalar(result))
        }
    }
    .rs.scalar("")
}
<bytecode: 0x000001883bac8d80>
<environment: 0x000001883f4b86b8>

$.rs.flattenFrame
function (x) 
{
    multicols <- .rs.multiCols(x)
    while (length(multicols) > 0) {
        multicol <- multicols[1]
        newcols <- ncol(x[[multicol]])
        if (identical(newcols, 0)) {
            x[[multicol]] <- NULL
        }
        else {
            cols <- x[[multicol]]
            if (length(.rs.multiCols(cols)) > 0L) {
                cols <- x[[multicol]] <- .rs.flattenFrame(cols)
                newcols <- ncol(cols)
            }
            prefix <- names(multicol)[[1]]
            if (is.matrix(cols)) {
                colnames <- colnames(cols)
                if (is.null(colnames)) {
                  colnames(cols) <- paste0(prefix, "[,", 1:ncol(cols), 
                    "]")
                }
                else {
                  colnames(cols) <- paste0(prefix, "[,\"", colnames, 
                    "\"]")
                }
            }
            else if (is.data.frame(cols)) {
                names(cols) <- paste(prefix, names(cols), sep = "$")
            }
            if (multicol >= ncol(x)) {
                x <- cbind(x[0:(multicol - 1)], cols)
            }
            else {
                x <- cbind(x[0:(multicol - 1)], cols, x[(multicol + 
                  1):ncol(x)])
            }
        }
        multicols <- multicols[-1] + (max(newcols, 1) - 1)
    }
    x
}
<environment: 0x000001883f4b86b8>

$.rs.python.tokenizationRules
function () 
{
    list(list(pattern = sprintf("(?:%s)\\b", paste(.rs.python.keywords(), 
        collapse = "|")), type = "keyword"), list(pattern = "[[:alpha:]_][[:alnum:]_]*\\b", 
        type = "identifier"), list(pattern = "((\\d+[jJ]|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)[jJ])|((\\d+\\.\\d*|\\.\\d+)([eE][-+]?\\d+)?|\\d+[eE][-+]?\\d+)|(0[xX][\\da-fA-F]+[lL]?|0[bB][01]+[lL]?|(0[oO][0-7]+)|(0[0-7]*)[lL]?|[1-9]\\d*[lL]?))\\b", 
        type = "number"), list(pattern = "[\"]{3}(.*?)(?:[\"]{3}|$)", 
        type = "string"), list(pattern = "[']{3}(.*?)(?:[']{3}|$)", 
        type = "string"), list(pattern = "[\"](?:(?:\\\\.)|(?:[^\"\\\\]))*?(?:[\"]|$)", 
        type = "string"), list(pattern = "['](?:(?:\\\\.)|(?:[^'\\\\]))*?(?:[']|$)", 
        type = "string"), list(pattern = "\\*\\*=?|>>=?|<<=?|<>|!+|//=?|[%&|^=<>*/+-]=?|~", 
        type = "operator"), list(pattern = "[:;.,`@]", type = "special"), 
        list(pattern = "[][)(}{]", type = "bracket"), list(pattern = "#[^\n]*", 
            type = "comment"), list(pattern = "[[:space:]]+", 
            type = "whitespace"))
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletionsKeywords
function (token, conn, ctx) 
{
    if (!nzchar(token)) 
        return(.rs.emptyCompletions(language = "SQL"))
    lowercase <- if (nzchar(token)) 
        identical(token, tolower(token))
    else ctx$preferLowercaseKeywords
    keywords <- if (lowercase) 
        tolower(.rs.sql.keywords(conn))
    else toupper(.rs.sql.keywords(conn))
    results <- .rs.selectFuzzyMatches(keywords, token)
    .rs.makeCompletions(token = token, results = results, packages = "keyword", 
        type = .rs.acCompletionTypes$KEYWORD, language = "SQL")
}
<environment: 0x000001883f4b86b8>

$.rs.getDataTableSpecialSymbolsCompletions
function (token, symbols) 
{
    results <- symbols[.rs.fuzzyMatches(sub("^.", "", symbols), 
        token)]
    .rs.makeCompletions(token = token, results = results, quote = FALSE, 
        packages = "data.table", type = .rs.acCompletionTypes$DATATABLE_SPECIAL_SYMBOL)
}
<environment: 0x000001883f4b86b8>

$.rs.setErrorManagementType
function (type, userOnly) 
{
    if (identical(type, "message")) 
        options(error = NULL)
    else if (identical(type, "traceback") && userOnly) 
        options(error = .rs.recordUserTraceback)
    else if (identical(type, "traceback") && !userOnly) 
        options(error = .rs.recordAnyTraceback)
    else if (identical(type, "break") && userOnly) 
        options(error = .rs.breakOnUserError)
    else if (identical(type, "break") && !userOnly) 
        options(error = .rs.breakOnAnyError)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsGetOption
function (token) 
{
    allOptions <- names(options())
    .rs.makeCompletions(token = token, results = .rs.selectFuzzyMatches(allOptions, 
        token), packages = "options", quote = TRUE, type = .rs.acCompletionTypes$OPTION)
}
<environment: 0x000001883f4b86b8>

$.rs.attachDataFile
function (filename, name, pos = 2) 
{
    if (!file.exists(filename)) 
        stop(gettextf("file '%s' not found", filename), domain = NA)
    .Internal(attach(NULL, pos, name))
    load(filename, envir = as.environment(pos))
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.parseDictElement
function (dictElement, keyName) 
{
    if (is.null(keyName)) {
        stop("Unable to find a key for the current \"dict\" element.", 
            call. = FALSE)
    }
    values <- list()
    if (xml2::xml_length(dictElement) >= 1) {
        key <- NULL
        for (element in xml2::xml_children(dictElement)) {
            elName <- xml2::xml_name(element)
            if (elName != "comment") {
                if (elName == "key") {
                  if (!is.null(key)) {
                    stop("Unable to find a value for the key \"", 
                      key, "\".", call. = FALSE)
                  }
                  key <- .rs.parseKeyElement(element)
                }
                else if (elName == "string") {
                  values[[key]] <- .rs.parseStringElement(element, 
                    key)
                  key <- NULL
                }
                else if (elName == "dict") {
                  values[[key]] <- .rs.parseDictElement(element, 
                    key)
                  key <- NULL
                }
                else if (elName == "array") {
                  values[[key]] <- .rs.parseArrayElement(element, 
                    key)
                  key <- NULL
                }
                else {
                  stop("Encountered unexpected element as a child of the current \"dict\" element: \"", 
                    elName, "\". Expected \"key\", \"string\", \"array\", or \"dict\".", 
                    call. = FALSE)
                }
            }
        }
        if (!is.null(key)) {
            stop("Unable to find a value for the key \"", key, 
                "\".", call. = FALSE)
        }
    }
    values
}
<environment: 0x000001883f4b86b8>

$.rs.enqueClientEvent
function (type, data = NULL) 
{
    .Call("rs_enqueClientEvent", type, data, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.createZipFile
function (zipfile, parent, files) 
{
    previous_wd = getwd()
    setwd(parent)
    on.exit(setwd(previous_wd))
    quotedFiles = paste(shQuote(files), collapse = " ")
    createZipCommand = paste("zip", "-r", shQuote(zipfile), quotedFiles, 
        "2>&1")
    system(createZipCommand, intern = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.getObjectContents
function (objName, env) 
{
    object <- get(objName, envir = env)
    .rs.valueContents(object)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.stop_profiling
function (profilerOptions) 
{
    tryCatch({
        Rprof(NULL)
        if (!identical(profilerOptions$fileName, NULL)) {
            .rs.enqueClientEvent("rprof_created", list(path = .rs.scalar(profilerOptions$fileName)))
        }
        return(list(fileName = .rs.scalar(profilerOptions$fileName)))
    }, error = function(e) {
        return(list(error = .rs.scalar(e$message)))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.sql.keywords
function (conn) 
{
    keywords <- getOption("sql.keywords")
    if (is.function(keywords)) {
        if (length(formals(keywords))) 
            return(keywords(conn))
        else return(keywords())
    }
    else if (is.character(keywords)) {
        return(keywords)
    }
    if ("DBI" %in% loadedNamespaces()) {
        DBI <- asNamespace("DBI")
        keywords <- DBI$.SQL92Keywords
        if (is.character(keywords)) 
            return(keywords)
    }
    c("ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", 
        "AND", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", 
        "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", 
        "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", 
        "CREATE", "CROSS", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
        "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", 
        "DESC", "DETACH", "DISTINCT", "DROP", "EACH", "ELSE", 
        "END", "ESCAPE", "EXCEPT", "EXCLUSIVE", "EXISTS", "EXPLAIN", 
        "FAIL", "FOR", "FOREIGN", "FROM", "FULL", "GLOB", "GROUP", 
        "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", 
        "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", 
        "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LEFT", 
        "LIKE", "LIMIT", "MATCH", "NATURAL", "NO", "NOT", "NOTNULL", 
        "NULL", "OF", "OFFSET", "ON", "OR", "ORDER", "OUTER", 
        "PLAN", "PRAGMA", "PRIMARY", "QUERY", "RAISE", "RECURSIVE", 
        "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", 
        "REPLACE", "RESTRICT", "RIGHT", "ROLLBACK", "ROW", "SAVEPOINT", 
        "SELECT", "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", 
        "TO", "TRANSACTION", "TRIGGER", "UNION", "UNIQUE", "UPDATE", 
        "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", 
        "WHERE", "WITH", "WITHOUT")
}
<environment: 0x000001883f4b86b8>

$.rs.toolsEnv
function () 
{
    .rs.Env
}
<environment: 0x000001883f3f6d20>

$.rs.readIniFile
function (filePath) 
{
    as.list(.Call("rs_readIniFile", filePath, PACKAGE = "(embedding)"))
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.detectChanges
function (moduleName, cacheOnly = FALSE) 
{
    module <- .rs.reticulate.resolveModule(moduleName)
    newObjects <- reticulate::py_get_attr(module, "__dict__")
    oldObjects <- .rs.nullCoalesce(.rs.getVar("reticulate.monitoredModuleObjects"), 
        newObjects)
    copy <- reticulate::import("copy", convert = FALSE)
    newObjects <- copy$copy(newObjects)
    .rs.setVar("reticulate.monitoredModuleObjects", newObjects)
    if (cacheOnly) 
        return()
    vars <- sort(union(names(oldObjects), names(newObjects)))
    changedObjects <- .rs.listBuilder()
    removedObjects <- .rs.listBuilder()
    for (var in vars) {
        old <- reticulate::py_get_item(oldObjects, var, silent = TRUE)
        new <- reticulate::py_get_item(newObjects, var, silent = TRUE)
        if (is.null(old) && is.null(new)) {
        }
        else if (is.null(old)) {
            changedObjects$append(.rs.reticulate.describeObject(var, 
                newObjects))
        }
        else if (is.null(new)) {
            removedObjects$append(var)
        }
        else if (!.rs.reticulate.objectsEqual(old, new)) {
            changedObjects$append(.rs.reticulate.describeObject(var, 
                newObjects))
        }
    }
    if (changedObjects$empty() && removedObjects$empty()) 
        return()
    .rs.enqueClientEvent("environment_changed", list(changed = changedObjects$data(), 
        removed = as.character(removedObjects$data())))
}
<environment: 0x000001883f4b86b8>

$.rs.listZipFile
function (zipfile) 
{
    as.character(utils::unzip(zipfile, list = TRUE)$Name)
}
<environment: 0x000001883f4b86b8>

$.rs.setNotebookGraphicsOption
function (filename, height, width, units, pixelRatio, extraArgs) 
{
    options(device = function() {
        .rs.createNotebookGraphicsDevice(filename, height, width, 
            units, pixelRatio, extraArgs)
        dev.control(displaylist = "enable")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.saveLibPaths
function (filename) 
{
    libPaths <- .libPaths()
    save(libPaths, file = filename)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsSingleBracket
function (token, string, functionCall, numCommas, index, envir) 
{
    result <- .rs.emptyCompletions()
    if (.rs.isDataTableExtractCall(string, envir = envir)) 
        return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
    object <- .rs.getAnywhere(string, envir)
    if (is.null(object)) 
        return(result)
    if (inherits(object, "data.table")) {
        return(.rs.getDataTableUnnamedArgumentCompletions(token, 
            name = string, object = object, functionCall = functionCall, 
            numCommas = numCommas, includeArguments = (index == 
                1L), envir = envir))
    }
    completions <- character()
    if (is.array(object) && !is.null(dn <- dimnames(object))) {
        if (numCommas + 1 <= length(dn)) 
            completions <- dimnames(object)[[numCommas + 1]]
        string <- if (numCommas == 0) 
            paste("rownames(", string, ")", sep = "")
        else if (numCommas == 1) 
            paste("colnames(", string, ")", sep = "")
        else paste("dimnames(", string, ")[", numCommas + 1, 
            "]", sep = "")
    }
    else if (inherits(object, "data.frame") && numCommas == 0) {
        completions <- rownames(object)
    }
    else {
        completions <- .rs.getNames(object)
    }
    completions <- .rs.selectFuzzyMatches(completions, token)
    if (length(completions)) {
        result <- .rs.makeCompletions(token = token, results = completions, 
            packages = string, quote = !inherits(object, "data.table"), 
            type = .rs.acCompletionTypes$STRING)
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.emptyNamedList
function () 
{
    `names<-`(list(), character())
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.knit_asis
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    mdfile <- tempfile("_rs_md_", fileext = ".md")
    htmlfile <- tempfile("_rs_html_", tmpdir = ctx$outputFolder, 
        fileext = ".html")
    writeLines(enc2utf8(x), con = mdfile, useBytes = TRUE)
    rmarkdown::pandoc_convert(input = rmarkdown::pandoc_path_arg(mdfile), 
        to = "html", output = rmarkdown::pandoc_path_arg(htmlfile))
    .rs.recordHtmlWidget(x, htmlfile, NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.attemptRoxygenTagCompletion
function (token, line) 
{
    emptyCompletions <- .rs.emptyCompletions(excludeOtherCompletions = TRUE)
    if (grepl("^\\s*#+'\\s*$", line) && token == "'") 
        token <- ""
    if (grepl("^\\s*#+'\\s*@template\\s+", line)) {
        projDir <- .rs.getProjectDirectory()
        if (is.null(projDir)) 
            return(emptyCompletions)
        manRoxygen <- file.path(projDir, "man-roxygen")
        if (!utils::file_test("-d", manRoxygen)) 
            return(emptyCompletions)
        completions <- .rs.getCompletionsFile(token, path = manRoxygen, 
            quote = FALSE)
        completions$results <- sub("[.][rR]$", "", completions$results)
        return(completions)
    }
    if (token == "") {
        match <- grepl("^\\s*#+'\\s*$", line)
        if (!match) 
            return(emptyCompletions)
    }
    else {
        match <- grepl("^@[a-zA-Z0-9]*$", token, perl = TRUE)
        if (!match) 
            return(emptyCompletions)
    }
    tag <- sub(".*(?=@)", "", token, perl = TRUE)
    metadata <- .rs.roxygenTagMetadata()
    tags <- metadata$tags
    recommend <- metadata$recommend
    descriptions <- metadata$descriptions
    vignette <- metadata$vignette
    matching <- grepl(paste("^", tag, sep = ""), tags)
    keep <- c(which(matching & recommend), which(matching & !recommend))
    .rs.makeCompletions(tag, results = tags[keep], type = .rs.acCompletionTypes$ROXYGEN, 
        context = .rs.acContextTypes$ROXYGEN, meta = descriptions[keep], 
        packages = vignette[keep], excludeOtherCompletions = TRUE, 
        )
}
<environment: 0x000001883f4b86b8>

$.rs.packagesLoaded
function (pkgs) 
{
    if (any(pkgs %in% loadedNamespaces())) 
        return(TRUE)
    libs <- .dynLibs()
    libnames <- vapply(libs, "[[", character(1), "name")
    return(any(pkgs %in% libnames))
}
<environment: 0x000001883f4b86b8>

$.rs.functionNameFromCall
function (val) 
{
    call <- .rs.nullCoalesce(attr(val, "_rs_call", exact = TRUE), 
        val)
    if (is.function(call[[1]])) 
        return("[Anonymous function]")
    if (is.name(call[[1L]])) 
        return(as.character(call[[1L]]))
    .rs.deparse(call[[1L]])
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.cpp_source_file
function (file) 
{
    .rs.api.sendToConsole(.rs.cppSourceFile(file))
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.installPackageDependencies
function (name, package) 
{
    pkgs <- character()
    path <- system.file("tutorials", name, package = package)
    if (!file.exists(path)) 
        return(character())
    deps <- renv::dependencies(path, quiet = TRUE)
    pkgs <- sort(unique(c(deps$Package, c("learnr", "rstudioapi"))))
    pkgs <- grep("^[a-zA-Z0-9._]+$", pkgs, value = TRUE)
    installed <- vapply(pkgs, function(pkg) {
        location <- find.package(pkg, quiet = TRUE)
        length(location) > 0
    }, FUN.VALUE = logical(1))
    missing <- pkgs[!installed]
    if (length(missing) == 0) 
        return(character())
    title <- "Install Required Packages"
    message <- paste("The following tutorial package dependencies are missing and will be installed:\n", 
        paste("-", .rs.formatListForDialog(missing)), "\nWould you like to proceed?", 
        sep = "\n")
    ok <- .rs.api.showQuestion(title, message)
    if (!ok) {
        fmt <- "cannot run tutorial '%s'; required dependencies not installed"
        msg <- sprintf(fmt, name)
        stop(msg, call. = FALSE)
    }
    call <- substitute(install.packages(missing), list(missing = missing))
    writeLines(paste(getOption("prompt"), format(call), sep = ""))
    eval(call, envir = globalenv())
}
<environment: 0x000001883f4b86b8>

$.rs.resolveFormalsImpl
function (token, object, functionName, functionCall, matchedCall, 
    envir) 
{
    data <- .rs.resolveFormalsImplS3Dispatch(token, object, functionName, 
        functionCall, matchedCall, envir)
    if (is.null(data)) {
        formals <- .rs.getFunctionArgumentNames(object)
        methods <- rep.int(functionName, length(formals))
        data <- list(formals = formals, methods = methods)
    }
    keep <- .rs.fuzzyMatches(data$formals, token) & !(data$formals %in% 
        names(functionCall))
    data$formals <- data$formals[keep]
    data$methods <- data$methods[keep]
    data
}
<bytecode: 0x0000018840ca1508>
<environment: 0x000001883f4b86b8>

$.rs.describeObject
function (env, objName, computeSize = TRUE) 
{
    obj <- get(objName, env)
    if (missing(obj)) 
        obj <- as.name("Missing argument")
    if (inherits(obj, "python.builtin.object")) 
        return(.rs.reticulate.describeObject(objName, env))
    checkNullPtr <- .rs.readUiPref("check_null_external_pointers")
    hasNullPtr <- if (identical(checkNullPtr, TRUE)) 
        .rs.hasExternalPointer(obj, TRUE)
    else FALSE
    if (hasNullPtr) {
        val <- "<Object with null pointer>"
        desc <- "An R object containing a null external pointer"
        size <- 0
        len <- 0
    }
    else {
        val <- "(unknown)"
        desc <- ""
        size <- if (computeSize) 
            object.size(obj)
        else 0
        len <- length(obj)
    }
    class <- .rs.getSingleClass(obj)
    contents <- list()
    contents_deferred <- FALSE
    if (is.symbol(obj)) {
        val <- as.character(obj)
    }
    else if (is.language(obj)) {
        .rs.describeCall(obj)
    }
    else if (!hasNullPtr) {
        if (size > 524288) {
            len_desc <- if (len > 1) {
                paste(len, " elements, ", sep = "")
            }
            else {
                ""
            }
            if (is.data.frame(obj)) {
                val <- "NO_VALUE"
                desc <- .rs.valueDescription(obj)
            }
            else {
                fmt <- "Large %s (%s %s)"
                val <- sprintf(fmt, class, len_desc, format(size, 
                  units = "auto", standard = "SI"))
            }
            contents_deferred <- TRUE
        }
        else {
            val <- .rs.valueAsString(obj)
            desc <- .rs.valueDescription(obj)
            if (is.list(obj) || is.data.frame(obj) || isS4(obj) || 
                inherits(obj, c("data.table", "ore.frame", "cast_df", 
                  "xts", "DataFrame"))) {
                if (computeSize) {
                  contents <- .rs.valueContents(obj)
                }
                else {
                  val <- "NO_VALUE"
                  contents_deferred <- TRUE
                }
            }
        }
    }
    list(name = .rs.scalar(objName), type = .rs.scalar(class), 
        clazz = c(class(obj), typeof(obj)), is_data = .rs.scalar(is.data.frame(obj)), 
        value = .rs.scalar(val), description = .rs.scalar(desc), 
        size = .rs.scalar(size), length = .rs.scalar(len), contents = contents, 
        contents_deferred = .rs.scalar(contents_deferred))
}
<bytecode: 0x000001883f542598>
<environment: 0x000001883f4b86b8>

$.rs.findViewingEnv
function (name) 
{
    env <- globalenv()
    for (i in seq_along(sys.calls())) {
        if (identical(deparse(sys.call(i)[[1]]), "View")) {
            env <- sys.frame(i - 1)
            break
        }
    }
    while (environmentName(env) != "R_EmptyEnv" && !exists(name, 
        where = env, inherits = FALSE)) {
        env <- parent.env(env)
    }
    env
}
<environment: 0x000001883f4b86b8>

$.rs.files.restoreBindings
function () 
{
    bindings <- ls(envir = .rs.files.savedBindings)
    for (binding in bindings) .rs.replaceBinding(binding, "base", 
        .rs.files.savedBindings[[binding]])
}
<environment: 0x000001883f4b86b8>

$.rs.connectionReadDSN
function () 
{
    if (.rs.isPackageInstalled("odbc")) {
        dataSources <- data.frame()
        tryCatch({
            if (exists("list_data_sources", envir = asNamespace("odbc"))) {
                listSources <- get("list_data_sources", envir = asNamespace("odbc"))
            }
            else {
                listSources <- get("odbcListDataSources", envir = asNamespace("odbc"))
            }
            dataSources <- listSources()
        }, error = function(e) warning(e$message))
        lapply(dataSources$name, function(dataSourceName) {
            tryCatch({
                dataSource <- dataSources[dataSources$name == 
                  dataSourceName, ]
                snippet <- paste("library(DBI)\n", "con <- dbConnect(odbc::odbc(), \"${1:Data Source Name=", 
                  dataSource$name, "}\", timeout = 10)", sep = "")
                iconData <- .Call("rs_connectionIcon", dataSource$name)
                if (nchar(iconData) == 0) 
                  iconData <- .Call("rs_connectionIcon", "ODBC")
                list(package = .rs.scalar(NULL), version = .rs.scalar(NULL), 
                  name = .rs.scalar(dataSource$name), type = .rs.scalar("Snippet"), 
                  snippet = .rs.scalar(snippet), help = .rs.scalar(NULL), 
                  iconData = .rs.scalar(iconData), licensed = .rs.scalar(FALSE), 
                  source = .rs.scalar("DSN"), hasInstaller = .rs.scalar(FALSE))
            }, error = function(e) {
                warning(e$message)
                NULL
            })
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.stop_shiny_app
function (id) 
{
    if (identical(id, "foreground")) {
        shiny::stopApp()
    }
    else {
        .rs.api.stopJob(id)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.stan.getCompletions
function (line) 
{
    Encoding(line) <- "UTF-8"
    completions <- .rs.emptyCompletions()
    parts <- .rs.strsplit(line, "\\W+")
    token <- tail(parts, n = 1)
    if (!nzchar(token)) 
        return(.rs.emptyCompletions(language = "Stan"))
    keywords <- c(.rs.stan.keywords(), .rs.stan.types(), .rs.stan.blocks())
    completions <- .rs.appendCompletions(completions, .rs.makeCompletions(token = token, 
        results = .rs.selectFuzzyMatches(keywords, token), type = .rs.acCompletionTypes$KEYWORD))
    rosetta <- .rs.stan.rosetta()
    matches <- .rs.fuzzyMatches(rosetta$StanFunction, token)
    completions <- .rs.appendCompletions(completions, .rs.makeCompletions(token = token, 
        results = rosetta$StanFunction[matches], packages = "function", 
        type = .rs.acCompletionTypes$FUNCTION, meta = rosetta$Arguments[matches]))
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.getHelpFunction
function (name, src, envir = parent.frame()) 
{
    pos <- match(src, search(), nomatch = -1L)
    if (pos >= 0) {
        object <- tryCatch(get(name, pos = pos), error = function(e) NULL)
        if (!is.null(object)) 
            return(.rs.getHelpFromObject(object, envir, name))
    }
    container <- tryCatch(eval(parse(text = src), envir = .GlobalEnv), 
        error = function(e) NULL)
    if (!is.null(container)) {
        object <- tryCatch(eval(call("$", container, name)), 
            error = function(e) NULL)
        if (!is.null(object)) 
            return(.rs.getHelpFromObject(object, envir, name))
    }
    .rs.getHelp(name, src, getSignature = TRUE)
}
<bytecode: 0x000001883ebc3820>
<environment: 0x000001883f4b86b8>

$.rs.getDataTableUnnamedArgumentCompletions
function (token, name, object, functionCall, numCommas, includeArguments = TRUE, 
    envir) 
{
    completions <- .rs.getDataTableColumnsCompletions(token, 
        name, object)
    if (numCommas == 1) 
        completions <- .rs.appendCompletions(completions, .rs.getDataTableJCompletions(token))
    if (numCommas == 2 || numCommas == 3) 
        completions <- .rs.appendCompletions(completions, .rs.getDataTableByCompletions(token))
    if (isTRUE(includeArguments) && isNamespaceLoaded("data.table")) {
        argCompletions <- .rs.getCompletionsFunction(token, "[.data.table", 
            functionCall, numCommas, envir = envir, object = data.table:::`[.data.table`)
        argCompletions$type[argCompletions$type == .rs.acCompletionTypes$ARGUMENT] <- .rs.acCompletionTypes$SECUNDARY_ARGUMENT
        completions <- .rs.appendCompletions(completions, argCompletions)
    }
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.symbolLookupEnv
function () 
{
    new.env(parent = .rs.toolsEnv())
}
<environment: 0x000001883f3f6d20>

$.rs.stan.getArguments
function (f) 
{
    none <- .rs.scalar("")
    rosetta <- .rs.stan.rosetta()
    if (is.null(rosetta)) 
        return(none)
    idx <- match(f, rosetta$StanFunction)
    if (is.na(idx)) 
        return(none)
    arguments <- rosetta$Arguments[idx]
    if (identical(arguments, "~")) {
        for (suffix in c("lpdf", "lpmf")) {
            method <- paste(f, suffix, sep = "_")
            idx <- match(method, rosetta$StanFunction)
            if (!is.na(idx)) 
                break
        }
        if (is.na(idx)) 
            return(none)
        arguments <- rosetta$Arguments[idx]
    }
    .rs.scalar(arguments)
}
<environment: 0x000001883f4b86b8>

$.rs.reRmdChunkEnd
function () 
{
    "^[\t >]*```+\\s*$"
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.convert_to_yaml
function (input) 
{
    exprs <- list()
    tick_sub <- function(x) {
        lapply(x, function(val) {
            if (is.list(val)) {
                tick_sub(val)
            }
            else if (is.character(val) && length(val) == 1) {
                if (grepl("-", val, fixed = TRUE)) 
                  attr(val, "quoted") <- TRUE
                needsPlaceholder <- (function() {
                  if (identical(substr(val, 1, 1), "`") && identical(substr(val, 
                    nchar(val), nchar(val)), "`")) {
                    return(TRUE)
                  }
                  if (grepl("^[!]", val)) 
                    return(TRUE)
                  FALSE
                })()
                if (needsPlaceholder) {
                  key <- .Call("rs_generateShortUuid", PACKAGE = "(embedding)")
                  exprs[[key]] <<- val
                  key
                }
                else {
                  val
                }
            }
            else {
                val
            }
        })
    }
    yaml <- yaml::as.yaml(tick_sub(input))
    if (Encoding(yaml) == "unknown") 
        Encoding(yaml) <- "UTF-8"
    for (key in names(exprs)) yaml <- sub(key, exprs[[key]], 
        yaml, fixed = TRUE)
    list(yaml = .rs.scalar(yaml))
}
<environment: 0x000001883f4b86b8>

$.rs.api.getLastActiveEditorContext
function () 
{
    .Call("rs_getEditorContext", 0L, NULL, PACKAGE = "(embedding)")
}
<environment: 0x000001883fd253a8>

$.rs.getActiveArgument
function (object, matchedCall) 
{
    allArgs <- .rs.getFunctionArgumentNames(object)
    matchedArgs <- names(matchedCall)[-1L]
    qualifiedArgsInCall <- setdiff(matchedArgs, "")
    setdiff(allArgs, qualifiedArgsInCall)[1]
}
<environment: 0x000001883f4b86b8>

$.rs.getDplyrJoinCompletions
function (token, leftDataName, rightDataName, verb, cursorPos, 
    envir) 
{
    result <- .rs.emptyCompletions()
    leftData <- .rs.getAnywhere(leftDataName, envir)
    rightData <- .rs.getAnywhere(rightDataName, envir)
    if (!is.list(leftData) || !is.list(rightData)) 
        return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
    if (cursorPos == "left" && !is.null(leftData)) {
        completions <- .rs.selectFuzzyMatches(.rs.getNames(leftData), 
            token)
        result <- .rs.makeCompletions(token = token, results = completions, 
            packages = leftDataName, quote = TRUE, type = vapply(leftData[completions], 
                FUN.VALUE = numeric(1), USE.NAMES = FALSE, .rs.getCompletionType), 
            excludeOtherCompletions = TRUE)
    }
    else if (cursorPos == "right" && !is.null(rightData)) {
        completions <- .rs.selectFuzzyMatches(.rs.getNames(rightData), 
            token)
        result <- .rs.makeCompletions(token = token, results = completions, 
            packages = rightDataName, quote = TRUE, type = vapply(rightData[completions], 
                FUN.VALUE = numeric(1), USE.NAMES = FALSE, .rs.getCompletionType), 
            excludeOtherCompletions = TRUE)
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.clangPCHPath
function (pkg, clangVersion) 
{
    paste(packageVersion(pkg), R.version$platform, R.version$`svn rev`, 
        clangVersion, sep = "-")
}
<environment: 0x000001883f4b86b8>

$.rs.dataViewer.shouldUseObjectExplorer
function (object) 
{
    if (inherits(object, c("function", "vignette"))) 
        return(FALSE)
    if (inherits(object, "pandas.core.frame.DataFrame")) 
        return(FALSE)
    isTabular <- is.data.frame(object) || is.matrix(object) || 
        is.table(object)
    if (isTabular) 
        return(FALSE)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.registerNotifyHook
function (name, package, hook, namespace = FALSE) 
{
    hookFactory <- function(original) function(...) {
        on.exit(hook(...))
        .rs.callAs(name, original, ...)
    }
    .rs.registerHook(name, package, hookFactory, namespace)
}
<environment: 0x000001883f4b86b8>

$.rs.writePrefInternal
function (method, prefName, value) 
{
    if (missing(prefName) || is.null(prefName)) 
        stop("No preference name supplied")
    if (missing(value)) 
        stop("No value supplied")
    invisible(.Call(method, prefName, .rs.scalar(value), PACKAGE = "(embedding)"))
}
<environment: 0x000001883f4b86b8>

$.rs.knitrChunkOptions
function () 
{
    if (.rs.getPackageVersion("knitr") >= "0.4.2") 
        return(knitr:::opts_chunk_attr)
    knitrOptions <- knitr:::opts_chunk$get()
    knitrOptions <- as.list(sapply(knitrOptions, class))
    knitrOptions[knitrOptions == "NULL"] <- "character"
    knitrOptions$results <- list("markup", "asis", "hide")
    knitrOptions$fig.show <- list("asis", "hold", "animate")
    knitrOptions$fig.keep <- list("high", "none", "all", "first", 
        "last")
    knitrOptions$fig.align <- list("left", "right", "center")
    if (.rs.getPackageVersion("knitr") >= "0.4") 
        knitrOptions$dev <- as.list(names(knitr:::auto_exts))
    return(knitrOptions)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.setCacheEntry
function (entry, id = .rs.createUUID()) 
{
    cache <- .rs.explorer.getCache()
    cache[[id]] <- entry
    if (inherits(entry$object, "python.builtin.object")) {
        pyid <- paste("_rstudio_viewer", id, sep = "_")
        cache <- .rs.reticulate.explorerCache()
        reticulate::py_set_item(cache, pyid, entry$object)
    }
    id
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_package_news_url
function (packageName, libraryPath) 
{
    cache <- .rs.packageNewsURLsEnv
    entry <- file.path(libraryPath, packageName)
    if (exists(entry, envir = cache)) 
        return(get(entry, envir = cache))
    repos <- getOption("repos")
    cran <- if ("CRAN" %in% names(repos)) 
        repos[["CRAN"]]
    else if (length(repos)) 
        repos[[1]]
    else .Call("rs_rstudioCRANReposUrl", PACKAGE = "(embedding)")
    cran <- gsub("/*$", "", cran)
    desc <- .rs.tryCatch(.rs.readPackageDescription(file.path(libraryPath, 
        packageName)))
    prefix <- if (inherits(desc, "error") || !"biocViews" %in% 
        names(desc)) 
        file.path(cran, "web/packages")
    else "https://bioconductor.org/packages/release/bioc/news"
    pkgPath <- file.path(libraryPath, packageName)
    candidates <- if (file.exists(file.path(pkgPath, "NEWS.md"))) {
        c("news/news.html", "news.html", "NEWS", "ChangeLog")
    }
    else if (file.exists(file.path(pkgPath, "NEWS"))) {
        c("NEWS", "news/news.html", "news.html", "ChangeLog")
    }
    else {
        c("news/news.html", "news.html", "NEWS", "ChangeLog")
    }
    isCurl <- identical(getOption("download.file.method"), "curl")
    if (isCurl) {
        download.file.extra <- getOption("download.file.extra")
        on.exit(options(download.file.extra = download.file.extra), 
            add = TRUE)
        extra <- if (length(download.file.extra)) 
            download.file.extra
        else ""
        addons <- c()
        hasLocation <- grepl("\b-L\b", extra) || grepl("\b--location\b", 
            extra)
        if (!hasLocation) 
            addons <- c(addons, "-L")
        hasFail <- grepl("\b-f\b", extra) || grepl("\b--fail\b", 
            extra)
        if (!hasFail) 
            addons <- c(addons, "-f")
        hasSilent <- grepl("\b-s\b", extra) || grepl("\b--silent\b", 
            extra)
        if (!hasSilent) 
            addons <- c(addons, "-s")
        if (nzchar(extra)) 
            extra <- paste(extra, paste(addons, collapse = " "))
        else extra <- paste(addons, collapse = " ")
        options(download.file.extra = extra)
    }
    timeout <- getOption("timeout")
    on.exit(options(timeout = timeout), add = TRUE)
    options(timeout = 4L)
    for (candidate in candidates) {
        url <- file.path(prefix, packageName, candidate)
        destfile <- tempfile()
        on.exit(unlink(destfile), add = TRUE)
        status <- .rs.tryCatch(download.file(url, destfile = destfile, 
            quiet = !isCurl, mode = "wb"))
        if (is.null(status) || inherits(status, "error")) 
            next
        if (identical(status, 0L)) {
            cache[[entry]] <- .rs.scalar(url)
            return(.rs.scalar(url))
        }
    }
    fmt <- "Failed to infer appropriate NEWS URL: using '%s' as best-guess candidate"
    warning(sprintf(fmt, candidates[[1]]))
    .rs.scalar(candidates[[1]])
}
<environment: 0x000001883f4b86b8>

$.rs.setOption
function (name, value) 
{
    data <- list(value)
    names(data) <- name
    options(data)
}
<environment: 0x000001883f4b86b8>

$.rs.userCommands
<environment: 0x000001883db49778>

$.rs.scalar
function (obj) 
{
    if (!is.null(obj)) 
        class(obj) <- "rs.scalar"
    return(obj)
}
<environment: 0x000001883f4b86b8>

$.rs.showLintMarkers
function (lint, filePath) 
{
    markers <- .rs.createMarkersFromLint(lint, filePath)
    .rs.api.sourceMarkers(name = "Diagnostics", markers = markers, 
        basePath = .rs.getProjectDirectory(), isDiagnostics = true)
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalCreate
function (caption = NULL, show = TRUE, shellType = NULL) 
{
    if (!is.null(caption) && (!is.character(caption) || (length(caption) != 
        1))) 
        stop("'caption' must be NULL or a character vector of length one")
    if (is.null(show) || !is.logical(show)) 
        stop("'show' must be a logical vector")
    if (!is.null(shellType) && (!is.character(shellType) || (length(shellType) != 
        1))) 
        stop("'shellType' must be NULL or a character vector of length one")
    validShellType = TRUE
    if (!is.null(shellType)) {
        validShellType <- tolower(shellType) %in% c("default", 
            "win-cmd", "win-ps", "win-git-bash", "win-wsl-bash", 
            "ps-core", "custom")
    }
    if (!validShellType) 
        stop("'shellType' must be NULL, or one of 'default', 'win-cmd', 'win-ps', 'win-git-bash', 'win-wsl-bash', 'ps-core', 'bash', 'zsh', or 'custom'.")
    .Call("rs_terminalCreate", caption, show, shellType)
}
<environment: 0x000001883fda8400>

$.rs.parseCss
function (lines) 
{
    css <- list()
    cssLines <- unlist(strsplit(gsub("\\}", "\\}\n", lines), 
        c("\n"), perl = TRUE))
    currKeys <- list()
    isLastDescForKey <- FALSE
    inCommentBlock <- FALSE
    candidateKey <- NULL
    for (currLine in cssLines) {
        orgLine <- currLine
        startCommentBlock <- FALSE
        currLine <- gsub("/\\*.*?\\*/", "", currLine)
        if (!inCommentBlock && grepl("/\\*", currLine)) {
            startCommentBlock <- TRUE
            currLine <- sub("/\\*.*$", "", currLine)
        }
        if (inCommentBlock && grepl("\\*/", currLine)) {
            inCommentBlock <- FALSE
            currLine <- sub("^.*?\\*/", "", currLine)
        }
        if (!inCommentBlock) {
            if (grepl("^\\s*\\.[^\\{]+\\{", currLine)) {
                candidateKey <- paste(candidateKey, regmatches(currLine, 
                  regexec("^\\s*([^\\{]*?)\\s*\\{", currLine))[[1]][2], 
                  sep = " ")
                candidateKey <- gsub("^\\s*|\\s*$", "", candidateKey, 
                  perl = TRUE)
                if (!grepl("^\\s*$", candidateKey)) {
                  if (length(currKeys) > 0) {
                    warning("Malformed CSS: ", orgLine, ". No closing bracket for last block.")
                  }
                  currKeys <- unlist(strsplit(candidateKey, "\\s*,\\s*", 
                    perl = TRUE))
                  candidateKey <- NULL
                  for (currKey in currKeys) {
                    css[[currKey]] <- list()
                  }
                  currLine <- sub("^\\s*[^\\{]*?\\s*\\{", "", 
                    currLine)
                }
            }
            if (length(currKeys) > 0) {
                if (grepl("\\}", currLine)) {
                  isLastDescForKey <- TRUE
                  currLine <- sub("^([^\\}]*)\\}\\s*$", "\\1", 
                    currLine)
                  if (grepl("\\}", currLine)) {
                    warning("Maformed CSS: ", orgLine, ". Extra closing brackets.")
                  }
                }
                urlPattern <- "\\s*(background(?:-image)?)\\s*:\\s*(url\\((?:\"[^\"]*\"|[^)]*)\\)[^();]*?)\\s*(?:;|$)"
                while (grepl(urlPattern, currLine, ignore.case = TRUE, 
                  perl = TRUE)) {
                  ruleName = sub(urlPattern, "\\1", currLine, 
                    ignore.case = TRUE, perl = TRUE)
                  ruleValue = sub(urlPattern, "\\2", currLine, 
                    ignore.case = TRUE, perl = TRUE)
                  currLine <- sub(urlPattern, "", currLine, ignore.case = TRUE, 
                    perl = TRUE)
                  for (currKey in currKeys) css[[currKey]][[ruleName]] <- ruleValue
                }
                if (grepl(":", currLine)) {
                  descValues <- strsplit(currLine, "\\s*;\\s*")[[1]]
                  for (value in descValues) {
                    if (value != "") {
                      desc <- strsplit(sub("^\\s*([^;]+);?\\s*$", 
                        "\\1", value), "\\s*:\\s*")[[1]]
                      if (length(desc) != 2) {
                        warning("Malformed CSS: ", orgLine, ". Invalid element within block.")
                      }
                      else {
                        for (currKey in currKeys) css[[currKey]][[desc[1]]] <- tolower(desc[2])
                      }
                    }
                  }
                }
                else if (!grepl("^\\s*$", currLine)) {
                  warning("Malformd CSS: ", orgLine, ". Unexpected non-css line.")
                }
            }
            else if (!grepl("^\\s*$", currLine)) {
                if (is.null(candidateKey)) {
                  candidateKey <- currLine
                }
                else {
                  candidateKey <- paste(candidateKey, currLine)
                }
            }
            if (isLastDescForKey) {
                currKeys <- list()
                isLastDescForKey <- FALSE
            }
            if (startCommentBlock) {
                inCommentBlock <- TRUE
            }
        }
    }
    css
}
<environment: 0x000001883f4b86b8>

$.rs.truncate
function (string, n = 200, marker = "<...>") 
{
    if (nchar(string) <= n) 
        return(string)
    truncated <- substring(string, 1, n - nchar(marker))
    return(paste(truncated, marker))
}
<environment: 0x000001883f4b86b8>

$.rs.selectFuzzyMatches
function (completions, token) 
{
    types <- attr(completions, "types")
    matches <- .rs.fuzzyMatches(completions, token)
    completions <- completions[matches]
    if (!is.null(types)) 
        attr(completions, "types") <- types[matches]
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.functionHasSrcRef
function (func) 
{
    !is.null(attr(func, "srcref"))
}
<environment: 0x000001883f4b86b8>

$.rs.downloadAvailablePackages
function (contribUrl) 
{
    .Call("rs_downloadAvailablePackages", contribUrl, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.api.showDialog
function (title, message, url = "") 
{
    if (is.null(url) || is.na(url)) 
        url <- ""
    .Call("rs_showDialog", title = title, message = message, 
        dialogIcon = .rs.dialogIcon("info"), prompt = FALSE, 
        promptDefault = "", ok = "OK", cancel = "Cancel", url = url, 
        PACKAGE = "(embedding)")
}
<environment: 0x000001883fd44c10>

$.rs.ensureWriteableUserLibrary
function () 
{
    if (!.rs.defaultLibPathIsWriteable()) 
        .rs.initDefaultUserLibrary()
}
<environment: 0x000001883f4b86b8>

$.rs.valueAsStringImpl
function (val) 
{
    if (missing(val)) {
        "<missing>"
    }
    else if (is.null(val)) {
        "NULL"
    }
    else if (is.character(val) && !is.object(val)) {
        n <- length(val)
        if (n == 0) {
            "character (empty)"
        }
        else if (n == 1) {
            encodeString(val, quote = "\"", na.encode = FALSE)
        }
        else {
            encoded <- encodeString(head(val, n = 128L), quote = "\"", 
                na.encode = FALSE)
            fmt <- "chr [1:%i] %s"
            txt <- sprintf(fmt, n, paste(encoded, collapse = " "))
            .rs.truncate(txt)
        }
    }
    else if (is.raw(val)) {
        if (length(val) == 0) {
            "raw (empty)"
        }
        else {
            .rs.valueFromStr(val)
        }
    }
    else if (is.atomic(val) && is.null(attributes(val))) {
        n <- length(val)
        if (n == 0) {
            paste(.rs.getSingleClass(val), " (empty)")
        }
        else if (n == 1) {
            .rs.truncate(.rs.deparse(val), 1024L)
        }
        else {
            .rs.valueFromStr(val)
        }
    }
    else if (inherits(val, "python.builtin.object")) {
        .rs.valueFromStr(val)
    }
    else if (.rs.isFunction(val)) {
        .rs.getSignature(val)
    }
    else if (inherits(val, c("Date", "POSIXct", "POSIXlt"))) {
        if (length(val) == 1) {
            format(val, usetz = TRUE)
        }
        else {
            .rs.valueFromStr(val)
        }
    }
    else {
        "NO_VALUE"
    }
}
<environment: 0x000001883f4b86b8>

$.rs.haveSecureDownloadFileMethod
function () 
{
    .rs.isDownloadMethodSecure(getOption("download.file.method", 
        "auto"))
}
<environment: 0x000001883f4b86b8>

$.rs.ensureScalarCharacter
function (object) 
{
    if (is.character(object) && length(object) == 1) 
        return(object)
    fmt <- "'%s' is not a length-one character vector"
    stop(sprintf(fmt, .rs.deparse(substitute(object))), call. = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.launch_embedded_shiny_connection_ui
function (package, name) 
{
    if (package == "sparklyr" && packageVersion("sparklyr") <= 
        "0.5.4") {
        return(.rs.error("sparklyr ", packageVersion("sparklyr"), 
            " does not support this functionality. ", "Please upgrade to sparklyr 0.5.5 or newer."))
    }
    connectionContext <- .rs.rpc.get_new_connection_context()$connectionsList
    connectionInfo <- Filter(function(e) identical(as.character(e$package), 
        as.character(package)) & identical(as.character(e$name), 
        as.character(name)), connectionContext)
    if (length(connectionInfo) != 1) {
        return(.rs.error("Connection for package ", package, 
            " and name ", name, " is not registered"))
    }
    connectionInfo <- connectionInfo[[1]]
    consoleCommand <- paste("shiny::runGadget(", connectionInfo$newConnection, 
        ", viewer = .rs.embeddedViewer)", sep = "")
    .rs.api.sendToConsole(consoleCommand, echo = FALSE, execute = TRUE, 
        focus = FALSE)
    .rs.success()
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.list_all_files
function (path, pattern) 
{
    list.files(path, pattern = pattern, recursive = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.scalarListFromList
function (l, expressions = FALSE) 
{
    l <- lapply(l, function(ele) {
        if (is.null(ele)) 
            NULL
        else if (is.list(ele)) 
            .rs.scalarListFromList(ele)
        else if (length(ele) == 1) {
            if (is.character(ele) && Encoding(ele) == "unknown") 
                Encoding(ele) <- "UTF-8"
            .rs.scalar(ele)
        }
        else if (identical(expressions, TRUE) && (is.expression(ele) || 
            is.call(ele))) 
            .rs.scalarListFromList(list(expr = eval(ele)))$expr
        else ele
    })
}
<environment: 0x000001883f4b86b8>

$.rs.python.configuredInterpreterPath
function (projectDir) 
{
    if (.rs.platform.isWindows) {
        pyPython <- Sys.getenv("PY_PYTHON", unset = NA)
        if (!is.na(pyPython)) {
            python <- .rs.python.findWindowsPython()
            if (file.exists(python)) 
                return(python)
        }
    }
    vars <- c("RENV_PYTHON", "RETICULATE_PYTHON", "RETICULATE_PYTHON_FALLBACK")
    for (var in vars) {
        value <- Sys.getenv(var, unset = NA)
        if (!is.na(value)) 
            return(value)
    }
    if (!is.null(projectDir)) {
        projectPython <- .rs.python.projectInterpreterPath(projectDir)
        if (file.exists(projectPython)) 
            return(projectPython)
    }
    prefsPython <- .rs.readUiPref("python_path")
    if (file.exists(prefsPython)) 
        return(path.expand(prefsPython))
    if (.rs.platform.isWindows) {
        pythonPath <- .rs.python.findWindowsPython()
        if (file.exists(pythonPath)) 
            return(pythonPath)
    }
    if (!.rs.platform.isWindows) {
        python3 <- Sys.which("python3")
        if (nzchar(python3) && python3 != "/usr/bin/python3") 
            return(python3)
        python <- Sys.which("python")
        if (nzchar(python) && python != "/usr/bin/python") {
            info <- .rs.python.interpreterInfo(python, NULL)
            version <- numeric_version(info$version, strict = FALSE)
            if (!is.na(version) && version >= "3.2") 
                return(python)
        }
    }
    conda <- .rs.python.findCondaBinary()
    if (file.exists(conda)) {
        pythonPath <- if (.rs.platform.isWindows) 
            "../python.exe"
        else "../bin/python"
        python <- file.path(dirname(conda), pythonPath)
        if (file.exists(python)) 
            return(python)
    }
    if (!.rs.platform.isWindows) {
        python3 <- Sys.which("python3")
        if (nzchar(python3) && python3 == "/usr/bin/python3") 
            return(python3)
        python <- Sys.which("python")
        if (nzchar(python) && python == "/usr/bin/python") {
            info <- .rs.python.interpreterInfo(python, NULL)
            version <- numeric_version(info$version, strict = FALSE)
            if (!is.na(version) && version >= "3.2") 
                return(python)
        }
    }
    ""
}
<environment: 0x000001883f4b86b8>

$.rs.S3Originals
<environment: 0x00000188402b5b48>

$.rs.listFiles
function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, 
    no.. = FALSE) 
{
    .Call("rs_listFiles", path, pattern, all.files, full.names, 
        recursive, ignore.case, include.dirs, no.., PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.objectName
function (object, default) 
{
    if (inherits(object, "xml_node")) {
        sprintf("<%s>", xml2::xml_name(object))
    }
    else {
        default
    }
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.describeObject
function (name, parent) 
{
    builtins <- reticulate::import_builtins(convert = TRUE)
    object <- if (inherits(parent, "python.builtin.dict")) 
        reticulate::py_get_item(parent, name)
    else if (inherits(parent, "python.builtin.object")) 
        reticulate::py_get_attr(parent, name)
    else get(name, envir = parent)
    if (reticulate:::py_is_null_xptr(object)) {
        result <- list(name = .rs.scalar(name), type = .rs.scalar("<unknown>"), 
            clazz = "<unknown>", is_data = .rs.scalar(TRUE), 
            value = .rs.scalar("<Null pointer>"), description = .rs.scalar("<Null pointer>"), 
            size = .rs.scalar(0L), length = .rs.scalar(0L), contents = list(), 
            contents_deferred = .rs.scalar(FALSE))
        return(result)
    }
    isData <- !(grepl("^__.*__$", name) || reticulate:::py_is_callable(object) || 
        reticulate:::py_is_module(object))
    type <- if (.rs.reticulate.isFunction(object)) 
        "function"
    else .rs.reticulate.describeObjectType(object)
    value <- .rs.reticulate.describeObjectValue(object)
    sys <- reticulate::import("sys")
    size <- sys$getsizeof(object)
    length <- .rs.reticulate.describeObjectLength(object)
    contents <- .rs.reticulate.describeObjectContents(object)
    list(name = .rs.scalar(name), type = .rs.scalar(type), clazz = type, 
        is_data = .rs.scalar(isData), value = .rs.scalar(value), 
        description = .rs.scalar(value), size = .rs.scalar(size), 
        length = .rs.scalar(length), contents = contents, contents_deferred = .rs.scalar(FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.connectionUnregisterOdbcinstDriver
function (driverName) 
{
    odbcinstPath <- .rs.odbcBundleOdbcinstPath()
    odbcinstData <- .rs.odbcBundleReadIni(odbcinstPath)
    if (driverName %in% names(odbcinstData)) {
        odbcinstData[[driverName]] <- NULL
        .rs.odbcBundleWriteIni(odbcinstPath, odbcinstData)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.invokeHook
function (hookName, ...) 
{
    hooks <- getHook(hookName)
    if (!is.list(hooks)) 
        hooks <- list(hooks)
    for (fun in hooks) {
        if (is.character(fun)) 
            fun <- get(fun)
        tryCatch(fun(...), error = function(e) {
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.detectFreeVars_Call
function (e, w) 
{
    freeVars <- character(0)
    func <- e[[1]]
    funcName <- as.character(func)
    args <- as.list(e[-1])
    if (typeof(func) == "language") {
        freeVars <- c(freeVars, codetools:::walkCode(func, w))
    }
    else if (funcName %in% c("<-", "<<-", "=", "for") && length(args) > 
        1 && typeof(args[[1]]) != "language") {
        lvalue <- as.character(args[[1]])
        args <- args[-1]
        if (length(args) > 0) {
            for (ee in args) freeVars <- c(freeVars, codetools:::walkCode(ee, 
                w))
        }
        args <- c()
        if (funcName == "<<-") 
            assign(lvalue, T, envir = w$assignedGlobals)
        else assign(lvalue, T, envir = w$assigned)
    }
    else if (funcName == "$") {
        args <- args[-2]
    }
    else if (funcName == "function") {
        params <- args[[1]]
        w$assigned <- new.env(parent = w$assigned)
        for (param in names(params)) {
            assign(param, T, envir = w$assigned)
            freeVars <- c(freeVars, codetools:::walkCode(params[[param]], 
                w))
        }
        args <- args[-1]
    }
    if (length(args) > 0) {
        for (i in seq_along(args)) freeVars <- c(freeVars, codetools:::walkCode(args[[i]], 
            w))
    }
    return(unique(freeVars))
}
<environment: 0x000001883f4b86b8>

$.rs.saveOptions
function (filename) 
{
    opt <- options()
    opt$cpp11_preserve_env <- NULL
    opt$cpp11_preserve_xptr <- NULL
    sidecarFile <- paste(filename, "incomplete", sep = ".")
    unlink(sidecarFile)
    status <- tryCatch(suppressWarnings(save(opt, file = sidecarFile)), 
        error = identity)
    if (inherits(status, "error")) {
        unlink(sidecarFile)
        stop(status)
    }
    file.rename(sidecarFile, filename)
}
<environment: 0x000001883f4b86b8>

$source.with.encoding
function (path, encoding, echo = getOption("verbose"), print.eval = echo, 
    max.deparse.length = 150, chdir = FALSE) 
{
    warning("source.with.encoding is deprecated and will be removed in a ", 
        "future release of RStudio. Use source(..., encoding = '", 
        encoding, "') instead.")
    conn = file(path, open = "r", encoding = encoding)
    on.exit(close(conn))
    source(conn, echo = echo, print.eval = print.eval, max.deparse.length = max.deparse.length, 
        chdir = chdir)
}
<environment: 0x000001883f4b86b8>

$.rs.notebookConditions.connectCall
function () 
{
    body(.rs.notebookConditions.connectImpl)
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.renderConsoleData
function (csvData, attributes = list(class = "r"), context = list()) 
{
    if (length(csvData) == 0 || nrow(csvData) == 0) 
        return(list())
    csvData$text <- gsub("\033\\[\\d*(?:;\\d*)*m", "", csvData$text)
    cutpoints <- .rs.cutpoints(csvData$type)
    ranges <- Map(function(start, end) list(start = start, end = end), 
        c(1, cutpoints), c(cutpoints - 1, nrow(csvData)))
    splat <- lapply(ranges, function(range) {
        type <- csvData$type[[range$start]]
        text <- csvData$text[range$start:range$end]
        collapse <- if (type == 0) 
            "\n"
        else ""
        code <- paste(text, collapse = collapse)
        if (type == 0) {
            if (isTRUE(context$tidy)) {
                args <- c(list(text = code, output = FALSE), 
                  context$tidy.opts)
                formatted <- do.call(formatR::tidy_source, args)
                code <- paste(formatted$text.tidy, collapse = "\n")
            }
            if (is.null(context$indent)) {
                return(rmarkdown::html_notebook_output_code(code, 
                  attributes = attributes))
            }
            else {
                return(.rs.rnb.renderVerbatimConsoleInput(code, 
                  tolower(context$engine), context$indent))
            }
        }
        else {
            return(code)
        }
    })
    splat
}
<environment: 0x000001883f4b86b8>

$.rs.enumerate
function (X, FUN, ...) 
{
    keys <- if (is.environment(X)) {
        sort(ls(envir = X))
    }
    else {
        names(X)
    }
    result <- lapply(keys, function(key) {
        FUN(key, X[[key]], ...)
    })
    names(result) <- keys
    result
}
<environment: 0x000001883f4b86b8>

$.rs.extractRmdChunkInformation
function (rmd) 
{
    starts <- grep(.rs.reRmdChunkBegin(), rmd, perl = TRUE)
    ends <- grep(.rs.reRmdChunkEnd(), rmd, perl = TRUE)
    n <- min(length(starts), length(ends))
    if (length(starts) != n) 
        starts <- starts[seq_len(n)]
    if (length(ends) != n) 
        ends <- ends[seq_len(n)]
    lapply(seq_len(n), function(i) {
        begin <- starts[[i]]
        end <- ends[[i]]
        contents <- rmd[begin:end]
        list(begin = starts[[i]], end = ends[[i]], contents = contents)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.writeUserState
function (stateName, value) 
{
    if (missing(stateName) || is.null(stateName)) 
        stop("No state name supplied")
    if (missing(value)) 
        stop("No value supplied")
    invisible(.Call("rs_writeUserState", stateName, .rs.scalar(value), 
        PACKAGE = "(embedding)"))
}
<environment: 0x000001883f4b86b8>

$.rs.api.dictionariesPath
function () 
{
    .Call("rs_dictionariesPath", "bundled", PACKAGE = "(embedding)")
}
<environment: 0x000001883fdfe0c8>

$.rs.insecureDownloadWarning
function (msg) 
{
    if (.rs.showSecureDownloadWarning()) {
        message("WARNING: ", msg, "\n\nTo learn more and/or disable this warning ", 
            "message see the \"Use secure download method for HTTP\" option ", 
            "in Tools -> Global Options -> Packages.")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.completeUrl
function (url, path) 
{
    .Call("rs_completeUrl", url, path)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_shiny_viewer_type
function () 
{
    .rs.scalar(.rs.getShinyViewerType())
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.rmd_output_format
function (input, encoding) 
{
    if (Encoding(input) == "unknown") 
        Encoding(input) <- "UTF-8"
    formats <- rmarkdown:::enumerate_output_formats(input, encoding = encoding)
    if (is.character(formats)) 
        .rs.scalar(formats[[1]])
    else NULL
}
<environment: 0x000001883f4b86b8>

$.rs.isEmptyCompletion
function (completions) 
{
    length(completions$results) == 0
}
<environment: 0x000001883f4b86b8>

$RStudio.Version
function () 
{
    .rs.api.versionInfo()
}
<environment: 0x000001883f4b86b8>

$.rs.htmlEscape
function (text, attribute = FALSE) 
{
    .Call("rs_htmlEscape", text, attribute, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.restoreGlobalEnvFromFile
function (path) 
{
    Encoding(path) <- "UTF-8"
    if (!file.exists(path)) 
        return(paste(path, "does not exist"))
    owd <- setwd(dirname(path))
    on.exit(setwd(owd), add = TRUE)
    status <- try(load(basename(path), envir = .GlobalEnv), silent = TRUE)
    if (!inherits(status, "try-error")) 
        return("")
    condition <- attr(status, "condition")
    if (is.null(condition)) {
        if (is.character(status)) 
            return(paste(c(status), collapse = "\n"))
        else return("Unknown Error")
    }
    if (!"message" %in% names(condition)) 
        return("Unknown Error")
    paste(condition$message, collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.renv.refresh
function () 
{
    project <- renv::project()
    libdir <- renv:::renv_paths_library(project = project)
    files <- c(file.path(project, "renv.lock"), list.files(libdir, 
        full.names = TRUE))
    info <- file.info(files, extra_cols = FALSE)
    new <- info[c("size", "mtime")]
    old <- .rs.renvCache[["modifiedTimes"]]
    if (identical(old, new)) 
        return()
    .rs.renvCache[["modifiedTimes"]] <- new
    .rs.updatePackageEvents()
    .Call("rs_packageLibraryMutated", PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.create_terminal_viewport_rule
function (background) 
{
    sprintf(paste(sep = "\n", ".terminal .xterm-viewport {", 
        "  background-color: %s;", "  overflow-y: scroll;", "}"), 
        background)
}
<environment: 0x000001883f4b86b8>

$.rs.assembleDataImportName
function (dataImportOptions) 
{
    dataName <- dataImportOptions$dataName
    if (is.null(dataName) || identical(dataName, "")) {
        if (!is.null(dataImportOptions$importLocation)) {
            locationName <- basename(dataImportOptions$importLocation)
            if (length(locationName) > 0) {
                fileComponents <- unlist(strsplit(locationName, 
                  ".", fixed = TRUE))
                components <- length(fileComponents)
                if (components >= 1) {
                  dataName <- paste(fileComponents[1:(components - 
                    1)], collapse = "_")
                }
            }
        }
    }
    dataName
}
<environment: 0x000001883f4b86b8>

$.rs.isGlobalTheme
function (themeUrl) 
{
    grepl("^theme/custom/global/.*?\\.rstheme$", themeUrl, ignore.case = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.initialize
function () 
{
    engine <- tolower(Sys.getenv("MPLENGINE"))
    if (engine %in% c("", "qt5agg")) 
        Sys.setenv(MPLENGINE = "tkAgg")
    .rs.registerPackageLoadHook("reticulate", function(...) {
        python <- .rs.readUiPref("python_path")
        .rs.reticulate.usePython(python)
        if (packageVersion("reticulate") >= "1.23") {
            .rs.addFunction("reticulate.describeObjectLength", 
                function(object) {
                  reticulate::py_len(object, -1L)
                })
        }
    })
}
<environment: 0x000001883f4b86b8>

$.rs.api.translateLocalUrl
function (url, absolute = FALSE) 
{
    .Call("rs_translateLocalUrl", url, absolute, PACKAGE = "(embedding)")
}
<environment: 0x000001883fe03a08>

$.rs.isNullExternalPointer
function (object) 
{
    .Call("rs_isNullExternalPointer", object, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleValidate
function (bundleFile, md5) 
{
    if (!is.null(md5) && nchar(md5) > 0) {
        validMd5s <- strsplit(as.character(md5), "[ \n,]+")[[1]]
        bundleMd5 <- tools::md5sum(bundleFile)
        if (!bundleMd5 %in% validMd5s) {
            stop("Failed to validate bundle with signature ", 
                md5, " but got ", bundleMd5, " instead.")
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.ignoreNextLoadedPackageCheck
[1] FALSE
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.rpc.validate_cran_repo
function (url) 
{
    packagesFile <- tempfile(fileext = ".gz")
    tryCatch({
        download.file(.rs.completeUrl(.rs.appendSlashIfNeeded(url), 
            "src/contrib/PACKAGES.gz"), packagesFile, quiet = TRUE)
        .rs.scalar(TRUE)
    }, error = function(e) {
        .rs.scalar(FALSE)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.api.addJob
function (name, status = "", progressUnits = 0L, actions = NULL, 
    running = FALSE, autoRemove = TRUE, group = "", show = TRUE, 
    launcherJob = FALSE, tags = NULL) 
{
    if (missing(name)) 
        stop("Cannot add a job without a name.")
    if (!is.integer(progressUnits) || progressUnits < 0L || progressUnits > 
        1000000L) 
        stop("progressUnits must be an integer between 1 and 1000000, or 0 to disable progress.")
    .Call("rs_addJob", name, status, progressUnits, actions, 
        running, autoRemove, group, show, launcherJob, tags, 
        PACKAGE = "(embedding)")
}
<environment: 0x000001883f045798>

$.rs.valueDescriptionImpl
function (obj) 
{
    if (missing(obj)) {
        return("Missing argument")
    }
    else if (is.null(obj)) {
        return("NULL")
    }
    else if (is(obj, "ore.frame")) {
        sqlTable <- attr(obj, "sqlTable", exact = TRUE)
        if (is.null(sqlTable)) 
            return("Oracle R frame")
        else return(paste("Oracle R frame:", sqlTable))
    }
    else if (.rs.isExternalPointer(obj)) {
        class <- class(obj)
        if (length(class) && !identical(class, "externalptr")) {
            fmt <- "External pointer of class '%s'"
            return(sprintf(fmt, class[[1]]))
        }
        else {
            return("External pointer")
        }
    }
    else if (is.data.frame(obj)) {
        return(paste(dim(obj)[1], "obs. of", dim(obj)[2], ifelse(dim(obj)[2] == 
            1, "variable", "variables"), sep = " "))
    }
    else if (is.environment(obj)) {
        return("Environment")
    }
    else if (isS4(obj)) {
        return(paste("Formal class ", is(obj)))
    }
    else if (is.list(obj)) {
        return(paste("List of ", length(obj)))
    }
    else if (is.matrix(obj) || is.numeric(obj) || is.factor(obj) || 
        is.raw(obj) || is.character(obj) || is.logical(obj)) {
        return(.rs.valueFromStr(obj))
    }
    else {
        return("")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.runSqlForDataCapture
function (sql, outputFile, options) 
{
    is_sql_update_query <- function(query) {
        query <- gsub("^\\s*--.*\n", "", query)
        if (grepl("^\\s*\\/\\*.*", query)) {
            query <- gsub(".*\\*\\/", "", query)
        }
        grepl("^\\s*(INSERT|UPDATE|DELETE|CREATE|DROP).*", query, 
            ignore.case = TRUE)
    }
    dir.create(dirname(outputFile), recursive = TRUE, showWarnings = FALSE)
    max.print <- if (is.null(options$max.print)) 
        getOption("max.print", 1000)
    else as.numeric(options$max.print)
    max.print <- if (is.null(options$sql.max.print)) 
        max.print
    else as.numeric(options$sql.max.print)
    conn <- options$connection
    if (is.numeric(options$connection)) {
        chunkReferences <- get(".rs.knitr.chunkReferences", envir = .rs.toolsEnv())
        conn <- chunkReferences[[chunkOptions$connection]]
    }
    if (is.null(conn)) {
        stop("The 'connection' option (DBI connection) is required for sql chunks.")
    }
    if (is.character(options$connection)) {
        conn <- get(options$connection, envir = globalenv())
        if (is.null(conn)) 
            stop("The 'connection' option must be a valid DBI connection.")
    }
    varnames_from_sql <- function(conn, sql) {
        varPos <- DBI::sqlParseVariables(conn, sql)
        if (length(varPos$start) > 0) {
            varNames <- substring(sql, varPos$start, varPos$end)
            sub("^\\?", "", varNames)
        }
    }
    mexists <- function(x, env = globalenv(), inherits = TRUE) {
        vapply(x, exists, logical(1), where = env, inherits = inherits)
    }
    interpolate_from_env <- function(conn, sql, env = globalenv(), 
        inherits = TRUE) {
        names <- unique(varnames_from_sql(conn, sql))
        names_missing <- names[!mexists(names, env, inherits)]
        if (length(names_missing) > 0) {
            stop("Object(s) not found: ", paste("\"", names_missing, 
                "\"", collapse = ", "))
        }
        args <- if (length(names) > 0) 
            setNames(mget(names, envir = env, inherits = inherits), 
                names)
        do.call(DBI::sqlInterpolate, c(list(conn, sql), args))
    }
    varname <- options$output.var
    query <- interpolate_from_env(conn, sql)
    if (is_sql_update_query(query)) {
        DBI::dbExecute(conn, query)
        data <- NULL
    }
    else if (is.null(varname) && max.print > 0) {
        res <- DBI::dbSendQuery(conn, query)
        data <- DBI::dbFetch(res, n = max.print)
        DBI::dbClearResult(res)
    }
    else {
        data <- DBI::dbGetQuery(conn, query)
    }
    if (!is.null(varname)) {
        assign(varname, data, envir = globalenv())
    }
    else if (!is.null(data)) {
        x <- data
        save(x, file = outputFile)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.connectionOdbcInstallerPath
function () 
{
    normalizePath(file.path(.Call("rs_connectionOdbcInstallPath"), 
        "odbc", "installers"), mustWork = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.toJSON
function (object, unbox = FALSE) 
{
    AsIs <- inherits(object, "AsIs") || inherits(object, ".rs.scalar")
    if (is.list(object)) {
        if (is.null(names(object))) {
            return(paste("[", paste(lapply(seq_along(object), 
                function(i) {
                  .rs.toJSON(object[[i]], unbox = unbox)
                }), collapse = ","), "]", sep = "", collapse = ","))
        }
        else {
            return(paste("{", paste(lapply(seq_along(object), 
                function(i) {
                  paste(sep = "", "\"", .rs.jsonEscapeString(enc2utf8(names(object)[[i]])), 
                    "\":", .rs.toJSON(object[[i]], unbox = unbox))
                }), collapse = ","), "}", sep = "", collapse = ","))
        }
    }
    else {
        n <- length(object)
        if (is.null(object)) {
            if (unbox) 
                return("null")
            else return("[]")
        }
        else if (n == 0) {
            return("[]")
        }
        else if (is.character(object) || is.factor(object)) {
            object <- paste(collapse = ",", vapply(as.character(object), 
                FUN.VALUE = character(1), USE.NAMES = FALSE, 
                function(x) {
                  if (is.na(x)) 
                    "null"
                  else paste("\"", .rs.jsonEscapeString(enc2utf8(x)), 
                    "\"", sep = "")
                }))
        }
        else if (is.numeric(object)) {
            object[is.na(object)] <- "\"NA\""
        }
        else if (is.logical(object)) {
            object <- ifelse(object, "true", "false")
            object[is.na(object)] <- "null"
        }
        if (AsIs || (unbox && n == 1)) 
            return(paste(object))
        else return(paste("[", paste(object, collapse = ","), 
            "]", sep = "", collapse = ","))
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getShinyViewerType
function () 
{
    viewer <- getOption("shiny.launch.browser")
    if (identical(viewer, FALSE)) 
        return("none")
    else if (identical(viewer, TRUE)) 
        return("browser")
    else if (is.function(viewer) && is.character(attr(viewer, 
        "shinyViewerType"))) 
        return(attr(viewer, "shinyViewerType"))
    return("user")
}
<environment: 0x000001883f4b86b8>

$.rs.resolveObjectFromFunctionCall
function (functionCall, envir) 
{
    string <- .rs.format(functionCall[[1]])[[1]]
    splat <- strsplit(string, ":{2,3}", perl = TRUE)[[1]]
    object <- NULL
    if (length(splat) == 1) {
        stripped <- .rs.stripSurrounding(string)
        envir <- .rs.resolveEnvironment(envir)
        object <- .rs.tryCatch(.rs.getAnywhere(name = stripped, 
            envir = envir))
    }
    else if (length(splat) == 2) {
        namespaceString <- .rs.stripSurrounding(splat[[1]])
        functionString <- string <- .rs.stripSurrounding(splat[[2]])
        if (namespaceString %in% loadedNamespaces()) {
            object <- .rs.tryCatch(eval(expr = parse(text = functionString), 
                envir = asNamespace(namespaceString)))
        }
    }
    if ("utils" %in% loadedNamespaces()) {
        readers <- list(utils::read.csv, utils::read.csv2, utils::read.delim, 
            utils::read.delim2)
        if (any(sapply(readers, identical, object))) 
            object <- utils::read.table
        writers <- list(utils::write.csv, utils::write.csv2)
        if (any(sapply(writers, identical, object))) 
            object <- utils::write.table
    }
    if (inherits(object, "error")) 
        return(NULL)
    object
}
<bytecode: 0x000001884103be98>
<environment: 0x000001883f4b86b8>

$.rs.getRgbColor
function (color) 
{
    namedCssColors <- list(black = c(0L, 0L, 0L), silver = c(192L, 
        192L, 192L), gray = c(128L, 128L, 128L), white = c(255L, 
        255L, 255L), maroon = c(128L, 0L, 0L), red = c(255L, 
        0L, 0L), purple = c(128L, 0L, 128L), fuchsia = c(255L, 
        0L, 255L), green = c(0L, 128L, 0L), lime = c(0L, 255L, 
        0L), olive = c(128L, 128L, 0L), yellow = c(255L, 255L, 
        0L), navy = c(0L, 0L, 128L), blue = c(0L, 0L, 255L), 
        teal = c(0L, 128L, 128L), aqua = c(0L, 255L, 255L), orange = c(255L, 
            165L, 0L), aliceblue = c(240L, 248L, 255L), antiquewhite = c(250L, 
            235L, 215L), aquamarine = c(127L, 255L, 212L), azure = c(240L, 
            255L, 255L), beige = c(245L, 245L, 220L), bisque = c(255L, 
            228L, 196L), blanchedalmond = c(255L, 235L, 205L), 
        blueviolet = c(138L, 43L, 226L), brown = c(165L, 42L, 
            42L), burlywood = c(222L, 184L, 135L), cadetblue = c(95L, 
            158L, 160L), chartreuse = c(127L, 255L, 0L), chocolate = c(210L, 
            105L, 30L), coral = c(255L, 127L, 80L), cornflowerblue = c(100L, 
            149L, 237L), cornsilk = c(255L, 248L, 220L), crimson = c(220L, 
            20L, 60L), cyan = c(0L, 255L, 255L), darkblue = c(0L, 
            0L, 139L), darkcyan = c(0L, 139L, 139L), darkgoldenrod = c(184L, 
            134L, 11L), darkgray = c(169L, 169L, 169L), darkgreen = c(0L, 
            100L, 0L), darkgrey = c(169L, 169L, 169L), darkkhaki = c(189L, 
            183L, 107L), darkmagenta = c(139L, 0L, 139L), darkolivegreen = c(85L, 
            107L, 47L), darkorange = c(255L, 140L, 0L), darkorchid = c(153L, 
            50L, 204L), darkred = c(139L, 0L, 0L), darksalmon = c(233L, 
            150L, 122L), darkseagreen = c(143L, 188L, 143L), 
        darkslateblue = c(72L, 61L, 139L), darkslategray = c(47L, 
            79L, 79L), darkslategrey = c(47L, 79L, 79L), darkturquoise = c(0L, 
            206L, 209L), darkviolet = c(148L, 0L, 211L), deeppink = c(255L, 
            20L, 147L), deepskyblue = c(0L, 191L, 255L), dimgray = c(105L, 
            105L, 105L), dimgrey = c(105L, 105L, 105L), dodgerblue = c(30L, 
            144L, 255L), firebrick = c(178L, 34L, 34L), floralwhite = c(255L, 
            250L, 240L), forestgreen = c(34L, 139L, 34L), gainsboro = c(220L, 
            220L, 220L), ghostwhite = c(248L, 248L, 255L), gold = c(255L, 
            215L, 0L), goldenrod = c(218L, 165L, 32L), greenyellow = c(173L, 
            255L, 47L), grey = c(128L, 128L, 128L), honeydew = c(240L, 
            255L, 240L), hotpink = c(255L, 105L, 180L), indianred = c(205L, 
            92L, 92L), indigo = c(75L, 0L, 130L), ivory = c(255L, 
            255L, 240L), khaki = c(240L, 230L, 140L), lavender = c(230L, 
            230L, 250L), lavenderblush = c(255L, 240L, 245L), 
        lawngreen = c(124L, 252L, 0L), lemonchiffon = c(255L, 
            250L, 205L), lightblue = c(173L, 216L, 230L), lightcoral = c(240L, 
            128L, 128L), lightcyan = c(224L, 255L, 255L), lightgoldenrodyellow = c(250L, 
            250L, 210L), lightgray = c(211L, 211L, 211L), lightgreen = c(144L, 
            238L, 144L), lightgrey = c(211L, 211L, 211L), lightpink = c(255L, 
            182L, 193L), lightsalmon = c(255L, 160L, 122L), lightseagreen = c(32L, 
            178L, 170L), lightskyblue = c(135L, 206L, 250L), 
        lightslategray = c(119L, 136L, 153L), lightslategrey = c(119L, 
            136L, 153L), lightsteelblue = c(176L, 196L, 222L), 
        lightyellow = c(255L, 255L, 224L), limegreen = c(50L, 
            205L, 50L), linen = c(250L, 240L, 230L), magenta = c(255L, 
            0L, 255L), mediumaquamarine = c(102L, 205L, 170L), 
        mediumblue = c(0L, 0L, 205L), mediumorchid = c(186L, 
            85L, 211L), mediumpurple = c(147L, 112L, 219L), mediumseagreen = c(60L, 
            179L, 113L), mediumslateblue = c(123L, 104L, 238L), 
        mediumspringgreen = c(0L, 250L, 154L), mediumturquoise = c(72L, 
            209L, 204L), mediumvioletred = c(199L, 21L, 133L), 
        midnightblue = c(25L, 25L, 112L), mintcream = c(245L, 
            255L, 250L), mistyrose = c(255L, 228L, 225L), moccasin = c(255L, 
            228L, 181L), navajowhite = c(255L, 222L, 173L), oldlace = c(253L, 
            245L, 230L), olivedrab = c(107L, 142L, 35L), orangered = c(255L, 
            69L, 0L), orchid = c(218L, 112L, 214L), palegoldenrod = c(238L, 
            232L, 170L), palegreen = c(152L, 251L, 152L), paleturquoise = c(175L, 
            238L, 238L), palevioletred = c(219L, 112L, 147L), 
        papayawhip = c(255L, 239L, 213L), peachpuff = c(255L, 
            218L, 185L), peru = c(205L, 133L, 63L), pink = c(255L, 
            192L, 203L), plum = c(221L, 160L, 221L), powderblue = c(176L, 
            224L, 230L), rosybrown = c(188L, 143L, 143L), royalblue = c(65L, 
            105L, 225L), saddlebrown = c(139L, 69L, 19L), salmon = c(250L, 
            128L, 114L), sandybrown = c(244L, 164L, 96L), seagreen = c(46L, 
            139L, 87L), seashell = c(255L, 245L, 238L), sienna = c(160L, 
            82L, 45L), skyblue = c(135L, 206L, 235L), slateblue = c(106L, 
            90L, 205L), slategray = c(112L, 128L, 144L), slategrey = c(112L, 
            128L, 144L), snow = c(255L, 250L, 250L), springgreen = c(0L, 
            255L, 127L), steelblue = c(70L, 130L, 180L), tan = c(210L, 
            180L, 140L), thistle = c(216L, 191L, 216L), tomato = c(255L, 
            99L, 71L), turquoise = c(64L, 224L, 208L), violet = c(238L, 
            130L, 238L), wheat = c(245L, 222L, 179L), whitesmoke = c(245L, 
            245L, 245L), yellowgreen = c(154L, 205L, 50L), rebeccapurple = c(102L, 
            51L, 153L))
    if (is.vector(color) && any(is.integer(color))) {
        if (length(color) != 3) {
            stop("expected 3 values for RGB color, not ", length(color), 
                call. = FALSE)
        }
        colorVec <- color
    }
    else if (substr(color, 0, 1) == "#") {
        if (nchar(color) != 7) {
            stop("hex representation of RGB values should have the format \"#RRGGBB\", where `RR`, `GG` and `BB` are in [0x00, 0xFF]. Found: ", 
                color, call. = FALSE)
        }
        else {
            colorVec <- sapply(c(substr(color, 2, 3), substr(color, 
                4, 5), substr(color, 6, 7)), function(str) {
                strtoi(str, 16L)
            }, USE.NAMES = FALSE)
        }
    }
    else if (grepl("^rgba?", color)) {
        matches = regmatches(color, regexec("\\(([^,\\)]+),([^,\\)]+),([^,\\)]+)", 
            color))[[1]]
        if (length(matches) != 4) {
            stop("non-hex representation of RGB values should have the format \"rgb(R, G, B)\" or \"rgba(R, G, B, A)\" where `R`, `G`, and `B` are integer values in [0, 255] and `A` is decimal value in [0, 1.0]. Found: ", 
                color, call. = FALSE)
        }
        colorVec <- strtoi(matches[2:4])
    }
    else if (color %in% names(namedCssColors)) {
        colorVec <- namedCssColors[[color]]
    }
    else {
        stop("supplied color has an invalid format: ", color, 
            ". Expected \"#RRGGBB\", \"rgb(R, G, B) or \"rgba(R, G, B, A)\", where `RR`, `GG` and `BB` are in [0x00, 0xFF], `R`, `G`, and `B` are integer values in [0, 255], and `A` is decimal value in [0, 1.0]", 
            call. = FALSE)
    }
    invalidMsg <- paste0("invalid color supplied: ", color, ". ")
    if (any(is.na(colorVec)) || any(!is.integer(colorVec))) {
        stop(invalidMsg, "One or more RGB values could not be converted to an integer", 
            call. = FALSE)
    }
    if (any(colorVec < 0)) {
        stop(invalidMsg, "RGB value cannot be negative", call. = FALSE)
    }
    if (any(colorVec > 255)) {
        stop(invalidMsg, "RGB value cannot be greater than 255", 
            call. = FALSE)
    }
    colorVec
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.registryGet
function (name, package) 
{
    key <- .rs.tutorial.registryKey(name, package)
    .rs.tutorial.registry[[key]]
}
<environment: 0x000001883f4b86b8>

$.rs.markdown.acCompletionTypes
$.rs.markdown.acCompletionTypes$COMPLETION_HREF
[1] 1

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.rpc.convert_from_yaml
function (yaml) 
{
    Encoding(yaml) <- "UTF-8"
    data <- list()
    parseError <- ""
    parseSucceeded <- FALSE
    tryCatch({
        handlers <- list(r = function(x) paste("!r", x))
        data <- .rs.scalarListFromList(yaml::yaml.load(yaml, 
            handlers = handlers))
        parseSucceeded <- TRUE
    }, error = function(e) {
        parseError <<- as.character(e)
    })
    list(data = data, parse_succeeded = .rs.scalar(parseSucceeded), 
        parse_error = .rs.scalar(parseError))
}
<environment: 0x000001883f4b86b8>

$.rs.api.highlightUi
function (data = list()) 
{
    .Call("rs_highlightUi", data, PACKAGE = "(embedding)")
}
<environment: 0x000001883fe22ea8>

$.rs.api.askForSecret
function (name, title, prompt) 
{
    .rs.askForSecret(name, title, prompt)
}
<environment: 0x000001883fde7e58>

$.rs.setInternet2
function (value = NA) 
{
    if (getRversion() >= "3.3.0") 
        return(TRUE)
    if (Sys.info()[["sysname"]] != "Windows") 
        return(TRUE)
    utils::setInternet2(value)
}
<environment: 0x000001883f4b86b8>

$.rs.invokeShinyWindowViewer
function (url) 
{
    invisible(.Call("rs_shinyviewer", url, getwd(), "window", 
        NULL, PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"shinyViewerType")
[1] "window"

$.rs.rpc.get_set_method_call
function (call) 
{
    parsed <- .rs.tryParseCall(call)
    if (is.null(parsed)) 
        return(list())
    matched <- .rs.tryMatchCall(methods::setMethod, parsed)
    if (is.null(matched)) 
        return(list())
    generic <- .rs.extractElement(matched, "f", "")
    parameter.names <- character()
    parameter.types <- character()
    signature <- .rs.extractElement(matched, "signature")
    if (!is.null(signature)) {
        if (is.call(signature) && length(signature) > 1) {
            parameter.names <- names(signature)[-1]
            parameter.types <- unlist(lapply(2:length(signature), 
                function(i) {
                  if (is.character(signature[[i]])) 
                    signature[[i]]
                  else ""
                }))
        }
        else if (is.character(signature)) {
            parameter.names <- signature
        }
    }
    list(generic = generic, parameter.names = parameter.names, 
        parameter.types = parameter.types)
}
<environment: 0x000001883f4b86b8>

$.rs.valueFromStr
function (val) 
{
    .rs.withTimeLimit(1, fail = "<truncated>", {
        capture.output(try(str(val), silent = TRUE))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.parseColor
function (color) 
{
    colorLen <- nchar(color)
    if (colorLen < 1) {
        return(NULL)
    }
    if (colorLen == 4) {
        color <- gsub("([a-fA-F0-9])", "\\1\\1", color)
    }
    if (!grepl("^#[a-fA-F0-9]{6}$", color)) {
        if (!grepl("^#[a-fA-F0-9]{8}$", color)) {
            stop("Unable to parse color: ", color, "it must have format \"#RGB\", \"#RRGGBB\" or \"#RRGGBBAA\" where `R`, `G`, `B`, and `A` are in [0x00, 0xFF].", 
                call. = FALSE)
        }
        aVal <- format(round(strtoi(substr(color, 8, 9), base = 16L)/255, 
            digits = 2), nsmall = 2)
        color <- paste0("rgba(", paste(c(.rs.getRgbColor(substr(color, 
            1, 7)), aVal), collapse = ", "), ")")
    }
    color
}
<environment: 0x000001883f4b86b8>

$.rs.mget
function (x = NULL) 
{
    tryCatch({
        objects <- if (is.null(x)) 
            .rs.selectStartsWith(objects(envir = .rs.toolsEnv(), 
                all.names = TRUE), ".rs.cache")
        else paste(".rs.cache.", x, sep = "")
        mget(objects, envir = .rs.toolsEnv())
    }, error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.parseCRANReposList
function (repos) 
{
    parts <- strsplit(repos, "\\|")[[1]]
    indexes <- seq_len(length(parts)/2)
    r <- list()
    for (i in indexes) r[[parts[[2 * i - 1]]]] <- parts[[2 * 
        i]]
    r
}
<environment: 0x000001883f4b86b8>

$.rs.addGlobalFunction
function (name, FN) 
{
    envir <- .rs.toolsEnv()
    environment(FN) <- envir
    assign(name, FN, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleCheckPrereqsUnixodbc
function () 
{
    identical(suppressWarnings(system2("odbcinst", stdout = getOption("odbc.installer.verbose", 
        FALSE), stderr = getOption("odbc.installer.verbose", 
        FALSE))), 1L)
}
<environment: 0x000001883f4b86b8>

$.rs.forceUnloadPackage
function (package) 
{
    tryCatch(withCallingHandlers(.rs.forceUnloadPackageImpl(package), 
        warning = function(w) invokeRestart("muffleWarning")), 
        error = warning)
}
<environment: 0x000001883f4b86b8>

$.rs.markdown.getCompletionsHref
function (data) 
{
    token <- data$token
    path <- data$path
    if (is.null(path)) 
        return(.rs.emptyCompletions())
    workingDir <- .rs.markdown.resolveCompletionRoot(path)
    slashes <- gregexpr("[/\\]", token)[[1]]
    idx <- tail(slashes, n = 1)
    lhs <- substring(token, 1, idx - 1)
    rhs <- substring(token, idx + 1)
    isAbsolute <- grepl("^(?:[A-Z]:|/|\\\\|~)", token, perl = TRUE)
    if (!isAbsolute) 
        lhs <- file.path(workingDir, lhs)
    completions <- .rs.getCompletionsFile(token = rhs, path = lhs, 
        quote = FALSE, directoriesOnly = FALSE)
    return(completions)
}
<environment: 0x000001883f4b86b8>

$.rs.api.runScriptJob
function (path, name = NULL, encoding = "unknown", workingDir = NULL, 
    importEnv = FALSE, exportEnv = "") 
{
    if (missing(path)) 
        stop("Must specify path to R script to run.")
    if (!file.exists(path)) 
        stop("The R script '", path, "' does not exist.")
    .Call("rs_runScriptJob", path, name, encoding, workingDir, 
        importEnv, exportEnv, PACKAGE = "(embedding)")
}
<environment: 0x000001883f05eb10>

$.rs.parseYamlOpt
function (opt) 
{
    opt <- sub("^#\\|\\s*", "", opt)
    if (any(grepl(".+=.+", opt))) {
        opts <- paste(opt, collapse = " ")
        opts <- knitr:::parse_params(opts)
    }
    else {
        opts <- .rs.fromYAML(opt)
        opts <- lapply(opts, function(value) {
            if (!is.character(value)) 
                return(value)
            if (tolower(value) %in% c("y", "yes", "on")) 
                return(TRUE)
            if (tolower(value) %in% c("n", "no", "off")) 
                return(FALSE)
            else return(value)
        })
    }
    return(opts)
}
<environment: 0x000001883f4b86b8>

$.rs.Rd2HTML
function (file, package = "") 
{
    tf <- tempfile()
    on.exit(unlink(tf))
    macros <- .rs.RdLoadMacros(file)
    tools::Rd2HTML(file, out = tf, package = package, macros = macros, 
        dynamic = TRUE)
    lines <- readLines(tf, warn = FALSE)
    lines <- sub("R Documentation</td></tr></table>", "(preview) R Documentation</td></tr></table>", 
        lines)
    if (nzchar(package)) {
        lines <- sub("img src=\"figures/([^\"]*)\"", sprintf("img src=\"dev-figure?pkg=%s&figure=\\1\"", 
            package), lines)
        lines <- gsub("a href=\"../../([^/]*/help/)([^/]*)\">", 
            "a href=\"/library/\\1\\2?dev=\\2\">", lines)
    }
    paste(lines, collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.resolveFormals
function (token, object, functionName, functionCall, matchedCall, 
    envir) 
{
    tryCatch(.rs.resolveFormalsImpl(token, object, functionName, 
        functionCall, matchedCall, envir), error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.isExternalPointer
function (object) 
{
    identical(typeof(object), "externalptr")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.update_odbc_installers
function () 
{
    installerUrl <- getOption("connections-installer")
    connectionsWarning <- NULL
    if (!.rs.isDesktop()) 
        return(list())
    if (!is.null(installerUrl) && nchar(installerUrl) > 0) {
        installerHostName <- gsub("https?://|/[^:].+$", "", installerUrl)
        connectionsWarning <- tryCatch({
            installersFile <- file.path(tempdir(), basename(installerUrl))
            download.file(installerUrl, installersFile, quiet = TRUE)
            untar(installersFile, exdir = .rs.connectionOdbcInstallerPath())
            NULL
        }, error = function(e) {
            paste("Could not retrieve driver updates from ", 
                installerHostName, sep = "")
        })
    }
    list(warning = connectionsWarning)
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletionsArguments
function (source, token) 
{
    object <- tryCatch(reticulate::py_eval(source, convert = FALSE), 
        error = identity)
    if (inherits(object, "error")) 
        return(.rs.python.emptyCompletions())
    arguments <- .rs.python.getFunctionArguments(object)
    .rs.python.completions(token = token, candidates = paste(arguments, 
        "=", sep = ""), source = source, type = .rs.acCompletionTypes$ARGUMENT, 
        reorder = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleName
function (placeholder) 
{
    osName <- .rs.odbcBundleOsName()
    bitness <- .rs.odbcOsBitness()
    bundleName <- gsub("\\(os\\)", osName, placeholder)
    bundleName <- gsub("\\(bitness\\)", bitness, bundleName)
    bundleName
}
<environment: 0x000001883f4b86b8>

$.rs.scrapeHtmlAttributes
function (line) 
{
    reData <- "([[:alnum:]_-]+)[[:space:]]*=[[:space:]]*\"(\\\\.|[^\"])+\""
    reMatches <- gregexpr(reData, line)[[1]]
    starts <- c(reMatches)
    ends <- starts + attr(reMatches, "match.length") - 1
    stripped <- substring(line, starts, ends)
    equalsIndex <- regexpr("=", stripped, fixed = TRUE)
    lhs <- substring(stripped, 1, equalsIndex - 1)
    rhs <- substring(stripped, equalsIndex + 2, nchar(stripped) - 
        1)
    names(rhs) <- lhs
    as.list(rhs)
}
<environment: 0x000001883f4b86b8>

$.rs.packageHelpEncodingDefault
function () 
{
    pref <- .rs.readUiPref("default_encoding")
    .rs.nullCoalesce(pref, "UTF-8")
}
<environment: 0x000001883f4b86b8>

$.rs.success
function (result = NULL) 
{
    list(result = result, message = NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_new_odbc_connection_context
function (name, retries = 1) 
{
    singleEntryFilter <- function(e) {
        identical(as.character(e$name), name)
    }
    connectionContext <- Filter(singleEntryFilter, .rs.connectionReadOdbc())
    while (length(connectionContext) != 1 && (retries <- retries - 
        1) >= 0) Sys.sleep(1)
    if (length(connectionContext) != 1) 
        list(error = .rs.scalar(paste("The", name, "driver is not registered.")))
    else {
        connectionContext[[1]]
    }
}
<environment: 0x000001883f4b86b8>

$.rs.editor
function (name, file = "", title = file, ...) 
{
    if (missing(name) || is.null(name)) 
        return(.Call("rs_editFile", file, PACKAGE = "(embedding)"))
    if (is.null(file) || !nzchar(file)) {
        file <- tempfile("rstudio-scratch-", fileext = ".R")
        on.exit(unlink(file), add = TRUE)
    }
    deparsed <- if (is.function(name)) 
        .rs.deparseFunction(name, useSource = TRUE, asString = FALSE)
    else deparse(name)
    writeLines(deparsed, con = file)
    .Call("rs_editFile", file, PACKAGE = "(embedding)")
    eval(parse(file), envir = globalenv())
}
<environment: 0x000001883f4b86b8>

$.rs.hydrateCacheFromNotebook
function (nbPath, cachePath = NULL) 
{
    if (is.null(cachePath)) {
        rmdPath <- .rs.withChangedExtension(nbPath, ".Rmd")
        cachePath <- .rs.rnb.cachePathFromRmdPath(rmdPath)
    }
    if (!.rs.dirExists(cachePath)) 
        dir.create(cachePath, recursive = TRUE)
    nbData <- rmarkdown::parse_html_notebook(nbPath)
    unlink(list.files(cachePath, full.names = TRUE), recursive = TRUE)
    lastActiveAnnotation <- list()
    activeChunkId <- "unknown"
    activeChunkIndex <- 0
    activeIndex <- 2
    headerContent <- nbData$source[(grep("^\\s*<head>\\s*$", 
        nbData$source, perl = TRUE)[[1]] + 1):(grep("^\\s*</head>\\s*$", 
        nbData$source, perl = TRUE)[[1]] - 1)]
    chunkInfo <- .rs.extractRmdChunkInformation(nbData$rmd)
    outputPath <- function(cachePath, chunkId, index, ext) {
        file.path(cachePath, chunkId, sprintf("%06i.%s", as.integer(index), 
            ext))
    }
    onText <- function(annotation) {
        if (identical(annotation$state, "begin") && identical(lastActiveAnnotation$label, 
            "text") && identical(lastActiveAnnotation$state, 
            "end")) {
            activeChunkId <<- .rs.rnb.generateRandomChunkId()
            activeChunkIndex <<- activeChunkIndex + 1
            activeIndex <<- 2
        }
    }
    consoleDataBuilder <- .rs.listBuilder()
    writeConsoleData <- function(builder) {
        if (builder$empty()) 
            return()
        df <- .rs.rbindList(builder$data())
        df <- df[c("type", "data")]
        df$type[df$type == "input"] <- "0"
        df$type[df$type == "output"] <- "1"
        path <- outputPath(cachePath, activeChunkId, activeIndex, 
            "csv")
        .rs.ensureDirectory(dirname(path))
        write.table(df, file = path, quote = TRUE, sep = ",", 
            row.names = FALSE, col.names = FALSE, fileEncoding = "UTF-8")
        builder$clear()
        activeIndex <<- activeIndex + 1
    }
    onSource <- function(annotation) {
        if (annotation$state == "begin") {
            consoleDataBuilder$append(list(data = paste(annotation$meta$data, 
                collapse = "\n"), type = "input"))
        }
        else {
        }
    }
    onOutput <- function(annotation) {
        if (annotation$state == "begin") {
            consoleDataBuilder$append(list(data = paste(annotation$meta$data, 
                collapse = "\n"), type = "output"))
        }
        else {
        }
    }
    chunkDefnsBuilder <- .rs.listBuilder()
    onChunk <- function(annotation) {
        if (annotation$state == "begin") {
            activeChunkIndex <<- activeChunkIndex + 1
            activeIndex <<- 2
            info <- chunkInfo[[activeChunkIndex]]
            candidates <- c(letters, 0:9)
            if (.rs.isSetupChunk(info$contents)) 
                activeChunkId <<- "csetup_chunk"
            else activeChunkId <<- .rs.rnb.generateRandomChunkId()
            chunkDefnsBuilder$append(list(chunk_id = activeChunkId, 
                expansion_state = 0, options = list(), row = info$end - 
                  1, row_count = 1, visible = TRUE))
        }
        else {
            writeConsoleData(consoleDataBuilder)
            activeChunkId <<- "unknown"
        }
    }
    plotRange <- list(start = NULL, end = NULL)
    plotMeta <- NULL
    writePlot <- function(source, range, meta) {
        html <- paste(source[(range$start + 1):(range$end - 1)], 
            collapse = " ")
        scraped <- .rs.scrapeHtmlAttributes(html)
        ext <- if (.rs.startsWith(scraped$src, "data:image/jpeg;")) 
            "jpeg"
        else "png"
        imgDataEncoded <- substring(scraped$src, nchar(paste("data:image/", 
            ext, ";base64,", sep = "")) + 1)
        imgData <- .rs.base64decode(imgDataEncoded, binary = TRUE)
        path <- outputPath(cachePath, activeChunkId, activeIndex, 
            ext)
        .rs.ensureDirectory(dirname(path))
        writeBin(imgData, path, useBytes = TRUE)
        if (!is.null(meta) && !is.null(meta$metadata)) {
            metaPath <- outputPath(cachePath, activeChunkId, 
                activeIndex, "metadata")
            cat(.rs.toJSON(meta, unbox = TRUE), file = metaPath, 
                sep = "\n")
        }
        activeIndex <<- activeIndex + 1
    }
    onPlot <- function(annotation) {
        if (annotation$state == "begin") {
            writeConsoleData(consoleDataBuilder)
            plotRange$start <<- annotation$row
            plotMeta <<- annotation$meta
        }
        else {
            plotRange$end <<- annotation$row
            writePlot(nbData$source, plotRange, plotMeta)
            plotRange <<- list(start = NULL, end = NULL)
            plotMeta <<- NULL
        }
    }
    frameRange <- list(start = NULL, end = NULL)
    frameMeta <- NULL
    writeFrame <- function(source, range, meta) {
        if (is.null(meta)) 
            return(NULL)
        if (!is.null(meta$metadata)) {
            metaPath <- outputPath(cachePath, activeChunkId, 
                activeIndex, "metadata")
            cat(.rs.toJSON(meta$metadata, unbox = TRUE), file = metaPath, 
                sep = "\n")
        }
        if (!is.null(meta$rdf)) {
            rdfPath <- outputPath(cachePath, activeChunkId, activeIndex, 
                "rdf")
            writeBin(object = .rs.base64decode(meta$rdf, binary = TRUE), 
                con = rdfPath)
        }
    }
    onFrame <- function(annotation) {
        if (annotation$state == "begin") {
            writeConsoleData(consoleDataBuilder)
            frameRange$start <<- annotation$row
            frameMeta <<- annotation$meta
        }
        else {
            frameRange$end <<- annotation$row
            writeFrame(nbData$source, frameRange, frameMeta)
            frameRange <<- list(start = NULL, end = NULL)
            frameMeta <<- NULL
        }
    }
    htmlRange <- list(start = NULL, end = NULL)
    htmlMeta <- NULL
    writeHtml <- function(source, range, meta) {
        htmlOutput <- source[(range$start + 1):(range$end - 1)]
        htmlPath <- outputPath(cachePath, activeChunkId, activeIndex, 
            "html")
        cat(htmlOutput, file = htmlPath, sep = "\n")
        if (!is.null(meta) && !is.null(meta$metadata)) {
            metaPath <- outputPath(cachePath, activeChunkId, 
                activeIndex, "metadata")
            cat(.rs.toJSON(meta, unbox = TRUE), file = metaPath, 
                sep = "\n")
        }
        activeIndex <<- activeIndex + 1
    }
    onHtml <- function(annotation) {
        if (annotation$state == "begin") {
            writeConsoleData(consoleDataBuilder)
            htmlRange$start <<- annotation$row
            htmlMeta <<- annotation$meta
        }
        else {
            htmlRange$end <<- annotation$row
            writeHtml(nbData$source, htmlRange, htmlMeta)
            htmlRange <<- list(start = NULL, end = NULL)
            htmlMeta <<- NULL
        }
    }
    widgetRange <- list(start = NULL, end = NULL)
    widgetMeta <- NULL
    writeHtmlWidget <- function(source, range, meta) {
        htmlBody <- source[(range$start + 1):(range$end - 1)]
        fmt <- paste("<!DOCTYPE html>", "<html>", "<head>", "%s", 
            "</head>", "<body style=\"background-color:white;\">", 
            "%s", "</body>", "</html>", sep = "\n")
        htmlOutput <- sprintf(fmt, paste(headerContent, collapse = "\n"), 
            paste(htmlBody, collapse = "\n"))
        htmlPath <- outputPath(cachePath, activeChunkId, activeIndex, 
            "html")
        cat(htmlOutput, file = htmlPath, sep = "\n")
        jsonPath <- outputPath(cachePath, activeChunkId, activeIndex, 
            "json")
        cat(.rs.toJSON(meta, unbox = TRUE), file = jsonPath, 
            sep = "\n")
        activeIndex <<- activeIndex + 1
    }
    onHtmlWidget <- function(annotation) {
        if (annotation$state == "begin") {
            writeConsoleData(consoleDataBuilder)
            widgetRange$start <<- annotation$row
            widgetMeta <<- annotation$meta
        }
        else {
            widgetRange$end <- annotation$row
            writeHtmlWidget(nbData$source, widgetRange, widgetMeta)
            widgetRange <<- list(start = NULL, end = NULL)
            widgetMeta <<- NULL
        }
    }
    annotations <- nbData$annotations
    for (i in seq_along(annotations)) {
        annotation <- annotations[[i]]
        label <- annotation$label
        switch(label, text = onText(annotation), chunk = onChunk(annotation), 
            source = onSource(annotation), output = onOutput(annotation), 
            plot = onPlot(annotation), html = onHtml(annotation), 
            frame = onFrame(annotation), htmlwidget = onHtmlWidget(annotation))
        lastActiveAnnotation <- annotation
    }
    mtime <- file.info(nbPath)$mtime
    chunks <- list(chunk_definitions = chunkDefnsBuilder$data(), 
        doc_write_time = as.numeric(mtime))
    chunksJson <- .rs.toJSON(chunks, unbox = TRUE)
    chunksJsonPath <- file.path(cachePath, "chunks.json")
    cat(chunksJson, file = chunksJsonPath, sep = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.previewSql
function (conn, statement, ...) 
{
    script <- NULL
    if (file.exists(statement)) {
        script <- statement
        statement <- paste(readLines(script), collapse = "\n")
    }
    statement <- gsub("--[^\n]*\n+", "", statement)
    conn <- .rs.tryCatch(force(conn))
    if (inherits(conn, "error")) {
        msg <- paste("Failed to retrieve connection:", conditionMessage(conn))
        return(.rs.scalar(msg))
    }
    status <- .rs.tryCatch({
        rs <- DBI::dbSendQuery(conn, statement = statement, ...)
        data <- DBI::dbFetch(rs, n = 1000)
        DBI::dbClearResult(rs)
    })
    if (inherits(status, "error")) {
        msg <- paste("Failed to query database:", conditionMessage(status))
        return(.rs.scalar(msg))
    }
    .rs.previewDataFrame(data, script)
}
<environment: 0x000001883f4b86b8>

$.rs.api.getActiveDocumentContext
function () 
{
    .Call("rs_getEditorContext", 0L, NULL, PACKAGE = "(embedding)")
}
<environment: 0x000001883fd1ece8>

$.rs.transposeList
function (list) 
{
    do.call(Map, c(c, list, USE.NAMES = FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_rsconnect_lint_results
function (target) 
{
    err <- ""
    results <- NULL
    basePath <- ""
    if (!file.exists(target)) {
        err <- paste("The file or directory ", target, " does not exist.")
    }
    else {
        tryCatch({
            info <- file.info(target)
            if (info$isdir) {
                basePath <- target
                results <- rsconnect::lint(project = basePath)
            }
            else if (tolower(tools::file_ext(target)) == "r") {
                basePath <- dirname(target)
                results <- rsconnect::lint(project = basePath, 
                  appPrimaryDoc = basename(target))
            }
            else {
                basePath <- dirname(target)
                results <- rsconnect::lint(project = basePath, 
                  files = basename(target))
            }
        }, error = function(e) {
            err <<- e$message
        })
    }
    if (identical(length(results), 0) || !rsconnect:::hasLint(results)) {
        return(list(has_lint = .rs.scalar(FALSE), error_message = .rs.scalar(err)))
    }
    rsconnect:::showRstudioSourceMarkers(basePath = basePath, 
        results)
    list(has_lint = .rs.scalar(TRUE), error_message = .rs.scalar(err))
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsFromShinyUI
function (token, filePath, string, type) 
{
    dir <- dirname(filePath)
    serverPath <- file.path(dir, "server.R")
    uiPath <- file.path(dir, "ui.R")
    name <- tolower(basename(filePath))
    if (!file.exists(uiPath)) 
        return(NULL)
    completions <- .rs.shinyUICompletions(uiPath)
    results <- if (string == "input") 
        .rs.selectFuzzyMatches(completions$input, token)
    else .rs.selectFuzzyMatches(completions$output, token)
    return(.rs.makeCompletions(token = token, results = results, 
        packages = uiPath, quote = type == .rs.acContextTypes$DOUBLE_BRACKET, 
        type = .rs.acCompletionTypes$CONTEXT, excludeOtherCompletions = type == 
            .rs.acContextTypes$DOLLAR))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.tutorial_metadata
function (url) 
{
    tutorial <- .rs.tutorial.registryFind(url)
    if (is.null(tutorial)) 
        return(list())
    .rs.scalarListFromList(as.list(tutorial))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.tutorial_started
function (name, package, url) 
{
    tutorial <- .rs.tutorial.registryGet(name, package)
    tutorial[["browser_url"]] <- url
}
<environment: 0x000001883f4b86b8>

$.rs.api.getThemes
function () 
{
    lapply(.rs.getThemes(), function(theme) {
        theme[names(theme) != "url"]
    })
}
<environment: 0x000001883f40a680>

$.rs.replaceBinding
function (binding, package, override) 
{
    if (!requireNamespace(package, quietly = TRUE)) 
        stop(sprintf("Failed to load namespace for package '%s'", 
            package))
    namespace <- asNamespace(package)
    original <- get(binding, envir = namespace)
    if (is.function(override)) 
        environment(override) <- namespace
    do.call("unlockBinding", list(binding, namespace))
    assign(binding, override, envir = namespace)
    do.call("lockBinding", list(binding, namespace))
    searchPathName <- paste("package", package, sep = ":")
    if (searchPathName %in% search()) {
        env <- as.environment(searchPathName)
        if (exists(binding, envir = env)) {
            do.call("unlockBinding", list(binding, env))
            assign(binding, override, envir = env)
            do.call("lockBinding", list(binding, env))
        }
    }
    original
}
<environment: 0x000001883f4b86b8>

$.rs.systemToUtf8
function (text) 
{
    .Call("rs_systemToUtf8", as.character(text), PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.python.getPythonVersion
function (pythonPath) 
{
    .rs.python.execute(pythonPath, "import platform; print(platform.python_version())")
}
<environment: 0x000001883f4b86b8>

$.rs.addFirstRunDocumentsForTemplate
function (projectFilePath, projectPath, openFiles) 
{
    projectFiles <- list.files(projectPath, recursive = TRUE)
    reOpenFiles <- glob2rx(openFiles)
    files <- Reduce(union, lapply(reOpenFiles, function(regex) {
        grep(regex, projectFiles, value = TRUE)
    }))
    scratchPaths <- .Call("rs_computeScratchPaths", projectFilePath, 
        PACKAGE = "(embedding)")
    scratchPath <- scratchPaths$scratch_path
    .Call("rs_addFirstRunDoc", scratchPath, files, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.renv.listPackages
function (project) 
{
    installedPackages <- .rs.listInstalledPackages()
    lockfilePackages <- .rs.tryCatch(.rs.renv.readLockfilePackages(project))
    if (inherits(lockfilePackages, "error")) 
        return(installedPackages)
    names(lockfilePackages) <- c("name", "packrat.version", "packrat.source")
    installedPackages[["in.project.library"]] <- installedPackages$library_absolute == 
        renv:::renv_paths_library(project = project)
    merge.data.frame(x = installedPackages, y = lockfilePackages, 
        by = "name", all.x = TRUE, all.y = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.askForSecret
function (name, title = name, prompt = paste(name, ":", sep = "")) 
{
    result <- .Call("rs_askForSecret", name, title, prompt, .rs.isPackageInstalled("keyring"), 
        .rs.hasSecret(name))
    if (is.null(result)) 
        stop("Ask for secret operation was cancelled.")
    result
}
<environment: 0x000001883f4b86b8>

$RStudioGD
function () 
{
    .Call("rs_createGD")
}
<environment: 0x000001883f4b86b8>

$.rs.api.restartSession
function (command = NULL) 
{
    command <- as.character(command)
    invisible(.rs.restartR(command))
}
<environment: 0x000001883fcdcf78>

$.rs.get
function (x) 
{
    tryCatch(get(paste(".rs.cache.", x, sep = ""), envir = .rs.toolsEnv()), 
        error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.api.closeAllSourceBuffersWithoutSaving
function () 
{
    .Call("rs_documentCloseAllNoSave", PACKAGE = "(embedding)")
}
<environment: 0x000001883fd92740>

$.rs.connectionFilesPath
function () 
{
    snippetsPath <- getOption("connections-path", "/etc/rstudio/connections/")
    if (!is.null(getOption("connections-path")) && !dir.exists(snippetsPath)) {
        warning("Path '", snippetsPath, "' does not exist. ", 
            "Configure the connections-path option appropriately.")
    }
    snippetsPath
}
<environment: 0x000001883f4b86b8>

$.rs.getNativeSymbols
function (package) 
{
    loadedDLLs <- getLoadedDLLs()
    if (package %in% names(loadedDLLs)) 
        return(.rs.extractNativeSymbols(loadedDLLs[[package]]))
    character()
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.preview_data_import
function (dataImportOptions, maxCols = 100, maxFactors = 64) 
{
    dataImportOptions$importLocation <- .rs.pathRelativeToWorkingDir(dataImportOptions$importLocation)
    dataImportOptions$modelLocation <- .rs.pathRelativeToWorkingDir(dataImportOptions$modelLocation)
    tryCatch({
        Encoding(dataImportOptions$importLocation) <- "UTF-8"
        beforeImportFromOptions <- list(text = function() {
            dataImportOptions$columnsOnly <<- FALSE
            if (!identical(dataImportOptions$columnDefinitions, 
                NULL)) {
                dataImportOptions$columnDefinitions <<- Filter(function(e) {
                  !(identical(e$assignedType, "skip") || identical(e$assignedType, 
                    "only"))
                }, dataImportOptions$columnDefinitions)
            }
        }, xls = function() {
            if (!identical(dataImportOptions$columnDefinitions, 
                NULL)) {
                dataImportOptions$columnDefinitions <<- lapply(dataImportOptions$columnDefinitions, 
                  function(e) {
                    if (identical(e$assignedType, "skip")) {
                      e$assignedType <- "character"
                    }
                    e
                  })
            }
        })
        optionsInfoFromOptions <- list(text = function() {
            return(list(columnTypes = c("guess", "date", "time", 
                "double", "factor", "numeric", "integer", "logical", 
                "dateTime", "character", "include", "only", "skip")))
        }, statistics = function() {
            return(list(columnTypes = list()))
        }, xls = function() {
            sheets <- list()
            if (!identical(sheets, NULL)) {
                sheets <- tryCatch({
                  readxl::excel_sheets(path = dataImportOptions$importLocation)
                }, error = function(e) {
                  list()
                })
            }
            return(list(sheets = sheets, columnTypes = c("numeric", 
                "date", "character", "include", "skip")))
        })
        parsingErrorsFromMode <- function(mode, data) {
            modeFunc <- list(text = function(data) {
                length(readr::problems(data)$row)
            })
            if (identical(modeFunc[[mode]], NULL)) 
                0
            else modeFunc[[mode]](data)
        }
        if (dataImportOptions$mode %in% names(beforeImportFromOptions)) {
            beforeImportFromOptions[[dataImportOptions$mode]]()
        }
        dataImportOptions$canCacheData <- TRUE
        importInfo <- .rs.assembleDataImport(dataImportOptions)
        data <- suppressWarnings(eval(parse(text = importInfo$previewCode)))
        parsingErrors <- parsingErrorsFromMode(dataImportOptions$mode, 
            data)
        preparedData <- .rs.prepareViewerData(data, maxFactors = maxFactors, 
            maxCols = maxCols, maxRows = dataImportOptions$maxRows)
        options <- optionsInfoFromOptions[[dataImportOptions$mode]]()
        return(list(data = preparedData$data, columns = preparedData$columns, 
            options = options, parsingErrors = parsingErrors, 
            localFiles = importInfo$localFiles))
    }, error = function(e) {
        return(list(error = e))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.has_shinytest_results
function (testFile) 
{
    dirExists <- dir.exists(file.path(dirname(testFile), paste(tools::file_path_sans_ext(basename(testFile)), 
        "current", sep = "-")))
    shinyDir <- dirname(testFile)
    if (identical(basename(shinyDir), "shinytests") || identical(basename(shinyDir), 
        "shinytest")) {
        shinyDir <- dirname(shinyDir)
    }
    if (identical(basename(shinyDir), "tests")) {
        shinyDir <- dirname(shinyDir)
    }
    else {
        stop("Could not find Shiny app for test file ", testFile)
    }
    list(appDir = .rs.scalar(shinyDir), testDirExists = .rs.scalar(dirExists))
}
<environment: 0x000001883f4b86b8>

$.rs.parseTmTheme
function (filePath) 
{
    if (!file.exists(filePath)) {
        stop("The specified file, \"", filePath, "\", does not exist.", 
            call. = FALSE)
    }
    xmlStr <- paste(readLines(filePath, encoding = "UTF-8", warn = FALSE), 
        collapse = "\n")
    tmThemeDoc <- xml2::xml_root(xml2::read_xml(xmlStr, error = function(msg, 
        code, domain, line, col, level, filename) {
        stop("An error occurred while parsing ", filename, " at line ", 
            line, ": ", msg, call. = FALSE)
    }, encoding = "UTF-8"))
    childrenCount <- xml2::xml_length(tmThemeDoc)
    if (childrenCount != 1) {
        stop("Expected 1 non-text child of the root, found: ", 
            childrenCount, call. = FALSE)
    }
    if (xml2::xml_name(xml2::xml_child(tmThemeDoc, 1)) != "dict") {
        stop("Expecting \"dict\" element; found \"", xml2::xml_name(xml2::xml_child(tmThemeDoc, 
            1)), "\".", call. = FALSE)
    }
    if (xml2::xml_length(xml2::xml_child(tmThemeDoc, 1)) < 1) {
        stop("\"dict\" element cannot be empty.", call. = FALSE)
    }
    .rs.parseDictElement(xml2::xml_child(tmThemeDoc, 1), "")
}
<environment: 0x000001883f4b86b8>

$.rs.haveAdvancedSteppingCommands
function () 
{
    getRversion() >= "3.1" && .rs.haveRequiredRSvnRev(63400)
}
<environment: 0x000001883f4b86b8>

$.rs.makeCompletions
function (token, results, packages = character(), quote = logical(), 
    type = numeric(), meta = character(), fguess = "", excludeOtherCompletions = FALSE, 
    excludeOtherArgumentCompletions = FALSE, overrideInsertParens = FALSE, 
    orderStartsWithAlnumFirst = TRUE, cacheable = TRUE, helpHandler = NULL, 
    language = "R", context = numeric(), suggestOnAccept = NULL) 
{
    if (is.null(results)) 
        results <- character()
    if (is.null(token)) 
        token <- ""
    n <- length(results)
    packages <- .rs.formCompletionVector(packages, "", n)
    quote <- .rs.formCompletionVector(quote, FALSE, n)
    type <- .rs.formCompletionVector(type, .rs.acCompletionTypes$UNKNOWN, 
        n)
    meta <- .rs.formCompletionVector(meta, "", n)
    context <- .rs.formCompletionVector(context, .rs.acCompletionTypes$UNKNOWN, 
        n)
    if (!is.null(suggestOnAccept)) 
        suggestOnAccept <- .rs.formCompletionVector(suggestOnAccept, 
            FALSE, n)
    if (orderStartsWithAlnumFirst) {
        startsWithLetter <- grepl("^[a-zA-Z0-9]", results, perl = TRUE)
        first <- which(startsWithLetter)
        last <- which(!startsWithLetter)
        order <- c(first, last)
        results <- results[order]
        packages <- packages[order]
        quote <- quote[order]
        type <- type[order]
        meta <- meta[order]
        if (!is.null(suggestOnAccept)) 
            suggestOnAccept <- suggestOnAccept[order]
    }
    limit <- 2000
    if (length(results) > limit) {
        cacheable <- FALSE
        idx <- seq_len(limit)
        results <- results[idx]
        packages <- packages[idx]
        quote <- quote[idx]
        type <- type[idx]
        meta <- meta[idx]
        if (!is.null(suggestOnAccept)) 
            suggestOnAccept <- suggestOnAccept[idx]
    }
    list(token = token, results = results, packages = packages, 
        quote = quote, type = type, meta = meta, fguess = fguess, 
        excludeOtherCompletions = .rs.scalar(excludeOtherCompletions), 
        excludeOtherArgumentCompletions = .rs.scalar(excludeOtherArgumentCompletions), 
        overrideInsertParens = .rs.scalar(overrideInsertParens), 
        cacheable = .rs.scalar(cacheable), helpHandler = .rs.scalar(helpHandler), 
        language = .rs.scalar(language), context = context, suggestOnAccept = suggestOnAccept)
}
<bytecode: 0x000001883c308d48>
<environment: 0x000001883f4b86b8>

$.rs.stripSurrounding
function (string) 
{
    complements <- list(c("(", ")"), c("{", "}"), c("[", "]"), 
        c("<", ">"))
    result <- .rs.doStripSurrounding(string, complements)
    while (result != string) {
        string <- result
        result <- .rs.doStripSurrounding(string, complements)
    }
    result
}
<bytecode: 0x000001883c727cf0>
<environment: 0x000001883f4b86b8>

$.rs.assign
function (x, value) 
{
    assign(paste(".rs.cache.", x, sep = ""), value, envir = .rs.toolsEnv())
}
<environment: 0x000001883f4b86b8>

$.rs.executeChunkCallback
function (chunkName, chunkCode) 
{
    if (exists(".rs.notebookChunkCallbacks", envir = .rs.toolsEnv()) && 
        length(.rs.notebookChunkCallbacks) != 0) {
        handle <- ls(envir = .rs.notebookChunkCallbacks)
        chunkCallback <- get(handle, envir = .rs.notebookChunkCallbacks)
        return(chunkCallback(eval(chunkName), eval(chunkCode)))
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.formatListForDialog
function (list, sep = ", ", max = 50L) 
{
    nc <- 0L
    ns <- nchar(sep)
    for (index in seq_along(list)) {
        nc <- nc + ns + nchar(list[[index]])
        if (nc > max) 
            break
    }
    n <- length(list)
    items <- list
    if (index < n - 1L) 
        items <- c(list[1:index], paste("and", n - index, "others"))
    text <- paste(items, collapse = sep)
    .rs.truncate(text, n = max * 2L)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionPreviewObject
function (type, host, limit, ...) 
{
    connection <- .rs.findActiveConnection(type, host)
    if (!is.null(connection)) {
        df <- connection$previewObject(limit, ...)
        args <- list(...)
        .rs.viewDataFrame(df, args[[length(args)]], TRUE)
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.error
function (...) 
{
    list(result = NULL, message = .rs.scalar(paste(..., sep = "")))
}
<environment: 0x000001883f4b86b8>

$.rs.dialogIcon
function (name = NULL) 
{
    icons <- list(info = 1, warning = 2, error = 3, question = 4)
    if (is.null(name)) 
        icons
    else icons[[name]]
}
<environment: 0x000001883f4b86b8>

$.rs.connectionReadOdbc
function () 
{
    if (.rs.isPackageInstalled("odbc")) {
        drivers <- data.frame()
        tryCatch({
            drivers <- get("odbcListDrivers", envir = asNamespace("odbc"))()
            if (.Platform$OS.type == "windows") {
                drivers <- rbind(drivers, .rs.connectionReadWindowsRegistry())
            }
        }, error = function(e) warning(e$message))
        uniqueDriverNames <- unique(drivers$name)
        lapply(uniqueDriverNames, function(driver) {
            .rs.connectionReadOdbcEntry(drivers, uniqueDriverNames, 
                driver)
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.setCRANRepos
function (cran, secondary) 
{
    local({
        r <- c(list(CRAN = cran), .rs.parseCRANReposList(secondary))
        n <- names(r)
        r <- as.character(r)
        names(r) <- n
        attr(r, "RStudio") <- TRUE
        options(repos = r)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.addFunction
function (name, FN, attrs = list(), envir = .rs.toolsEnv()) 
{
    for (attrib in names(attrs)) attr(FN, attrib) <- attrs[[attrib]]
    environment(FN) <- envir
    fullName <- paste(".rs.", name, sep = "")
    assign(fullName, FN, envir = .rs.toolsEnv())
}
<bytecode: 0x000001883fadd550>
<environment: 0x000001883f4b86b8>

$.rs.rpc.uninstall_odbc_driver
function (driverName) 
{
    tryCatch({
        defaultInstallPath <- file.path(.rs.connectionOdbcInstallPath(), 
            tolower(driverName))
        defaultInstallExists <- dir.exists(defaultInstallPath)
        if (defaultInstallExists) {
            unlink(defaultInstallPath, recursive = TRUE)
        }
        if (identical(tolower(Sys.info()["sysname"][[1]]), "windows")) {
            .rs.connectionUnregisterWindowsDriver(driverName)
        }
        else {
            .rs.connectionUnregisterOdbcinstDriver(driverName)
        }
        if (!defaultInstallExists) {
            list(message = .rs.scalar(paste("The", driverName, 
                "driver was not found in the default installation path;", 
                "if appropriate, please manually remove this driver.")))
        }
        else {
            list()
        }
    }, error = function(e) {
        list(error = .rs.scalar(e$message))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.listJsonRpcHandlers
function () 
{
    rpcHandlers <- objects("tools:rstudio", all.names = TRUE, 
        pattern = utils:::glob2rx(".rs.rpc.*"))
    return(rpcHandlers)
}
<environment: 0x000001883f4b86b8>

$.rs.libclang.generateCompilerDefinitions
function (path, isCpp = TRUE) 
{
    if (.rs.platform.isWindows) {
        envpath <- Sys.getenv("PATH")
        on.exit(Sys.setenv(PATH = envpath), add = TRUE)
        .rs.addRToolsToPath()
    }
    exe <- if (.rs.platform.isWindows) 
        "R.exe"
    else "R"
    R <- file.path(R.home("bin"), exe)
    args <- c("CMD", "config", if (isCpp) "CXX" else "CC")
    output <- system2(R, args, stdout = TRUE, stderr = TRUE)
    compiler <- tail(output, n = 1L)
    if (.rs.platform.isWindows && getRversion() >= "4.0.0" && 
        getRversion() < "4.2.0" && (.rs.startsWith(compiler, 
        "/mingw32/bin") || .rs.startsWith(compiler, "/mingw64/bin"))) {
        for (root in c("C:/rtools40", "C:/RBuildTools/4.0")) {
            if (file.exists(root)) {
                compiler <- paste0(root, compiler)
                break
            }
        }
    }
    file <- tempfile(fileext = if (isCpp) 
        ".cpp"
    else ".c")
    writeLines("void test() {}", con = file)
    command <- paste(compiler, "-dM -E", basename(file))
    output <- .rs.tryCatch({
        owd <- setwd(tempdir())
        on.exit(setwd(owd), add = TRUE)
        suppressWarnings(system(command, intern = TRUE))
    })
    if (inherits(output, "error")) 
        return()
    formatted <- unlist(lapply(output, function(line) {
        parts <- strsplit(line, "\\s+", perl = TRUE)[[1L]]
        fmt <- "#ifndef %s\n%s\n#endif\n"
        msg <- sprintf(fmt, gsub("\\(.*", "", parts[[2L]]), line)
        gsub("#define", "# define", msg)
    }))
    if (.rs.platform.isWindows && isCpp) {
        formatted <- c("#include <bits/c++config.h>", "", formatted, 
            "", "#undef _GLIBCXX_USE_FLOAT128")
    }
    dir.create(dirname(path), showWarnings = FALSE, recursive = TRUE)
    writeLines(formatted, con = path)
    normalizePath(path)
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.outputSourcePng
function (fileName, fileContents, metadata, ...) 
{
    rmarkdown:::html_notebook_output_png(bytes = fileContents, 
        meta = metadata)
}
<environment: 0x000001883f4b86b8>

$.rs.resolveAliasedPath
function (path) 
{
    .Call("rs_resolveAliasedPath", path, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.python.isPython3
function () 
{
    config <- reticulate::py_config()
    grepl("^3", config$version)
}
<environment: 0x000001883f4b86b8>

$.rs.runUserDefinedEngine
function (engine, code, options) 
{
    Encoding(code) <- "UTF-8"
    code <- .rs.trimCommonIndent(code)
    useReticulate <- identical(engine, "python") && !identical(getOption("python.reticulate"), 
        FALSE)
    if (useReticulate) {
        requireNamespace("reticulate", quietly = TRUE)
    }
    knitrEngines <- knitr::knit_engines$get()
    if (!engine %in% names(knitrEngines)) {
        fmt <- "engine '%s' has not yet been registered"
        stop(sprintf(fmt, options))
    }
    knitrEngine <- knitrEngines[[engine]]
    if (!is.function(knitrEngine)) {
        fmt <- "engine '%s' is not a function"
        stop(sprintf(fmt, options))
    }
    if (useReticulate) {
        show <- getOption("reticulate.engine.matplotlib.show")
        on.exit(options(reticulate.engine.matplotlib.show = show), 
            add = TRUE)
        options(reticulate.engine.matplotlib.show = function(plt, 
            options) {
            path <- tempfile("reticulate-matplotlib-plot-", fileext = ".png")
            plt$savefig(path, dpi = options$dpi)
            structure(list(path = path), class = "reticulate_matplotlib_plot")
        })
        wrap <- getOption("reticulate.engine.wrap")
        on.exit(options(reticulate.engine.wrap = wrap), add = TRUE)
        options(reticulate.engine.wrap = function(outputs, options) {
            sys <- reticulate::import("sys", convert = TRUE)
            if (!is.null(sys$modules$matplotlib$pyplot)) {
                plt <- reticulate::import("matplotlib.pyplot", 
                  convert = TRUE)
                tryCatch(plt$clf(), error = identity)
            }
            outputs
        })
        environment <- getOption("reticulate.engine.environment")
        on.exit(options(reticulate.engine.environment = environment), 
            add = TRUE)
        options(reticulate.engine.environment = globalenv())
    }
    mergedOptions <- knitr::opts_chunk$merge(options)
    code <- strsplit(code, "\n", fixed = TRUE)[[1]]
    mergedOptions$code <- code
    mergedOptions$echo <- FALSE
    knitrEngine(mergedOptions)
}
<environment: 0x000001883f4b86b8>

$.rs.findRtoolsInstaller
function (url, fallbackUrl) 
{
    tryCatch({
        tmp <- tempfile()
        utils::download.file(url, tmp, mode = "w", quiet = TRUE)
        homePageHtml <- paste(readLines(tmp), collapse = " ")
        unlink(tmp)
    }, error = function(e) {
        return(fallbackUrl)
    })
    reLinkPattern <- ".*<a\\shref=\"(.*rtools.*\\.exe)\">\\s*.+<\\/a>.*"
    if (grepl(reLinkPattern, homePageHtml)) {
        urlRoot <- dirname(url)
        installerUrl <- gsub(reLinkPattern, "\\1", homePageHtml)
        file.path(urlRoot, installerUrl)
    }
    else fallbackUrl
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsDollar
function (token, string, functionCall, envir, isAt) 
{
    if (.rs.isDataTableExtractCall(string, envir = envir)) 
        return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
    object <- .rs.getAnywhere(string, envir)
    if (is.null(object)) 
        return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
    allNames <- character()
    names <- character()
    type <- numeric()
    helpHandler <- NULL
    if (isAt) {
        if (isS4(object)) {
            tryCatch({
                allNames <- .slotNames(object)
                names <- .rs.selectFuzzyMatches(allNames, token)
                if (length(names) > 200) 
                  type <- .rs.acCompletionTypes$UNKNOWN
                else {
                  type <- numeric(length(names))
                  for (i in seq_along(names)) {
                    type[[i]] <- suppressWarnings(tryCatch(.rs.getCompletionType(eval(call("@", 
                      quote(object), names[[i]]))), error = function(e) .rs.acCompletionTypes$UNKNOWN))
                  }
                }
            }, error = function(e) NULL)
        }
    }
    else {
        dollarNamesMethod <- .rs.getDollarNamesMethod(object, 
            TRUE, envir = envir)
        if (is.function(dollarNamesMethod)) {
            allNames <- dollarNamesMethod(object, "")
            types <- ifelse(grepl("[()]\\s*$", allNames), .rs.acCompletionTypes$FUNCTION, 
                .rs.acCompletionTypes$UNKNOWN)
            allNames <- gsub("[()]*\\s*$", "", allNames)
            attr(allNames, "types") <- as.integer(types)
            helpHandler <- attr(allNames, "helpHandler", exact = TRUE)
        }
        else if (inherits(object, "refObjectGenerator")) {
            allNames <- Reduce(union, list(objects(object@generator@.xData, 
                all.names = TRUE), objects(object$def@refMethods, 
                all.names = TRUE), c("new", "help", "methods", 
                "fields", "lock", "accessors")))
        }
        else if (inherits(object, "refClass")) {
            suppressWarnings(tryCatch({
                refClassDef <- object$.refClassDef
                allNames <- c(ls(refClassDef@fieldPrototypes, 
                  all.names = TRUE), ls(refClassDef@refMethods, 
                  all.names = TRUE))
                baseMethods <- c("callSuper", "copy", "export", 
                  "field", "getClass", "getRefClass", "import", 
                  "initFields", "show", "trace", "untrace", "usingMethods")
                allNames <- c(setdiff(allNames, baseMethods), 
                  baseMethods)
            }, error = function(e) NULL))
        }
        else if (isS4(object) && length(names(object))) {
            allNames <- .rs.getNames(object)
        }
        else if (is.environment(object)) {
            allNames <- .rs.getNames(object)
        }
        else {
            if (is.atomic(object)) 
                return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
            if (!isS4(object)) {
                allNames <- .rs.getNames(object)
            }
        }
        names <- .rs.selectFuzzyMatches(allNames, token)
        types <- attr(names, "types")
        if (is.integer(types) && length(types) == length(names)) 
            type <- types
        else if (inherits(object, "data.frame")) 
            type <- .rs.acCompletionTypes$COLUMN
        else if (length(names) > 200) 
            type <- .rs.acCompletionTypes$UNKNOWN
        else {
            type <- numeric(length(names))
            for (i in seq_along(names)) {
                type[[i]] <- suppressWarnings(tryCatch(if (is.environment(object) && 
                  bindingIsActive(names[[i]], object)) 
                  .rs.acCompletionTypes$UNKNOWN
                else .rs.getCompletionType(eval(call("$", quote(object), 
                  names[[i]]))), error = function(e) .rs.acCompletionTypes$UNKNOWN))
            }
        }
    }
    .rs.makeCompletions(token = token, results = names, packages = string, 
        quote = FALSE, type = type, excludeOtherCompletions = TRUE, 
        helpHandler = helpHandler, context = if (isAt) 
            .rs.acContextTypes$AT
        else .rs.acContextTypes$DOLLAR)
}
<environment: 0x000001883f4b86b8>

$.rs.getSetRefClassSymbols
function (callString) 
{
    parsed <- .rs.rpc.get_set_ref_class_call(callString)
    unique(as.character(c(".self", parsed$field.names, parsed$method.names)))
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.stopTutorial
function (name, package) 
{
    tutorial <- .rs.tutorial.registryGet(name, package)
    .rs.api.stopJob(tutorial[["job"]])
    key <- .rs.tutorial.registryKey(name, package)
    .rs.tutorial.registry[[key]] <- NULL
}
<environment: 0x000001883f4b86b8>

$.rs.inferReticulatePython
function () 
{
    python <- Sys.getenv("RETICULATE_PYTHON", unset = NA)
    if (!is.na(python)) 
        return(python)
    loaded <- "reticulate" %in% loadedNamespaces() && reticulate::py_available(initialize = FALSE)
    if (loaded) {
        config <- reticulate::py_config()
        return(config$python)
    }
    python <- .rs.readUiPref("python_path")
    if (!is.null(python) && !identical(python, "")) 
        return(path.expand(python))
    python <- Sys.getenv("RETICULATE_PYTHON_FALLBACK", unset = NA)
    if (!is.na(python)) 
        return(python)
    if (.rs.isPackageInstalled("reticulate")) {
        prev_miniconda <- Sys.getenv("RETICULATE_MINICONDA_ENABLED")
        Sys.setenv(RETICULATE_MINICONDA_ENABLED = "FALSE")
        py_config <- NULL
        tryCatch({
            py_config <- .rs.executeFunctionInChildProcess(callback = function() reticulate::py_discover_config())
        }, finally = {
            Sys.setenv(RETICULATE_MINICONDA_ENABLED = prev_miniconda)
        })
        if (!is.null(py_config) && !is.null(py_config$python)) {
            return(py_config$python)
        }
    }
    ""
}
<environment: 0x000001883f4b86b8>

$.rs.getKnitParamsForDocument
function (documentId) 
{
    .Call("rs_getKnitParamsForDocument", documentId)
}
<environment: 0x000001883f4b86b8>

$.rs.api.getActiveProject
function () 
{
    .rs.getProjectDirectory()
}
<environment: 0x000001883fd1c808>

$.rs.getHelp
function (topic, package = "", sig = NULL, subset = TRUE, getSignature = FALSE) 
{
    if (!length(package)) 
        package <- ""
    if (!length(topic)) 
        topic <- ""
    package <- sub("package:", "", package, fixed = TRUE)
    if (package == "" && any(grepl(":{2,3}", topic, perl = TRUE))) {
        splat <- strsplit(topic, ":{2,3}", perl = TRUE)[[1]]
        topic <- splat[[2]]
        package <- splat[[1]]
    }
    helpfiles <- NULL
    if (package == "") {
        helpfiles <- utils::help(topic, help_type = "html")
    }
    else {
        helpfiles <- tryCatch(expr = {
            call <- .rs.makeHelpCall(topic, package)
            eval(call)
        }, error = function(e) {
            return(NULL)
        })
    }
    if (length(helpfiles) <= 0) 
        return()
    file <- helpfiles[[1]]
    path <- dirname(file)
    dirpath <- dirname(path)
    pkgname <- basename(dirpath)
    query <- paste("/library/", pkgname, "/html/", basename(file), 
        ".html", sep = "")
    html <- suppressWarnings(tools:::httpd(query, NULL, NULL))$payload
    if (package == "") {
        parts <- strsplit(file, "/", fixed = TRUE)[[1L]]
        index <- 0L
        for (i in rev(seq_along(parts))) {
            if (identical(parts[[i]], "help")) {
                index <- i - 1L
                break
            }
        }
        if (index > 0) 
            package <- parts[[index]]
    }
    if (package != "") {
        packagePath <- system.file(package = package)
        if (nzchar(packagePath)) {
            encoding <- .rs.packageHelpEncoding(packagePath)
            if (identical(encoding, "UTF-8")) 
                Encoding(html) <- "UTF-8"
        }
    }
    match <- suppressWarnings(regexpr("<body>.*</body>", html))
    if (match < 0) {
        html <- NULL
    }
    else {
        html <- substring(html, match + 6, match + attr(match, 
            "match.length") - 1 - 7)
        if (subset) {
            slotsMatch <- suppressWarnings(regexpr("<h3>Slots</h3>", 
                html))
            detailsMatch <- suppressWarnings(regexpr("<h3>Details</h3>", 
                html))
            match <- if (slotsMatch > detailsMatch) 
                slotsMatch
            else detailsMatch
            if (match >= 0) 
                html = substring(html, 1, match - 1)
        }
    }
    if (is.null(sig) && getSignature) {
        object <- NULL
        if (package %in% loadedNamespaces()) {
            object <- tryCatch(get(topic, envir = asNamespace(package)), 
                error = function(e) NULL)
        }
        if (!length(object)) {
            object <- tryCatch(get(topic, pos = globalenv()), 
                error = function(e) NULL)
        }
        sig <- .rs.getSignature(object)
        sig <- gsub("^function ", topic, sig)
    }
    list(html = html, signature = sig, pkgname = pkgname)
}
<bytecode: 0x0000018840e01fb0>
<environment: 0x000001883f4b86b8>

$.rs.extractRCode
function (content, reStart, reEnd) 
{
    Encoding(content) <- "UTF-8"
    splat <- strsplit(content, "\n", fixed = TRUE)[[1]]
    starts <- grep(reStart, splat, perl = TRUE)
    ends <- grep(reEnd, splat, perl = TRUE)
    pairs <- lapply(starts, function(i) {
        following <- ends[ends > i]
        if (!length(following)) 
            return(NULL)
        c(i, following[[1]])
    })
    pairs[unlist(lapply(pairs, is.null))] <- NULL
    new <- character(length(splat))
    for (pair in pairs) {
        start <- pair[[1]]
        end <- pair[[2]]
        if (grepl("eval\\s*=\\s*F", splat[[start]], perl = TRUE)) 
            next
        if (grepl("engine\\s*=", splat[[start]], perl = TRUE)) 
            next
        if (start + 1 == end) 
            next
        new[(start + 1):(end - 1)] <- splat[(start + 1):(end - 
            1)]
    }
    .rs.scalar(paste(new, collapse = "\n"))
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.cachePathFromRmdPath
function (rmdPath) 
{
    .Call("rs_chunkCacheFolder", rmdPath)
}
<environment: 0x000001883f4b86b8>

$.rs.db.listTables
function (conn, schema = NULL) 
{
    if ("odbc" %in% loadedNamespaces() && inherits(conn, "OdbcConnection")) 
        return(odbc::dbListTables(conn, schema = schema))
    objects <- DBI::dbListObjects(conn, DBI::Id(schema = schema))
    vapply(objects$table, function(object) tail(object@name, 
        n = 1), character(1))
}
<environment: 0x000001883f4b86b8>

$.rs.parseDataFile
function (path, encoding, header, sep, dec, quote, comment, nrows) 
{
    data <- tryCatch(if (identical(sep, ",") && identical(dec, 
        ".") && identical(quote, "\"")) 
        read.csv(path, encoding = encoding, header = header, 
            nrows = nrows, comment.char = comment)
    else read.table(path, encoding = encoding, header = header, 
        sep = sep, dec = dec, quote = quote, comment.char = comment, 
        nrows = nrows), error = function(e) {
        data.frame(Error = e$message)
    })
    oldWidth <- options("width")$width
    options(width = 1000)
    output <- format(data)
    options(width = oldWidth)
    return(output)
}
<environment: 0x000001883f4b86b8>

$.rs.extractElement
function (object, name, default = NULL) 
{
    if (name %in% names(object)) 
        object[[name]]
    else default
}
<environment: 0x000001883f4b86b8>

$.rs.packageHelpEncoding
function (packagePath) 
{
    if (!is.character(packagePath) || !file.exists(packagePath)) 
        return(.rs.packageHelpEncodingDefault())
    if (exists(packagePath, envir = .rs.packageHelpEncodingEnv)) 
        return(get(packagePath, envir = .rs.packageHelpEncodingEnv))
    encoding <- tryCatch(.rs.packageHelpEncodingImpl(packagePath), 
        error = function(e) .rs.packageHelpEncodingDefault())
    assign(packagePath, encoding, envir = .rs.packageHelpEncodingEnv)
    encoding
}
<environment: 0x000001883f4b86b8>

$.rs.api.getConsoleEditorContext
function () 
{
    .Call("rs_getEditorContext", 1L, NULL, PACKAGE = "(embedding)")
}
<environment: 0x000001883fd21b18>

$.rs.rpc.get_pending_actions
function (action, dir) 
{
    .rs.pendingActions(action, dir)
}
<environment: 0x000001883f4b86b8>

$.rs.getNames
function (object) 
{
    tryCatch({
        if (is.environment(object) && !inherits(object, "R6")) 
            ls(object, all.names = TRUE)
        else if (inherits(object, "tbl") && "dplyr" %in% loadedNamespaces()) 
            dplyr::tbl_vars(object)
        else if (inherits(object, "jobjRef")) 
            gsub("[\\(\\)]", "", names(object))
        else names(object)
    }, error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.generateRandomChunkId
function () 
{
    candidates <- c(letters, 0:9)
    .rs.randomString("c", candidates = candidates, n = 12L)
}
<environment: 0x000001883f4b86b8>

$.rs.removeCachedData
function (cacheKey, cacheDir) 
{
    if (Encoding(cacheDir) == "unknown") 
        Encoding(cacheDir) <- "UTF-8"
    if (exists(".rs.CachedDataEnv") && exists(cacheKey, where = .rs.CachedDataEnv, 
        inherits = FALSE)) 
        rm(list = cacheKey, envir = .rs.CachedDataEnv, inherits = FALSE)
    cacheFile <- file.path(cacheDir, paste(cacheKey, "Rdata", 
        sep = "."))
    if (file.exists(cacheFile)) 
        file.remove(cacheFile)
    .rs.removeWorkingData(cacheKey)
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.launchBrowser
function (url) 
{
    tutorial <- .rs.getVar("tutorial.pendingTutorial")
    .rs.clearVar("tutorial.pendingTutorial")
    tutorial[["shiny_url"]] <- url
    meta <- .rs.scalarListFromList(tutorial)
    .rs.invokeShinyTutorialViewer(url, meta)
}
<environment: 0x000001883f4b86b8>

$.rs.setPrintMarginColor
function (content, color) 
{
    .rs.updateSetting(content, color, "ace_print-margin", "background")
}
<environment: 0x000001883f4b86b8>

$.rs.findGlobalData
function (name) 
{
    if (exists(name, envir = globalenv())) {
        if (inherits(get(name, envir = globalenv()), "data.frame")) 
            return(name)
    }
    invisible("")
}
<environment: 0x000001883f4b86b8>

$.rs.fileInfo
function (..., extra_cols = TRUE) 
{
    suppressWarnings(file.info(..., extra_cols = extra_cols))
}
<environment: 0x000001883f4b86b8>

$.rs.docDeployList
function (target, asMultipleDoc, quartoSrcFile) 
{
    file_list <- c()
    if (asMultipleDoc) {
        targets <- list.files(path = dirname(target), pattern = glob2rx(paste("*", 
            tools::file_ext(target), sep = ".")), ignore.case = TRUE, 
            full.names = TRUE)
    }
    else {
        targets <- target
    }
    yaml <- NULL
    encoding <- getOption("encoding")
    properties <- .rs.getSourceDocumentProperties(target)
    if (!is.null(properties$encoding)) 
        encoding <- properties$encoding
    yaml <- tryCatch(rmarkdown::yaml_front_matter(target, encoding = encoding), 
        error = function(e) NULL)
    if (is.null(yaml) && !identical(encoding, "UTF-8")) {
        yaml <- tryCatch(rmarkdown::yaml_front_matter(target, 
            encoding = "UTF-8"), error = function(e) NULL)
    }
    if (is.list(yaml) && (identical(yaml$runtime, "shiny_prerendered") || 
        identical(yaml$runtime, "shinyrmd") || identical(yaml$server, 
        "shiny") || (is.list(yaml$server) && identical(yaml$server$type, 
        "shiny")))) {
        return(rsconnect::listBundleFiles(appDir = dirname(target)))
    }
    for (t in targets) {
        deploy_frame <- NULL
        tryCatch({
            deploy_frame <- rmarkdown::find_external_resources(t)
        }, error = function(e) {
        })
        if (!is.null(deploy_frame)) {
            file_list <- c(file_list, deploy_frame$path)
        }
        file_list <- c(file_list, basename(t))
    }
    if (nzchar(quartoSrcFile)) {
        project <- .rs.quartoFileProject(quartoSrcFile)
        resources <- project$resources
        project <- project$project
        file_list <- c(file_list, resources)
        if (file.exists(file.path(dirname(quartoSrcFile), "_metadata.yml"))) {
            file_list <- c(file_list, "_metadata.yml")
        }
        if (length(project)) {
            if (identical(project, "")) {
                file_list <- c(file_list, "_quarto.yml")
            }
            else {
                file_list <- c(file_list, file.path(project, 
                  "_quarto.yml"))
            }
        }
    }
    file_list <- unique(file_list)
    list(contents = file_list, totalSize = sum(file.info(file.path(dirname(target), 
        file_list))$size))
}
<environment: 0x000001883f4b86b8>

$.rs.notebookConditions.onMessage
function (condition) 
{
    full <- paste(condition$message, collapse = "\n")
    .Call("rs_signalNotebookCondition", 0L, full, PACKAGE = "(embedding)")
    invokeRestart("muffleMessage")
}
<environment: 0x000001883f4b86b8>

$.rs.downloadFileExtraWithCurlArgs
function () 
{
    newArgs <- "-L -f -g"
    curArgs <- getOption("download.file.extra")
    if (!is.null(curArgs) && !grepl(newArgs, curArgs, fixed = TRUE)) 
        curArgs <- paste(newArgs, curArgs)
    curArgs
}
<environment: 0x000001883f4b86b8>

$.rs.listIndexedFiles
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L) 
{
    .rs.doListIndex("rs_listIndexedFiles", term, inDirectory, 
        as.integer(maxCount))
}
<environment: 0x000001883f4b86b8>

$.rs.readShinytestResultRds
function (rdsPath) 
{
    failures <- Filter(function(e) !identical(e$pass, TRUE), 
        readRDS(rdsPath)$results)
    sapply(failures, function(e) e$name)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.explorer_end_inspect
function (id) 
{
    .rs.explorer.removeCacheEntry(id)
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.htmlwidget
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    outputFolder <- ctx$outputFolder
    chunkOptions <- ctx$chunkOptions
    libraryFolder <- ctx$libraryFolder
    if (!requireNamespace("htmlwidgets", quietly = TRUE)) 
        stop("print.htmlwidget called without 'htmlwidgets' available")
    htmlfile <- tempfile(pattern = "_rs_html_", tmpdir = outputFolder, 
        fileext = ".html")
    dependencies <- c(htmlwidgets:::widget_dependencies(class(x)[1], 
        attr(x, "package")), x$dependencies)
    depfile <- tempfile(pattern = "_rs_html_deps_", tmpdir = outputFolder, 
        fileext = ".json")
    cat(.rs.toJSON(dependencies, unbox = TRUE), file = depfile, 
        sep = "\n")
    x$sizingPolicy$viewer.padding <- 0
    x$sizingPolicy$viewer.fill <- TRUE
    if (!is.null(x$sizingPolicy$knitr) && identical(x$sizingPolicy$knitr$figure, 
        FALSE)) {
        x$sizingPolicy$defaultWidth <- "auto"
        x$sizingPolicy$browser$fill <- FALSE
    }
    knitrOptions <- knitr::opts_current$get()
    `%||%` <- function(x, y) if (length(x)) 
        x
    else y
    defaultDpi <- 96
    defaultFigWidth <- 7
    defaultFigHeight <- 5
    if (!is.null(chunkOptions$dpi)) {
        dpi <- chunkOptions$dpi
    }
    else if (!is.null(knitrOptions$dpi)) {
        dpi <- knitrOptions$dpi
        if (is.numeric(knitrOptions$fig.retina)) 
            dpi <- dpi/knitrOptions$fig.retina
    }
    else {
        dpi <- defaultDpi
    }
    isDefaultKnitrSizing <- identical(knitrOptions$fig.width, 
        defaultFigWidth) && identical(knitrOptions$fig.height, 
        defaultFigHeight) && identical(dpi, defaultDpi) && is.null(knitrOptions$fig.asp)
    isDefaultChunkSizing <- is.null(chunkOptions$fig.width) && 
        is.null(chunkOptions$fig.height) && is.null(chunkOptions$fig.asp)
    if (isDefaultKnitrSizing && isDefaultChunkSizing) {
        knitrOptions$out.width.px <- .rs.firstOf(knitrOptions$out.width.px, 
            defaultFigWidth * defaultDpi)
        knitrOptions$out.height.px <- .rs.firstOf(knitrOptions$out.height.px, 
            defaultFigHeight * defaultDpi)
    }
    else {
        figWidth <- .rs.firstOf(chunkOptions$fig.width, knitrOptions$fig.width) * 
            dpi
        figHeight <- .rs.firstOf(chunkOptions$fig.height, knitrOptions$fig.height) * 
            dpi
        figAsp <- .rs.firstOf(chunkOptions$fig.asp, knitrOptions$fig.asp, 
            1)
        knitrOptions$out.width.px <- figWidth
        knitrOptions$out.height.px <- figHeight %||% figWidth * 
            figAsp
    }
    knitrOptions$out.width.px <- floor(knitrOptions$out.width.px %||% 
        500)
    knitrOptions$out.height.px <- floor(knitrOptions$out.height.px %||% 
        500)
    html <- htmlwidgets:::toHTML(x, standalone = TRUE, knitrOptions = knitrOptions)
    if (length(html) != 3) 
        stop("unexpected htmlwidget structure: expected taglist of length 3")
    if (html[[1]]$attribs$id != "htmlwidget_container") 
        stop("expected a container div with id 'htmlwidget_container'")
    if (length(html[[1]]$children) == 0) 
        stop("expected one or more children for htmlwidget container div")
    embedded <- htmlwidgets:::toHTML(x, standalone = FALSE, knitrOptions = knitrOptions)
    .rs.tryCatch(html[[1]]$children[[1]][[2]]$attribs$style <- embedded[[1]][[2]]$attribs$style)
    div <- html[[1]]$children[[1]]
    json <- html[[2]]
    policy <- html[[3]]
    fmt <- "<!-- htmlwidget-sizing-policy-base64 %s -->"
    encodedPolicy <- .rs.base64encode(paste(as.character(policy), 
        collapse = "\n"))
    htmlPolicy <- htmltools::HTML(sprintf(fmt, encodedPolicy))
    htmlProduct <- htmltools::tagList(htmltools::HTML("<!-- htmlwidget-container-begin -->"), 
        div, htmltools::HTML("<!-- htmlwidget-container-end -->"), 
        json, htmlPolicy)
    attributes(htmlProduct) <- attributes(html)
    htmltools::save_html(htmlProduct, file = htmlfile, libdir = libraryFolder)
    .rs.recordHtmlWidget(x, htmlfile, depfile)
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.enqueueClientEvent
function (type, data = list()) 
{
    eventData <- list(type = .rs.scalar(type), data = data)
    .rs.enqueClientEvent("tutorial_command", eventData)
}
<environment: 0x000001883f4b86b8>

$.rs.reRmdChunkBegin
function () 
{
    "^[\t >]*```+\\s*\\{[.]?([a-zA-Z]+.*)\\}\\s*$"
}
<environment: 0x000001883f4b86b8>

$.rs.multiCols
function (x) 
{
    fun <- function(col) is.data.frame(col) || is.matrix(col)
    which(vapply(x, fun, TRUE))
}
<environment: 0x000001883f4b86b8>

$.rs.api.selectionSet
function (value = NULL, id = NULL) 
{
    value <- paste(value, collapse = "\n")
    payload <- list(value = .rs.scalar(value), doc_id = .rs.scalar(id))
    request <- .rs.api.createRequest(type = .rs.api.eventTypes$TYPE_SET_EDITOR_SELECTION, 
        sync = TRUE, target = .rs.api.eventTargets$TYPE_ACTIVE_WINDOW, 
        payload = payload)
    .rs.api.sendRequest(request)
}
<environment: 0x000001883fe64bf0>

$.rs.python.execute
function (python, code) 
{
    python <- normalizePath(python, winslash = "/", mustWork = TRUE)
    args <- c("-E", "-c", shQuote(code))
    result <- suppressWarnings(system2(python, args, stdout = TRUE, 
        stderr = TRUE))
    status <- .rs.nullCoalesce(attr(result, "status", exact = TRUE), 
        0L)
    if (!identical(status, 0L)) 
        .rs.stopf("error retrieving Python version [error code %i]", 
            status)
    paste(result, collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.createContext
function (name = NULL, access = NULL, tags = character(), recursive = FALSE, 
    start = 1, end = .rs.explorer.defaultRowLimit) 
{
    list(name = name, access = access, tags = tags, recursive = recursive, 
        start = start, end = end)
}
<environment: 0x000001883f4b86b8>

$.rs.quietPackratStatus
function (dir) 
{
    tryCatch({
        suppressWarnings(packrat::status(dir, quiet = TRUE))
    }, error = function(e) {
        NULL
    })
}
<environment: 0x000001883f4b86b8>

$.rs.readSourceDocument
function (id) 
{
    contents <- .Call("rs_readSourceDocument", as.character(id), 
        PACKAGE = "(embedding)")
    if (is.character(contents)) 
        Encoding(contents) <- "UTF-8"
    contents
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleDownload
function (url, placeholder, bundleTemp) 
{
    bundleName <- .rs.odbcBundleName(placeholder)
    bundleUrl <- file.path(url, bundleName)
    if (exists(bundleTemp)) 
        unlink(bundleTemp, recursive = TRUE)
    dir.create(bundleTemp, recursive = TRUE)
    bundleFileTemp <- file.path(bundleTemp, bundleName)
    download.file(bundleUrl, bundleFileTemp)
    bundleFileTemp
}
<environment: 0x000001883f4b86b8>

$.rs.registerNotebookErrHandler
function () 
{
    options(error = .rs.handleNotebookError)
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.onSuspend
function (path) 
{
}
<environment: 0x000001883f4b86b8>

$.rs.safeAsEnvironment
function (envName) 
{
    env <- NULL
    tryCatch({
        env <- as.environment(envName)
    }, error = function(e) {
    })
    env
}
<environment: 0x000001883f4b86b8>

$.rs.python.token
function (value, type, offset) 
{
    list(value = value, type = type, offset = offset)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsNamespace
function (token, string, exportsOnly, envir) 
{
    result <- .rs.emptyCompletions(excludeOtherCompletions = TRUE)
    if (!(string %in% loadedNamespaces())) {
        tryCatch(suppressPackageStartupMessages(requireNamespace(string, 
            quietly = TRUE)), error = function(e) NULL)
    }
    if (string %in% loadedNamespaces()) {
        namespace <- asNamespace(string)
        objectNames <- if (exportsOnly) 
            getNamespaceExports(namespace)
        else {
            arguments <- list()
            arguments[["name"]] <- namespace
            arguments[["all.names"]] <- TRUE
            if ("sorted" %in% names(formals(objects))) 
                arguments[["sorted"]] <- FALSE
            do.call(objects, arguments)
        }
        lazydata <- new.env(parent = emptyenv())
        dataNames <- character()
        if (exportsOnly && exists(".__NAMESPACE__.", envir = namespace)) {
            .__NAMESPACE__. <- get(".__NAMESPACE__.", envir = namespace)
            if (exists("lazydata", envir = .__NAMESPACE__.)) {
                lazydata <- get("lazydata", envir = .__NAMESPACE__.)
                dataNames <- objects(lazydata, all.names = TRUE)
            }
        }
        objectNames <- .rs.selectFuzzyMatches(objectNames, token)
        dataNames <- .rs.selectFuzzyMatches(dataNames, token)
        objectTypes <- vapply(mget(objectNames, envir = namespace, 
            inherits = TRUE), FUN.VALUE = numeric(1), USE.NAMES = FALSE, 
            .rs.getCompletionType)
        dataTypes <- rep(.rs.acCompletionTypes$DATAFRAME, length(dataNames))
        df <- data.frame(names = c(objectNames, dataNames), types = c(objectTypes, 
            dataTypes), stringsAsFactors = FALSE)
        df <- df[order(df$names), ]
        completions <- df$names
        type <- df$types
        result <- .rs.makeCompletions(token = token, results = completions, 
            packages = string, quote = FALSE, type = type, excludeOtherCompletions = TRUE, 
            context = if (exportsOnly) 
                .rs.acContextTypes$NAMESPACE_EXPORTED
            else .rs.acContextTypes$NAMESPACE_ALL)
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.viewHook
function (object, name) 
{
    reticulate:::disable_conversion_scope(object)
    if (inherits(object, "pandas.core.frame.DataFrame")) {
        object <- reticulate::py_to_r(object)
        assign(name, object, envir = environment())
        eval(call("View", as.name(name)), envir = environment())
    }
    else {
        envir <- new.env(parent = emptyenv())
        assign(name, object, envir = envir)
        .rs.explorer.viewObject(object = object, title = name, 
            envir = envir)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.isPythonObjectExpandable
function (object) 
{
    ignored <- c("python.builtin.bool", "python.builtin.int", 
        "python.builtin.float", "python.builtin.str", "python.builtin.bytes", 
        "python.builtin.method", "python.builtin.function", "python.builtin.builtin_function_or_method", 
        "python.builtin.NoneType")
    if (inherits(object, ignored)) 
        return(FALSE)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.api.askForPassword
function (prompt) 
{
    .rs.askForPassword(prompt)
}
<environment: 0x000001883fd2b698>

$.rs.notebookConditions.connectImpl
function () 
{
    .rs.notebookConditions.handlerStack <- .Internal(.addCondHands(c("warning", 
        "message"), list(warning = .rs.notebookConditions.onWarning, 
        message = .rs.notebookConditions.onMessage), base::globalenv(), 
        NULL, TRUE))
    base::assign(x = ".rs.notebookConditions.handlerStack", value = .rs.notebookConditions.handlerStack, 
        envir = .rs.toolsEnv())
    base::rm(.rs.notebookConditions.handlerStack)
}
<environment: 0x000001883f4b86b8>

$.rs.getSourceDocumentProperties
function (path, includeContents = FALSE) 
{
    if (is.null(path) || !file.exists(path)) 
        return(NULL)
    path <- normalizePath(path, winslash = "/", mustWork = TRUE)
    .Call("rs_getDocumentProperties", path, includeContents)
}
<environment: 0x000001883f4b86b8>

$.rs.onAvailablePackagesReady
function (reposString) 
{
    dir <- .rs.availablePackagesPendingEnv[[reposString]]
    rds <- file.path(dir, "packages.rds")
    packages <- .rs.tryCatch(readRDS(rds))
    if (!inherits(packages, "error")) 
        .rs.availablePackagesEnv[[reposString]] <- packages
    unlink(dir, recursive = TRUE)
    .rs.availablePackagesPendingEnv[[reposString]] <- NULL
    packages
}
<environment: 0x000001883f4b86b8>

$.rs.showHelpTopic
function (topic, package) 
{
    call <- .rs.makeHelpCall(topic, package)
    print(eval(call, envir = parent.frame()))
}
<environment: 0x000001883f4b86b8>

$.rs.utf8ToSystem
function (text) 
{
    .Call("rs_utf8ToSystem", as.character(text), PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.stan_run_diagnostics
function (file, useSourceDatabase) 
{
    .rs.stan.runDiagnostics(file, useSourceDatabase)
}
<environment: 0x000001883f4b86b8>

$.rs.getR6ClassGeneratorMethod
function (object, method) 
{
    if (is.function(object)) 
        object <- environment(object)
    if (!is.environment(object)) 
        return(NULL)
    if (!inherits(object, "R6ClassGenerator")) 
        return(NULL)
    tryCatch(object$public_methods[[method]], error = function(e) NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.themes_rainbow_indent_guides
function (colors = c("#ed90a4", "#d3a263", "#99b657", "#33c192", 
    "#00bdce", "#94a9eb", "#dc91db")) 
{
    n <- length(colors)
    content <- "/* Rainbow indent lines */"
    for (i in seq_len(n)) {
        content <- c(content, paste0(".rstudio_rainbow_indent_guides .ace_line .ace_indent-guide:nth-child(", 
            n, "n+", i, "){"), paste0("    background: linear-gradient(to left, ", 
            colors[i], "bb 1px, transparent 1px, transparent);"), 
            "}")
    }
    content <- c(content, "/* Rainbow indent fills */")
    for (i in seq_len(n)) {
        content <- c(content, paste0(".rstudio_rainbow_indent_fills .ace_line .ace_indent-guide:nth-child(", 
            n, "n+", i, "){"), paste0("    background: linear-gradient(to left, ", 
            colors[i], "bb 1px, ", colors[i], "77 1px, ", colors[i], 
            "77 );"), "}")
    }
    content
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsShinySession
function (token) 
{
    if (!is.null(results <- .rs.get("shinySessionCompletions"))) 
        return(results)
    if (!("shiny" %in% loadedNamespaces())) 
        return(NULL)
    completionGetter <- tryCatch(eval(call(":::", "shiny", "session_completions")), 
        error = function(e) NULL)
    if (is.null(completionGetter)) 
        return(NULL)
    completions <- tryCatch(completionGetter(), error = function(e) NULL)
    if (is.null(completions)) 
        return(NULL)
    if (!is.character(completions)) 
        return(NULL)
    results <- .rs.selectFuzzyMatches(completions, token)
    output <- .rs.makeCompletions(token = token, results = results, 
        type = .rs.acCompletionTypes$CONTEXT, excludeOtherCompletions = TRUE)
    .rs.assign("shinySessionCompletions", output)
    output
}
<environment: 0x000001883f4b86b8>

$.rs.nse.primitives
 [1] "quote"               "substitute"          "match.call"          "eval.parent"         "enquote"             "bquote"             
 [7] "evalq"               "lazy_dots"           "compat_as_lazy_dots" "select_vars"         "quo"                 "quos"               
[13] "enquo"               "named_quos"         
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.connectionInstallerInfo
function (name) 
{
    installerName <- paste(name, "dcf", sep = ".")
    installerFile <- as.character(.rs.connectionFiles(installerName, 
        .rs.connectionOdbcInstallerPath()))
    fileContents <- read.dcf(installerFile)
    list(name = if ("Name" %in% colnames(fileContents)) fileContents[, 
        "Name"][[1]] else NULL, version = if ("Version" %in% 
        colnames(fileContents)) fileContents[, "Version"][[1]] else NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.connectionError
function (error) 
{
    .rs.setVar("connectionObserver.lastTraceback", sys.calls())
    suppressed <- getOption("rstudio.connectionObserver.errorsSuppressed", 
        default = FALSE)
    if (suppressed) 
        return()
    package <- NULL
    frames <- sys.frames()
    for (frame in rev(frames)) {
        parent <- parent.env(frame)
        if (identical(parent, baseenv()) || identical(parent, 
            .BaseNamespaceEnv)) 
            next
        if (isNamespace(parent)) {
            spec <- getNamespaceInfo(parent, "spec")
            package <- spec[["name"]]
            break
        }
    }
    header <- if (is.null(package)) {
        "An error occurred while updating the RStudio Connections pane:"
    }
    else {
        fmt <- "An error occurred while the '%s' package was updating the RStudio Connections pane:"
        sprintf(fmt, package)
    }
    fmt <- "Error in %s: %s"
    body <- sprintf(fmt, format(error$call), format(error$message))
    footer <- "If necessary, these warnings can be squelched by setting `options(rstudio.connectionObserver.errorsSuppressed = TRUE)`."
    all <- paste(c(header, body, footer), collapse = "\n")
    message(all)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.forget_rsconnect_deployments
function (sourcePath, outputPath) 
{
    ext <- tolower(tools::file_ext(sourcePath))
    if (identical(ext, "r")) 
        sourcePath <- dirname(sourcePath)
    rsconnect::forgetDeployment(appPath = sourcePath, force = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.doShinyUICompletions
function (object, inputs, outputs, inputCount, outputCount, shinyFunctions) 
{
    if (is.call(object) && length(object) > 1) {
        functionName <- .rs.extractFunctionNameFromCall(object)
        firstArgName <- if (is.character(object[[2]]) && length(object[[2]]) == 
            1) 
            object[[2]]
        else ""
        if (nzchar(firstArgName)) {
            functionArgs <- shinyFunctions[[functionName]]
            if ("outputId" %in% functionArgs || .rs.endsWith(functionName, 
                "Output")) {
                outputCount$count <- outputCount$count + 1
                outputs[[as.character(outputCount$count)]] <- firstArgName
            }
            else if ("inputId" %in% functionArgs || .rs.endsWith(functionName, 
                "Input")) {
                inputCount$count <- inputCount$count + 1
                inputs[[as.character(inputCount$count)]] <- firstArgName
            }
        }
        for (j in 2:length(object)) {
            if (is.call(object[[j]])) {
                .rs.doShinyUICompletions(object[[j]], inputs, 
                  outputs, inputCount, outputCount, shinyFunctions)
            }
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.python.moduleCache
<environment: 0x000001883d1fa968>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.explorer.inspectPythonObject
function (object, context = .rs.explorer.createContext()) 
{
    attributes <- .rs.reticulate.listAttributes(object = object, 
        includeDunderMethods = .rs.explorer.tags$ATTRIBUTES %in% 
            context$tags)
    lapply(attributes, function(attribute) {
        item <- reticulate::py_get_attr(object, attribute, silent = TRUE)
        if (is.null(item)) 
            next
        if (.rs.reticulate.replIsActive()) {
            name <- as.character(attribute)
            access <- paste("#", name, sep = ".")
            tags <- character()
        }
        else {
            name <- as.character(attribute)
            access <- paste("#", deparse(as.name(name), backtick = TRUE), 
                sep = "$")
            tags <- character()
        }
        childContext <- .rs.explorer.createChildContext(context, 
            name, access, tags)
        .rs.explorer.inspectObject(item, childContext)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.environmentName
function (env) 
{
    if (identical(env, globalenv())) 
        return(".GlobalEnv")
    if (identical(env, baseenv())) 
        return("package:base")
    result <- environmentName(env)
    if (nchar(result) == 0) 
        .rs.environmentCallFrameName(env)$name
    else {
        if ((result %in% loadedNamespaces()) && identical(asNamespace(result), 
            env)) 
            paste("namespace:", result, sep = "")
        else result
    }
}
<environment: 0x000001883f4b86b8>

$.rs.clearVar
function (name) 
{
    envir <- .rs.toolsEnv()
    fullName <- paste(".rs.", name, sep = "")
    remove(list = fullName, pos = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.checkBuildTools
function (action) 
{
    if (identical(.Platform$pkgType, "mac.binary.mavericks")) 
        return(.Call("rs_canBuildCpp", PACKAGE = "(embedding)"))
    ok <- .Call("rs_canBuildCpp", PACKAGE = "(embedding)")
    if (ok) 
        return(TRUE)
    .rs.installBuildTools(action)
    FALSE
}
<environment: 0x000001883f4b86b8>

$.rs.insecureReposWarning
function (msg) 
{
    if (.rs.showSecureDownloadWarning()) {
        message("WARNING: ", msg, " You should either switch to a repository ", 
            "that supports HTTPS or change your RStudio options to not require HTTPS ", 
            "downloads.\n\nTo learn more and/or disable this warning ", 
            "message see the \"Use secure download method for HTTP\" option ", 
            "in Tools -> Global Options -> Packages.")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.registerUnsupported
function (name, package, alternative = "") 
{
    unsupported <- function(...) {
        msg <- "function not supported in RStudio"
        if (nzchar(alternative)) 
            msg <- paste(msg, "(try", alternative, "instead)")
        msg <- paste(msg, "\n", sep = "")
        stop(msg)
    }
    .rs.registerReplaceHook(name, package, unsupported)
}
<environment: 0x000001883f4b86b8>

$.rs.registerReplaceHook
function (name, package, hook, namespace = FALSE) 
{
    hookFactory <- function(original) function(...) .rs.callAs(name, 
        hook, original, ...)
    .rs.registerHook(name, package, hookFactory, namespace)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_custom_help
function (helpHandler, topic, source, language) 
{
    if (identical(language, "Python")) 
        return(.rs.python.getHelp(topic, source))
    helpHandlerFunc <- tryCatch(eval(parse(text = helpHandler)), 
        error = function(e) NULL)
    if (!is.function(helpHandlerFunc)) 
        return()
    results <- helpHandlerFunc("completion", topic, source)
    if (!is.null(results)) {
        results$description <- .rs.markdownToHTML(results$description)
    }
    results
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCondaEnvironmentInfo
function (pythonPath) 
{
    .rs.python.interpreterInfo(path = pythonPath, type = "conda")
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.fireEvent
function (type, data = list()) 
{
    .rs.enqueClientEvent("object_explorer_event", list(type = .rs.scalar(type), 
        data = data))
}
<environment: 0x000001883f4b86b8>

$.rs.recordUserTraceback
function () 
{
    .rs.recordTraceback(TRUE, 5, .rs.enqueueError)
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE
attr(,"errorHandlerType")
[1] "traceback"

$.rs.api.savePlotAsImage
function (file, format = c("png", "jpeg", "bmp", "tiff", "emf", 
    "svg", "eps"), width, height) 
{
    file <- path.expand(file)
    format <- match.arg(format)
    if (!is.numeric(width)) 
        stop("width argument mut be numeric", call. = FALSE)
    if (!is.numeric(height)) 
        stop("height argument mut be numeric", call. = FALSE)
    invisible(.Call("rs_savePlotAsImage", file, format, width, 
        height, PACKAGE = "(embedding)"))
}
<environment: 0x000001883fcfc238>

$.rs.hasSecret
function (name) 
{
    if (!.rs.isPackageInstalled("keyring")) {
        FALSE
    }
    else {
        keyring_list <- get("key_list", envir = asNamespace("keyring"))
        keys <- keyring_list(.rs.getSecretService())
        name %in% keys$username
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getDataTableColumnsCompletions
function (token, name, object) 
{
    .rs.makeCompletions(token = token, results = .rs.selectFuzzyMatches(names(object), 
        token), packages = name, quote = FALSE, type = .rs.acCompletionTypes$COLUMN, 
        fguess = "[.data.table")
}
<environment: 0x000001883f4b86b8>

$.rs.validateParams
function (obj, params, type, optional = FALSE) 
{
    for (param in params) {
        value <- obj[[param]]
        if (optional && is.null(value)) 
            next
        if (!inherits(value, type) || length(value) != 1) 
            stop(param, " must be a single element of type '", 
                type, "'", call. = FALSE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.stepsAtLine
function (funBody, line) 
{
    if (typeof(funBody) != "language") {
        return(NULL)
    }
    refs <- attr(funBody, "srcref")
    for (idx in 1:length(funBody)) {
        ref <- refs[[idx]]
        if (length(ref) > 0) {
            if (line > ref[3] || line < ref[1]) {
                next
            }
        }
        nestedFunSteps <- .rs.stepsAtLine(funBody[[idx]], line)
        if (!is.null(nestedFunSteps)) {
            return(c(idx, nestedFunSteps))
        }
        if (length(ref) > 0 && !(typeof(funBody[[idx]]) == "symbol" && 
            identical(as.character(funBody[[idx]]), "{"))) {
            return(idx)
        }
    }
    return(NULL)
}
<bytecode: 0x000001883c365938>
<environment: 0x000001883f4b86b8>

$.rs.quarto.renderPreview
function (port, token, path, format) 
{
    .rs.tryCatch(utils::download.file(paste0("http://localhost:", 
        port, "/", token, "/?path=", utils::URLencode(path, TRUE), 
        ifelse(nzchar(format), paste0("&format=", format), "")), 
        destfile = tempfile(), quiet = TRUE, cacheOK = FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.getHelpColumn
function (name, src, envir = parent.frame()) 
{
    data <- .rs.getAnywhere(src, envir)
    if (!is.null(data)) {
        column <- data[[name]]
        if (isNamespaceLoaded("pillar")) {
            formatted <- pillar::format_glimpse(column)
            bits <- c()
            nchars <- 55
            i <- 1
            while (nchars > 1 && i < length(column)) {
                current <- formatted[i]
                if (nchar(current) > nchars) {
                  current <- pillar:::str_trunc(current, nchars)
                }
                bits <- c(bits, current)
                nchars <- nchars - nchar(current) - 2
                i <- i + 1
            }
            if (length(bits) < length(column)) {
                bits <- c(bits, paste0("<i>", pillar:::get_ellipsis(), 
                  "</i>"))
            }
            description <- paste("<ul>", paste(paste0("<li>", 
                bits, "</li>"), collapse = " "), "</ul>")
            type <- pillar:::get_pillar_type(column)
            size <- length(formatted)
        }
        else {
            described <- .rs.describeObject(data, name)
            description <- described$description
            type <- described$type
            size <- described$length
        }
        list(html = paste0("<h2></h2><h3>Description</h3><p>", 
            description, "</p>"), signature = paste0("<", type, 
            "> [", size, "]"), pkgname = src, help = FALSE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleRegisterOSX
function (name, driverPath, version, installPath) 
{
    .rs.odbcBundleRegisterLinux(name, driverPath, version, installPath)
    driverIniFile <- .rs.odbcBundleDriverIniPath(name, installPath)
    if (length(driverIniFile) == 0) {
        warning("Could not find '", name, "' driver INI file under: ", 
            installPath)
    }
    else {
        driverIni <- .rs.odbcBundleReadIni(driverIniFile)
        odbcinstLib <- .rs.odbcOdbcInstLibPath()
        if (!is.null(odbcinstLib)) {
            driverIni[["Driver"]] <- c(driverIni[["Driver"]], 
                paste("ODBCInstLib", "=", odbcinstLib))
        }
        .rs.odbcBundleWriteIni(driverIniFile, driverIni)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.create_line_marker_rule
function (markerName, markerColor) 
{
    sprintf(paste(sep = "\n", ".ace_marker-layer %s {", "  position: absolute;", 
        "  z-index: -1;", "  background-color: %s;", "}"), markerName, 
        markerColor)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcOdbcInstLibPath
function () 
{
    odbcinstLib <- NULL
    odbcinstBin <- Sys.which("odbcinst")
    if (nchar(odbcinstBin) == 0) {
        warning("Could not find path to odbcinst.")
    }
    else {
        odbcinstLink <- Sys.readlink(odbcinstBin)
        if (!is.na(odbcinstLink)) {
            odbcinstBinPath <- normalizePath(file.path(dirname(odbcinstBin), 
                dirname(odbcinstLink)))
            odbcinstLibPath <- normalizePath(file.path(odbcinstBinPath, 
                "..", "lib"))
            odbcinstLib <- dir(odbcinstLibPath, pattern = "libodbcinst.*\\.dylib", 
                full.names = TRUE)[[1]]
        }
    }
    odbcinstLib
}
<environment: 0x000001883f4b86b8>

$.rs.doStripSurrounding
function (string, complements) 
{
    result <- gsub("^\\s*([`'\"])(.*?)\\1.*", "\\2", string, 
        perl = TRUE)
    for (item in complements) {
        result <- sub(paste("^\\", item[[1]], "(.*)\\", item[[2]], 
            "$", sep = ""), "\\1", result, perl = TRUE)
    }
    result
}
<bytecode: 0x00000188411a1c18>
<environment: 0x000001883f4b86b8>

$.rs.getHTMLCapabilities
function (markdownVersion, stitchVersion) 
{
    caps <- list()
    caps$r_markdown_supported = .rs.scalar(FALSE)
    caps$stitch_supported = .rs.scalar(FALSE)
    if (.rs.isPackageInstalled("knitr")) {
        knitrVersion <- .rs.getPackageVersion("knitr")
        caps$r_markdown_supported = .rs.scalar(knitrVersion >= 
            markdownVersion)
        caps$stitch_supported = .rs.scalar(knitrVersion >= stitchVersion)
    }
    return(caps)
}
<environment: 0x000001883f4b86b8>

$.rs.nBytes
function (x) 
{
    nchar(x, type = "bytes")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.markdown_get_completions
function (type, data) 
{
    if (type == .rs.markdown.acCompletionTypes$COMPLETION_HREF) 
        return(.rs.markdown.getCompletionsHref(data))
}
<environment: 0x000001883f4b86b8>

$.rs.api.setJobProgress
function (job, units) 
{
    if (missing(job)) 
        stop("Must specify job ID to set progress for.")
    if (missing(units)) 
        stop("Must specify number of progress units to set.")
    .Call("rs_setJobProgress", job, units, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f04f938>

$.rs.initTools
function () 
{
    ostype <- .Platform$OS.type
    info <- Sys.info()
    envir <- .rs.toolsEnv()
    assign(".rs.platform.isUnix", ostype == "unix", envir = envir)
    assign(".rs.platform.isWindows", ostype == "windows", envir = envir)
    assign(".rs.platform.isLinux", info[["sysname"]] == "Linux", 
        envir = envir)
    assign(".rs.platform.isMacos", info[["sysname"]] == "Darwin", 
        envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.iconvlist
function () 
{
    list(common = sort(intersect(.rs.iconvcommon(), toupper(iconvlist()))), 
        all = sort(iconvlist()))
}
<environment: 0x000001883f4b86b8>

$.rs.callSafely
function (call, args) 
{
    call <- match.fun(call)
    args <- args[intersect(names(formals(call)), names(args))]
    envir <- parent.frame()
    do.call(call, args, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.api.readPreference
function (name, default = NULL) 
{
    value <- .rs.readApiPref(name)
    if (is.null(value)) 
        default
    else value
}
<environment: 0x000001883fd5ae80>

$.rs.askForPassword
function (prompt) 
{
    .Call("rs_askForPassword", prompt)
}
<environment: 0x000001883f4b86b8>

$.rs.addGlobalVariable
function (name, var) 
{
    envir <- .rs.toolsEnv()
    environment(var) <- envir
    assign(name, var, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.initGraphicsDevice
function () 
{
    options(device = "RStudioGD")
    grDevices::deviceIsInteractive("RStudioGD")
}
<environment: 0x000001883f4b86b8>

$.rs.api.setJobState
function (job, state = c("idle", "running", "succeeded", "cancelled", 
    "failed")) 
{
    if (missing(job)) 
        stop("Must specify job ID to change state for.")
    state <- match.arg(state)
    .Call("rs_setJobState", job, state, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f05dd98>

$.rs.releaseHtmlCapture
function () 
{
    hooks <- .rs.rnb.htmlCaptureHooks()
    for (name in names(hooks)) {
        .rs.removeS3Override(name)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.defaultChunkOptions
function () 
{
    defaultOptions <- knitr::opts_chunk$get()
    if (identical(defaultOptions$error, .rs.scalar(FALSE))) 
        defaultOptions$error <- NULL
    chunkOptions <- get(".rs.knitr.chunkOptions", envir = .rs.toolsEnv())
    knitr::opts_chunk$restore(chunkOptions)
    knitrCode <- get(".rs.knitr.code", envir = .rs.toolsEnv())
    knitr:::knit_code$restore(knitrCode)
    knitrDir <- get(".rs.knitr.root.dir", envir = .rs.toolsEnv())
    knitr::opts_knit$set(root.dir = knitrDir)
    knitr::opts_chunk$set(defaultOptions)
    .rs.scalarListFromList(defaultOptions)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.listAttributes
function (object, includeDunderMethods = TRUE) 
{
    attributes <- reticulate::py_list_attributes(object)
    if (!includeDunderMethods) 
        attributes <- grep("^__", attributes, value = TRUE, invert = TRUE)
    indices <- order(.rs.startsWith(attributes, "__"), .rs.startsWith(attributes, 
        "_"))
    attributes[indices]
}
<environment: 0x000001883f4b86b8>

$.rs.api.insertText
function (location, text, id = "") 
{
    invalidTextMsg <- "'text' should be a character vector"
    invalidLengthMsg <- "'text' should either be length 1, or same length as 'ranges'"
    if (is.null(id)) 
        id <- ""
    if (!is.character(id)) 
        stop("'id' must be NULL or a character vector of length one")
    if (missing(location)) 
        location <- NULL
    if (missing(text)) 
        text <- NULL
    if (is.null(text) && is.character(location)) {
        return(.rs.api.selectionSet(value = location, id = id))
    }
    else if (is.null(location) && is.character(text)) {
        return(.rs.api.selectionSet(value = text, id = id))
    }
    else if (length(location) == 0) {
        return()
    }
    ranges <- .rs.validateAndTransformLocation(location)
    if (!is.character(text)) 
        stop(invalidTextMsg, call. = FALSE)
    if (length(text) != 1 && length(ranges) != length(text)) 
        stop(invalidLengthMsg, call. = FALSE)
    if (length(ranges)) {
        idx <- order(unlist(lapply(ranges, `[[`, 1)))
        ranges <- ranges[idx]
        if (length(text) != 1) 
            text <- text[idx]
    }
    data <- list(ranges = ranges, text = text, id = .rs.scalar(id))
    .rs.enqueEditorClientEvent("replace_ranges", data)
    invisible(data)
}
<environment: 0x000001883fd0bf38>

$.rs.selectStartsWith
function (strings, string) 
{
    strings[.rs.startsWith(strings, string)]
}
<environment: 0x000001883f4b86b8>

$.rs.getFunctionSourceRefs
function (functionName, fileName, packageName) 
{
    functionName <- .rs.unquote(functionName)
    fun <- .rs.getUntracedFunction(functionName, fileName, packageName)
    if (is.null(fun)) {
        return(NULL)
    }
    attr(fun, "srcref")
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.registryCreate
function (name, package) 
{
    tutorial <- as.environment(list(name = name, package = package))
    key <- .rs.tutorial.registryKey(name, package)
    .rs.tutorial.registry[[key]] <- tutorial
    tutorial
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.is_package_installed
function (package, version) 
{
    installed <- if (is.null(version)) 
        .rs.isPackageInstalled(package)
    else .rs.isPackageVersionInstalled(package, version)
    .rs.scalar(installed)
}
<environment: 0x000001883f4b86b8>

$.rs.api.documentOpen
function (path, line = -1L, col = -1L, moveCursor = TRUE) 
{
    hasFile <- !is.null(path) && length(path) > 0
    if (hasFile && !is.character(path)) {
        stop("path must be a character")
    }
    if (length(path) > 1L) {
        stop("path must be a single file")
    }
    if (hasFile && !file.exists(path)) {
        stop(path, " does not exist.")
    }
    if (hasFile) {
        path <- .rs.normalizePath(path, winslash = "/", mustWork = TRUE)
        path <- .rs.createAliasedPath(path)
    }
    if (is.double(line)) 
        line <- as.integer(line)
    if (is.double(col)) 
        col <- as.integer(col)
    if (!is.integer(line) || length(line) != 1 || !is.integer(col) || 
        length(col) != 1) {
        stop("line and column must be numeric values.")
    }
    payload <- list(path = .rs.scalar(path), row = .rs.scalar(line), 
        column = .rs.scalar(col), moveCursor = .rs.scalar(isTRUE(moveCursor)))
    request <- .rs.api.createRequest(type = .rs.api.eventTypes$TYPE_DOCUMENT_OPEN, 
        sync = TRUE, target = .rs.api.eventTargets$TYPE_ACTIVE_WINDOW, 
        payload = payload)
    response <- .rs.api.sendRequest(request)
    response$id
}
<environment: 0x000001883fd8b980>

$.rs.python.inferObjectTypes
function (object, names) 
{
    vapply(names, function(name) {
        item <- .rs.tryCatch(reticulate::py_get_attr(object, 
            name))
        if (inherits(item, "error")) 
            return(.rs.acCompletionTypes$UNKNOWN)
        if (inherits(item, "python.builtin.module")) 
            .rs.acCompletionTypes$ENVIRONMENT
        else if (.rs.reticulate.isFunction(item)) 
            .rs.acCompletionTypes$FUNCTION
        else if (inherits(item, "pandas.core.frame.DataFrame")) 
            .rs.acCompletionTypes$DATAFRAME
        else .rs.acCompletionTypes$UNKNOWN
    }, numeric(1))
}
<environment: 0x000001883f4b86b8>

$.rs.isPackified
function (project) 
{
    lockPath <- file.path(project, "packrat/packrat.lock")
    if (!file.exists(lockPath)) 
        return(FALSE)
    packrat:::checkPackified(project = project, quiet = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.embeddedViewer
function (url) 
{
    .Call("rs_embeddedViewer", url)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.replace_comment_header
function (command, path, code) 
{
    .rs.scalar(paste(deparse(do.call("substitute", args = list(eval(parse(text = paste("quote(", 
        command, ")", sep = ""))), list(.code = code, .file = path)))), 
        collapse = ""))
}
<environment: 0x000001883f4b86b8>

$.rs.internal.removeTheme
function (name, themeList) 
{
    Encoding(name) <- "UTF-8"
    warnings <- c()
    tryCatch(withCallingHandlers(.rs.removeTheme(name, themeList), 
        warning = function(w) {
            warnings <<- c(warnings, conditionMessage(w))
            invokeRestart("muffleWarning")
        }), error = function(e) {
        if (length(warnings) > 0) 
            e$message <- paste(e$message, paste0(warnings, collapse = "\n    "), 
                sep = "\nAlso, warnings:\n    ")
        e
    })
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.explorerCache
function () 
{
    key <- "reticulate.explorerCacheDictionary"
    if (!.rs.hasVar(key)) 
        .rs.setVar(key, reticulate::dict())
    .rs.getVar(key)
}
<environment: 0x000001883f4b86b8>

$.rs.isPackageInstalled
function (name, libLoc = NULL) 
{
    paths <- vapply(name, FUN.VALUE = character(1), USE.NAMES = FALSE, 
        function(pkg) {
            system.file(package = pkg, lib.loc = libLoc)
        })
    nzchar(paths)
}
<environment: 0x000001883f4b86b8>

$.rs.performsNonstandardEvaluationImpl
function (node, nsePrimitives) 
{
    if (is.call(node)) {
        head <- node[[1]]
        if (!is.symbol(head)) 
            return(FALSE)
        headString <- as.character(head)
        if (headString %in% nsePrimitives) 
            return(TRUE)
        if (headString %in% c("::", ":::") && length(node) == 
            3) {
            export <- node[[3]]
            if (as.character(export) %in% nsePrimitives) 
                return(TRUE)
        }
    }
    return(FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.close
function (id, entry) 
{
    handle <- list(id = .rs.scalar(id), name = .rs.scalar(entry$name), 
        title = .rs.scalar(entry$title), language = .rs.scalar(entry$language))
    .rs.explorer.fireEvent(.rs.explorer.types$CLOSE_NODE, handle)
}
<environment: 0x000001883f4b86b8>

$.rs.GEcopyDisplayList
function (fromDevice) 
{
    tryCatch(.Call("rs_GEcopyDisplayList", fromDevice), error = function(e) warning(e))
}
<environment: 0x000001883f4b86b8>

$.rs.evalWithAvailableArguments
function (fn, args) 
{
    filtered <- args[names(args) %in% names(formals(fn))]
    call <- c(substitute(fn), filtered)
    mode(call) <- "call"
    eval(call, envir = parent.frame())
}
<environment: 0x000001883f4b86b8>

$.rs.formatDataColumn
function (x, start, len, ...) 
{
    col <- x[start:min(NROW(x), start + len)]
    formatted <- .rs.tryCatch(.rs.formatDataColumnDispatch(col, 
        ...))
    if (is.character(formatted) && length(formatted) == length(col)) 
        return(formatted)
    if (is.numeric(col)) 
        .rs.formatDataColumnNumeric(col, ...)
    else if (is.list(col) && !is.data.frame(col)) 
        .rs.formatDataColumnList(col, ...)
    else .rs.formatDataColumnDefault(col, ...)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.listLoadedModules
function (includeBuiltins = FALSE) 
{
    if (!requireNamespace("reticulate", quietly = TRUE)) 
        return(list())
    stack <- .rs.listBuilder()
    globals <- reticulate::py_run_string("globals()", convert = FALSE)
    reticulate::iterate(globals, function(variable) {
        object <- reticulate::py_get_item(globals, variable, 
            silent = TRUE)
        if (!inherits(object, "python.builtin.module")) 
            return(FALSE)
        name <- .rs.nullCoalesce(reticulate::py_get_attr(object, 
            "__name__", silent = TRUE), variable)
        name <- as.character(name)
        if (!includeBuiltins && name %in% c("builtins", "__builtins__")) 
            return(FALSE)
        stack$append(name)
        TRUE
    })
    modules <- stack$data()
    modules <- c("__main__", setdiff(modules, "__main__"))
    lapply(modules, function(module) {
        list(name = .rs.scalar(module), frame = .rs.scalar(0L), 
            local = .rs.scalar(FALSE))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.describeObjectLength
function (object) 
{
    builtins <- reticulate::import_builtins(convert = TRUE)
    tryCatch(builtins$len(object), error = function(e) -1L)
}
<environment: 0x000001883f4b86b8>

$.rs.getActiveFrame
function (offset = 1L) 
{
    frames <- c(.GlobalEnv, sys.frames())
    frames[[length(frames) - 1L - offset]]
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.findTutorials
function (pkgRoot) 
{
    tutorialsRoot <- file.path(pkgRoot, "tutorials")
    if (!file.exists(tutorialsRoot)) 
        return(list())
    tutorialDirs <- sort(list.files(tutorialsRoot, full.names = TRUE))
    tutorials <- lapply(tutorialDirs, .rs.tutorial.findTutorialsImpl)
    Filter(Negate(is.null), tutorials)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionExecuteAction
function (type, host, action) 
{
    connection <- .rs.findActiveConnection(type, host)
    if (!is.null(connection) && action %in% names(connection$actions)) {
        connection$actions[[action]]$callback()
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.api.initializeProject
function (path = getwd()) 
{
    path <- .rs.ensureScalarCharacter(path)
    if (file.exists(path)) {
        if (grepl("[.]Rproj$", path)) 
            return(.rs.normalizePath(path, winslash = "/"))
        if (!utils::file_test("-d", path)) {
            fmt <- "file '%s' exists and is not a directory"
            stop(sprintf(fmt, .rs.createAliasedPath(path)))
        }
    }
    .rs.ensureDirectory(path)
    rProjFiles <- (function() {
        owd <- setwd(path)
        on.exit(setwd(owd), add = TRUE)
        file.path(path, list.files(pattern = "[.]Rproj$"))
    })()
    if (length(rProjFiles)) 
        return(.rs.normalizePath(rProjFiles[[1]], winslash = "/"))
    rProjFile <- file.path(normalizePath(path, mustWork = TRUE, 
        winslash = "/"), paste(basename(path), "Rproj", sep = "."))
    success <- .Call("rs_writeProjectFile", rProjFile, PACKAGE = "(embedding)")
    if (!success) {
        fmt <- "failed to initialize RStudio project in directory '%s'"
        stop(sprintf(fmt, .rs.createAliasedPath(path)))
    }
    return(rProjFile)
}
<environment: 0x000001883fcd76d8>

$.rs.rnb.renderVerbatimConsoleInput
function (code, engine, indent) 
{
    Encoding(code) <- "UTF-8"
    if (length(code) == 1) 
        code <- strsplit(code, "\n", fixed = TRUE)[[1]]
    code <- substring(code, nchar(indent) + 1)
    fmt <- "```%s\n%s\n```"
    out <- sprintf(fmt, tolower(engine), paste(code, collapse = "\n"))
    knitr::asis_output(out)
}
<environment: 0x000001883f4b86b8>

$.rs.doGetIndex
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L, getter) 
{
    if (is.null(inDirectory)) 
        return(character())
    inDirectory <- suppressWarnings(.rs.normalizePath(inDirectory))
    index <- getter(term, inDirectory, maxCount)
    if (is.null(index)) {
        return(list(paths = character(), more_available = FALSE))
    }
    paths <- suppressWarnings(.rs.normalizePath(index$paths, 
        winslash = "/"))
    scores <- .rs.scoreMatches(basename(paths), term)
    index$paths <- paths[order(scores)]
    index
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.stan_get_arguments
function (f) 
{
    .rs.stan.getArguments(f)
}
<environment: 0x000001883f4b86b8>

$.rs.removeWorkingData
function (cacheKey) 
{
    if (exists(".rs.WorkingDataEnv") && exists(cacheKey, where = .rs.WorkingDataEnv, 
        inherits = FALSE)) 
        rm(list = cacheKey, envir = .rs.WorkingDataEnv, inherits = FALSE)
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.python.findCondaBinary
function () 
{
    conda <- getOption("rstudio.conda.binary")
    if (!is.null(conda)) {
        conda <- Sys.which(conda)
        if (nzchar(conda)) 
            return(conda)
    }
    conda <- Sys.which("conda")
    if (nzchar(conda)) 
        return(conda)
    if (.rs.platform.isWindows) {
        condaRoots <- c(file.path(Sys.getenv("USERPROFILE"), 
            "anaconda3"), file.path(Sys.getenv("SYSTEMDRIVE"), 
            "ProgramData/anaconda3"))
    }
    else {
        condaRoots <- c("~/opt/anaconda3", "~/anaconda3", "~/opt/miniconda3", 
            "~/miniconda3", "/anaconda3", "/miniconda3")
    }
    condaSuffix <- if (.rs.platform.isWindows) 
        "condabin/conda.bat"
    else "condabin/conda"
    condaPaths <- file.path(condaRoots, condaSuffix)
    for (condaPath in condaPaths) if (file.exists(condaPath)) 
        return(path.expand(condaPath))
    ""
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.openExistingTutorial
function (name, package) 
{
    tutorial <- .rs.tutorial.registryGet(name, package)
    if (is.null(tutorial)) 
        return(FALSE)
    url <- tutorial[["shiny_url"]]
    if (is.null(url)) 
        return(FALSE)
    job <- tutorial[["job"]]
    running <- .rs.tryCatch(.Call("rs_isJobRunning", job, PACKAGE = "(embedding)"))
    if (!identical(running, TRUE)) 
        return(FALSE)
    meta <- .rs.scalarListFromList(tutorial)
    .rs.invokeShinyTutorialViewer(url, meta)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.scanFiles
function (path, pattern, asRelativePath = TRUE, maxCount = 200L) 
{
    .Call("rs_scanFiles", as.character(path), as.character(pattern), 
        as.logical(asRelativePath), as.integer(maxCount))
}
<environment: 0x000001883f4b86b8>

$.rs.getDataTableJCompletions
function (token) 
{
    .rs.getDataTableSpecialSymbolsCompletions(token, c(".SD", 
        ".BY", ".N", ".I", ".GRP", ".NGRP"))
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.getHtmlCaptureContext
function () 
{
    .rs.getVar("rnb.htmlCaptureContext")
}
<environment: 0x000001883f4b86b8>

$.rs.convertTmTheme
function (tmTheme) 
{
    fillTemplate <- function(template, replacements) {
        repeat {
            matches <- regmatches(template, regexec("%(.+?)%", 
                template))[[1]]
            if (length(matches) != 2) {
                break
            }
            replacement <- replacements[[matches[2]]]
            if (is.null(replacement)) 
                replacement <- ""
            template <- sub(matches[1], replacement, template)
        }
        template
    }
    hyphenate <- function(string) {
        tolower(gsub("-+", "-", sub("^-", "", gsub("_", "-", 
            gsub("([^0-9A-Z])([A-Z])", "\\1-\\2", gsub("(?:'|\"|\\(([^\\)]*)\\))", 
                "\\1", gsub("&", "-and-", gsub("\\s", "-", string))))))))
    }
    quoteStr <- function(string) {
        paste0("\"", gsub("\n", "\\n", gsub("\"", "\\\"", gsub("\\", 
            "\\\\", string))), "\"")
    }
    supportedScopes <- list()
    supportedScopes[["keyword"]] <- "keyword"
    supportedScopes[["keyword.operator"]] <- "keyword.operator"
    supportedScopes[["keyword.other.unit"]] <- "keyword.other.unit"
    supportedScopes[["constant"]] <- "constant"
    supportedScopes[["constant.language"]] <- "constant.language"
    supportedScopes[["constant.library"]] <- "constant.library"
    supportedScopes[["constant.numeric"]] <- "constant.numeric"
    supportedScopes[["constant.character"]] <- "constant.character"
    supportedScopes[["constant.character.escape"]] <- "constant.character.escape"
    supportedScopes[["constant.character.entity"]] <- "constant.character.entity"
    supportedScopes[["constant.other"]] <- "constant.other"
    supportedScopes[["support"]] <- "support"
    supportedScopes[["support.function"]] <- "support.function"
    supportedScopes[["support.function.dom"]] <- "support.function.dom"
    supportedScopes[["support.function.firebug"]] <- "support.firebug"
    supportedScopes[["support.function.constant"]] <- "support.function.constant"
    supportedScopes[["support.constant"]] <- "support.constant"
    supportedScopes[["support.constant.property-value"]] <- "support.constant.property-value"
    supportedScopes[["support.class"]] <- "support.class"
    supportedScopes[["support.type"]] <- "support.type"
    supportedScopes[["support.other"]] <- "support.other"
    supportedScopes[["function"]] <- "function"
    supportedScopes[["function.buildin"]] <- "function.buildin"
    supportedScopes[["storage"]] <- "storage"
    supportedScopes[["storage.type"]] <- "storage.type"
    supportedScopes[["invalid"]] <- "invalid"
    supportedScopes[["invalid.illegal"]] <- "invalid.illegal"
    supportedScopes[["invalid.deprecated"]] <- "invalid.deprecated"
    supportedScopes[["string"]] <- "string"
    supportedScopes[["string.regexp"]] <- "string.regexp"
    supportedScopes[["comment"]] <- "comment"
    supportedScopes[["comment.documentation"]] <- "comment.doc"
    supportedScopes[["comment.documentation.tag"]] <- "comment.doc.tag"
    supportedScopes[["variable"]] <- "variable"
    supportedScopes[["variable.language"]] <- "variable.language"
    supportedScopes[["variable.parameter"]] <- "variable.parameter"
    supportedScopes[["meta"]] <- "meta"
    supportedScopes[["meta.tag.sgml.doctype"]] <- "xml-pe"
    supportedScopes[["meta.tag"]] <- "meta.tag"
    supportedScopes[["meta.selector"]] <- "meta.selector"
    supportedScopes[["entity.other.attribute-name"]] <- "entity.other.attribute-name"
    supportedScopes[["entity.name.function"]] <- "entity.name.function"
    supportedScopes[["entity.name"]] <- "entity.name"
    supportedScopes[["entity.name.tag"]] <- "entity.name.tag"
    supportedScopes[["markup.heading"]] <- "markup.heading"
    supportedScopes[["markup.heading.1"]] <- "markup.heading.1"
    supportedScopes[["markup.heading.2"]] <- "markup.heading.2"
    supportedScopes[["markup.heading.3"]] <- "markup.heading.3"
    supportedScopes[["markup.heading.4"]] <- "markup.heading.4"
    supportedScopes[["markup.heading.5"]] <- "markup.heading.5"
    supportedScopes[["markup.heading.6"]] <- "markup.heading.6"
    supportedScopes[["markup.list"]] <- "markup.list"
    supportedScopes[["collab.user1"]] <- "collab.user1"
    supportedScopes[["marker-layer.active_debug_line"]] <- "marker-layer .active_debug_line"
    conn <- file(description = file.path(.Call("rs_rResourcesPath", 
        PACKAGE = "(embedding)"), "templates", "ace_theme_template.css"), 
        open = "rt")
    on.exit(close(conn), add = TRUE)
    cssTemplate <- paste0(readLines(conn, encoding = "UTF-8"), 
        collapse = "\n")
    name <- tmTheme$name
    if (is.null(name)) 
        name <- ""
    styleRes <- .rs.extractStyles(tmTheme, supportedScopes)
    styles <- styleRes$styles
    unsupportedScopes <- styleRes$unsupportedScopes
    styles$cssClass = paste0("ace-", hyphenate(name))
    styles$uuid <- tmTheme$uuid
    css <- fillTemplate(cssTemplate, styles)
    for (scope in supportedScopes) {
        if (scope %in% names(styles)) {
            if (grepl("active_debug_line", scope, fixed = TRUE)) {
                css = paste0(css, "\n\n.", styles$cssClass, " ", 
                  gsub("^|\\.", ".ace_", scope), " {\n")
                for (rule in names(styles[[scope]])) {
                  if (!grepl("^\\s*$", styles[[scope]][[rule]], 
                    perl = TRUE)) {
                    css = paste0(css, "  ", rule, ": ", styles[[scope]][[rule]], 
                      ";\n")
                  }
                }
                css = paste0(css, "\n  position: absolute;", 
                  "\n  z-index: -1;", "\n}")
            }
            else if (length(styles[[scope]]) > 0) {
                css = paste0(css, "\n\n.", styles$cssClass, " ", 
                  gsub("^|\\.", ".ace_", scope), " {\n")
                for (rule in names(styles[[scope]])) {
                  if (!grepl("^\\s*$", styles[[scope]][[rule]], 
                    perl = TRUE)) {
                    css = paste0(css, "  ", rule, ": ", styles[[scope]][[rule]], 
                      ";\n")
                  }
                }
                css = paste0(css, "\n}")
            }
        }
    }
    list(theme = strsplit(gsub("[^\\{\\}]+\\{\\s*\\}", "", css, 
        perl = TRUE), "\n")[[1]], isDark = as.logical(styles$isDark))
}
<environment: 0x000001883f4b86b8>

$.rs.withChangedExtension
function (path, ext) 
{
    ext <- sub("^\\.+", "", ext)
    if (.rs.endsWith(path, ".nb.html")) 
        paste(substring(path, 1, nchar(path) - 8), ext, sep = ".")
    else if (.rs.endsWith(path, ".tar.gz")) 
        paste(substring(path, 1, nchar(path) - 7), ext, sep = ".")
    else paste(tools::file_path_sans_ext(path), ext, sep = ".")
}
<environment: 0x000001883f4b86b8>

$.rs.libclang.defaultCompilerIncludeDirectories
function (compiler = NULL, isCpp = TRUE) 
{
    if (.rs.platform.isWindows) {
        path <- Sys.getenv("PATH")
        on.exit(Sys.setenv(PATH = path), add = TRUE)
        .rs.addRToolsToPath()
    }
    if (is.null(compiler)) {
        exe <- if (.rs.platform.isWindows) 
            "R.exe"
        else "R"
        R <- file.path(R.home("bin"), exe)
        compiler <- if (isCpp) 
            "CXX"
        else "CC"
        cxx <- system2(R, c("CMD", "config", compiler), stdout = TRUE, 
            stderr = TRUE)
        compiler <- tail(cxx, n = 1L)
    }
    file <- tempfile(fileext = if (isCpp) 
        ".cpp"
    else ".c")
    writeLines("void test() {}", con = file)
    command <- paste(compiler, "-E -v", basename(file))
    output <- local({
        owd <- setwd(tempdir())
        on.exit(setwd(owd), add = TRUE)
        suppressWarnings(system(command, intern = TRUE))
    })
    start <- grep("#include <...> search starts here:", output)
    end <- grep("End of search list.", output)
    if (length(start) == 0L || length(end) == 0L) {
        .rs.logWarningMessage("couldn't determine compiler search list")
        return(character())
    }
    lines <- output[(start + 1L):(end - 1L)]
    paths <- .rs.trimWhitespace(lines)
    normalizePath(paths, winslash = "/", mustWork = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalBusy
function (id) 
{
    if (is.null(id) || !is.character(id)) 
        stop("'id' must be a character vector")
    .Call("rs_terminalBusy", id)
}
<environment: 0x000001883fda4ae0>

$.rs.api.addJobOutput
function (job, output, error = FALSE) 
{
    .Call("rs_addJobOutput", job, output, error, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f065f98>

$.rs.add_keyword_color
function (content, name, overrideMap) 
{
    .rs.add_content(content, ".ace_keyword {", "  color: %s !important;", 
        "}", replace = overrideMap[[name]])
}
<environment: 0x000001883f4b86b8>

$.rs.devModeOn
function () 
{
    devToolsPath <- getOption("devtools.path")
    if (is.null(devToolsPath)) 
        if ("devtools" %in% .packages()) 
            devToolsPath <- "~/R-dev"
    if (is.null(devToolsPath)) 
        return(FALSE)
    devToolsPath <- .rs.normalizePath(devToolsPath, winslash = "/", 
        mustWork = FALSE)
    devToolsPath %in% .libPaths()
}
<environment: 0x000001883f4b86b8>

$.rs.subsetCompletions
function (completions, indices) 
{
    for (name in c("results", "packages", "quote", "type", "context")) completions[[name]] <- completions[[name]][indices]
    if (!is.null(completions[["suggestOnAccept"]])) 
        completions[["suggestOnAccept"]] <- completions[["suggestOnAccept"]][indices]
    completions
}
<bytecode: 0x000001883defd738>
<environment: 0x000001883f4b86b8>

$.rs.assembleDataImportParameters
function (params) 
{
    options <- params$options
    optionTypes <- params$optionTypes
    importFunction <- params$importFunction
    dataImportOptions <- params$dataImportOptions
    package <- params$package
    ns <- ""
    if (!identical(package, NULL)) {
        ns <- paste(package, "::", sep = "")
    }
    buildParameter <- function(optionType, optionValue) {
        if (identical(optionType, NULL)) {
            return(optionValue)
        }
        switch(optionType, character = {
            optionValue <- gsub("\\", "\\\\", optionValue, fixed = TRUE)
            optionValue <- gsub("\"", "\\\"", optionValue, fixed = TRUE)
            return(paste("\"", optionValue, "\"", sep = ""))
        }, locale = {
            localeDefaults <- formals(readr::locale)
            localeOrNull <- function(paramName, jsonName) {
                if (!identical(localeDefaults[[paramName]], optionValue[[jsonName]])) {
                  if (typeof(localeDefaults[[paramName]]) == 
                    "character") {
                    paste(paramName, " = \"", optionValue[[jsonName]], 
                      "\"", sep = "")
                  } else {
                    paste(paramName, " = ", optionValue[[jsonName]])
                  }
                } else NULL
            }
            return(paste(ns, "locale(", paste(c(localeOrNull("date_names", 
                "dateName"), localeOrNull("date_format", "dateFormat"), 
                localeOrNull("time_format", "timeFormat"), localeOrNull("decimal_mark", 
                  "decimalMark"), localeOrNull("grouping_mark", 
                  "groupingMark"), localeOrNull("tz", "tz"), 
                localeOrNull("encoding", "encoding"), localeOrNull("asciify", 
                  "asciify")), collapse = ", "), ")", sep = ""))
        }, columnDefinitionsReadR = {
            colParams <- c()
            for (colIdx in seq_along(optionValue)) {
                col <- optionValue[[colIdx]]
                col_only <- col$only[[1]]
                col_parseString <- col$parseString[[1]]
                col_assignedType <- col$assignedType[[1]]
                col_name <- col$name[[1]]
                if ((!identical(dataImportOptions$columnsOnly, 
                  TRUE) && !identical(col_assignedType, NULL)) || 
                  identical(col_only, TRUE)) {
                  colType <- paste(ns, "col_guess()", sep = "")
                  parseString <- ""
                  if (!identical(col_parseString, NULL)) {
                    if (identical(col_assignedType, "factor")) {
                      parseString <- paste("levels = ", col_parseString, 
                        sep = "")
                    } else {
                      parseString <- paste("format = \"", col_parseString, 
                        "\"", sep = "")
                    }
                  }
                  if (!identical(col_assignedType, NULL)) {
                    colType <- switch(col_assignedType, date = paste(ns, 
                      "col_date(", parseString, ")", sep = ""), 
                      skip = paste(ns, "col_skip()", sep = ""), 
                      time = paste(ns, "col_time(", parseString, 
                        ")", sep = ""), double = paste(ns, "col_double()", 
                        sep = ""), factor = paste(ns, "col_factor(", 
                        parseString, ")", sep = ""), numeric = paste(ns, 
                        "col_number()", sep = ""), integer = paste(ns, 
                        "col_integer()", sep = ""), logical = paste(ns, 
                        "col_logical()", sep = ""), dateTime = paste(ns, 
                        "col_datetime(", parseString, ")", sep = ""), 
                      character = paste(ns, "col_character()", 
                        sep = ""), euroDouble = paste(ns, "col_euro_double()", 
                        sep = ""))
                  }
                  colParams[[col_name]] <- paste("\"", col_name, 
                    "\" = ", colType, sep = "")
                }
            }
            if (length(colParams) == 0) return(NULL)
            colParam <- (paste(colParams, collapse = ",", sep = ""))
            colsConstructor <- "cols"
            if (identical(dataImportOptions$columnsOnly, TRUE)) {
                colsConstructor <- "cols_only"
            }
            return(paste(ns, colsConstructor, "(\n", colParam, 
                ")", sep = ""))
        }, columnDefinitionsReadXl = {
            colParams <- c()
            hasAssignedType <- function(x) {
                !identical(x$assignedType, NULL)
            }
            if (!any(unlist(lapply(optionValue, hasAssignedType), 
                use.names = FALSE))) return(NULL)
            colsByIndex <- list()
            for (colIdx in seq_along(optionValue)) {
                col <- optionValue[[colIdx]]
                colsByIndex[[col$index + 1]] <- col
            }
            for (colIdx in seq(from = 1, to = length(optionValue) - 
                1)) {
                col <- colsByIndex[[colIdx + 1]]
                if (!identical(col$rType, NULL)) {
                  colParams[[colIdx]] <- switch(col$rType, date = "date", 
                    time = "date", double = "numeric", factor = "character", 
                    numeric = "numeric", integer = "numeric", 
                    logical = "numeric", dateTime = "date", character = "text", 
                    "\"text\"")
                  colParams[[colIdx]] <- paste("\"", colParams[[colIdx]], 
                    "\"", sep = "")
                }
                if (!identical(col$assignedType, NULL)) {
                  colParams[[colIdx]] <- switch(col$assignedType, 
                    numeric = "\"numeric\"", date = "\"date\"", 
                    character = "\"text\"", skip = "\"skip\"")
                }
            }
            if (length(colParams) == 0) return(NULL)
            colParam <- (paste(colParams, collapse = ",", sep = ""))
            return(paste(ns, "c", "(\n", colParam, ")", sep = ""))
        }, {
            return(optionValue)
        })
    }
    parameterDefinitions <- formals(importFunction)
    parameterNames <- names(parameterDefinitions)
    options <- Filter(Negate(function(x) is.null(unlist(x))), 
        options)
    optionsNoDefaults <- list()
    for (optionName in parameterNames) {
        if (!identical(NULL, options[[optionName]]) && !identical(options[[optionName]], 
            parameterDefinitions[[optionName]])) {
            if (is.numeric(options[[optionName]]) && is.numeric(parameterDefinitions[[optionName]])) {
                if (!isTRUE(all.equal(options[[optionName]], 
                  parameterDefinitions[[optionName]]))) {
                  optionsNoDefaults[[optionName]] <- options[[optionName]]
                }
            }
            else {
                optionsNoDefaults[[optionName]] <- options[[optionName]]
            }
        }
    }
    parameters <- list()
    for (parameterName in parameterNames) {
        if (identical("symbol", typeof(parameterDefinitions[[parameterName]]))) {
            if (identical(NULL, optionsNoDefaults[[parameterName]])) {
                parameters[[parameterName]] <- "NULL"
            }
            else {
                parameters[[parameterName]] <- buildParameter(optionTypes[[parameterName]], 
                  optionsNoDefaults[[parameterName]])
            }
        }
        else if (!identical(NULL, optionsNoDefaults[[parameterName]])) {
            assembledParameter <- buildParameter(optionTypes[[parameterName]], 
                optionsNoDefaults[[parameterName]])
            if (!identical(assembledParameter, NULL)) {
                parameters[[parameterName]] <- paste(parameterName, 
                  assembledParameter, sep = " = ")
            }
        }
    }
    parameters <- Filter(Negate(function(x) is.null(unlist(x))), 
        parameters)
    paste(parameters, collapse = ",")
}
<environment: 0x000001883f4b86b8>

$.rs.api.eventTargets
$.rs.api.eventTargets$TYPE_UNKNOWN
[1] 0

$.rs.api.eventTargets$TYPE_ACTIVE_WINDOW
[1] 1

$.rs.api.eventTargets$TYPE_ALL_WINDOWS
[1] 2

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.platform.isMacos
[1] FALSE

$.rs.normalizePath
function (path, winslash = "\\", mustWork = NA) 
.Internal(normalizePath(path.expand(path), winslash, mustWork))
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectObject
function (object, context = .rs.explorer.createContext()) 
{
    if (missing(object) || identical(object, quote(expr = ))) 
        return(.rs.explorer.createInspectionResult(quote(expr = ), 
            context))
    result <- .rs.explorer.callCustomInspector(object, context)
    if (!is.null(result)) 
        return(result)
    if (inherits(object, "xml_node") && "xml2" %in% loadedNamespaces()) 
        .rs.explorer.inspectXmlNode(object, context)
    else if (inherits(object, "python.builtin.object")) 
        .rs.explorer.inspectPythonValue(object, context)
    else if (is.list(object) || is.call(object) || is.expression(object)) 
        .rs.explorer.inspectList(object, context)
    else if (is.environment(object)) 
        .rs.explorer.inspectEnvironment(object, context)
    else if (isS4(object)) 
        .rs.explorer.inspectS4(object, context)
    else if (is.function(object)) 
        .rs.explorer.inspectFunction(object, context)
    else .rs.explorer.inspectDefault(object, context)
}
<environment: 0x000001883f4b86b8>

$.rs.sortCompletions
function (completions, token, shortestFirst = FALSE) 
{
    typeScores <- rep(100, length(completions$results))
    typeScores[completions$type == .rs.acCompletionTypes$ARGUMENT] <- 1
    typeScores[completions$type == .rs.acCompletionTypes$COLUMN] <- 2
    typeScores[completions$type == .rs.acCompletionTypes$DATATABLE_SPECIAL_SYMBOL] <- 3
    typeScores[completions$type == .rs.acCompletionTypes$DATAFRAME & 
        !completions$context %in% c(.rs.acContextTypes$NAMESPACE_EXPORTED, 
            .rs.acContextTypes$NAMESPACE_ALL)] <- 4
    typeScores[completions$type == .rs.acCompletionTypes$SECUNDARY_ARGUMENT] <- 5
    typeScores[completions$type == .rs.acCompletionTypes$PACKAGE] <- 101
    typeScores[completions$type == .rs.acCompletionTypes$CONTEXT] <- 102
    scores <- if (nzchar(token)) 
        .rs.scoreMatches(completions$results, token)
    if (!length(scores)) 
        scores <- rep(0L, length(completions$results))
    order <- if (shortestFirst) 
        order(typeScores, scores, nchar(completions$results))
    else order(typeScores, scores)
    completions <- .rs.subsetCompletions(completions, order)
    completions
}
<bytecode: 0x0000018841142a08>
<environment: 0x000001883f4b86b8>

$.rs.lintRFile
function (filePath) 
{
    .Call("rs_lintRFile", filePath)
}
<environment: 0x000001883f4b86b8>

$.rs.packageVersionString
function (pkg) 
{
    as.character(packageVersion(pkg))
}
<environment: 0x000001883f4b86b8>

$.rs.getHelpPackage
function (pkgName) 
{
    pkgName <- sub(":*$", "", pkgName, perl = TRUE)
    topic <- paste(pkgName, "-package", sep = "")
    out <- .rs.getHelp(topic, pkgName)
    if (is.null(out)) {
        pkgDescription <- suppressWarnings(utils::packageDescription(pkgName))
        if (!identical(pkgDescription, NA)) {
            title <- .rs.htmlEscape(pkgDescription$Title)
            description <- .rs.htmlEscape(pkgDescription$Description)
            out <- list(html = paste0("<h2>", title, "</h2><h3>Description</h3><p>", 
                description, "</p>"), signature = NULL, pkgname = pkgName)
        }
    }
    out
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionType
function (object) 
{
    if (identical(object, base::`break`) || identical(object, 
        base::`next`) || identical(object, base::`repeat`)) 
        .rs.acCompletionTypes$KEYWORD
    else if (inherits(object, "refMethodDef")) 
        .rs.acCompletionTypes$R5_METHOD
    else if (inherits(object, "refObjectGenerator")) 
        .rs.acCompletionTypes$R5_CLASS
    else if (inherits(object, "refClass")) 
        .rs.acCompletionTypes$R5_OBJECT
    else if (inherits(object, "R6")) 
        .rs.acCompletionTypes$R6_OBJECT
    else if (isS4(object)) {
        if (inherits(object, "standardGeneric") || inherits(object, 
            "nonstandardGenericFunction")) 
            .rs.acCompletionTypes$S4_GENERIC
        else if (inherits(object, "MethodDefinition")) 
            .rs.acCompletionTypes$S4_METHOD
        else .rs.acCompletionTypes$S4_OBJECT
    }
    else if (is.function(object)) 
        .rs.acCompletionTypes$FUNCTION
    else if (is.array(object)) 
        .rs.acCompletionTypes$ARRAY
    else if (inherits(object, "data.frame")) 
        .rs.acCompletionTypes$DATAFRAME
    else if (is.list(object)) 
        .rs.acCompletionTypes$LIST
    else if (is.environment(object)) 
        .rs.acCompletionTypes$ENVIRONMENT
    else if (is.vector(object)) 
        .rs.acCompletionTypes$VECTOR
    else if (is.factor(object)) 
        .rs.acCompletionTypes$VECTOR
    else .rs.acCompletionTypes$UNKNOWN
}
<environment: 0x000001883f4b86b8>

$.rs.setCRANReposAtStartup
function (cran, secondary) 
{
    repos = getOption("repos")
    cranMirrorConfigured <- !is.null(repos) && !any(repos == 
        "@CRAN@")
    if (!cranMirrorConfigured) 
        .rs.setCRANRepos(cran, secondary)
}
<environment: 0x000001883f4b86b8>

$.rs.viewDataFrame
function (x, title, preview) 
{
    cacheKey <- .rs.addCachedData(force(x), "")
    invisible(.Call("rs_viewData", x, "", title, "", emptyenv(), 
        cacheKey, preview))
}
<environment: 0x000001883f4b86b8>

$.rs.expandPkgDependencies
function (dependencies) 
{
    available <- if (identical(R.version$os, "linux-gnu")) {
        available.packages()
    }
    else {
        available.packages(type = "both")
    }
    .rs.expandDependencies(available, installed.packages(), dependencies)
}
<environment: 0x000001883f4b86b8>

$.rs.fromYAML
function (yamlCode) 
{
    yamlCode <- paste(yamlCode, collapse = "\n")
    .Call("rs_fromYAML", yamlCode, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleOsName
function () 
{
    osMapping <- list(linux = "linux", windows = "windows", darwin = "osx")
    if (!tolower(Sys.info()["sysname"]) %in% names(osMapping)) 
        stop("Operating system \"", Sys.info()["sysname"], "\" is unsupported.")
    osMapping[[tolower(Sys.info()[["sysname"]])]]
}
<environment: 0x000001883f4b86b8>

$.rs.getSignature
function (object) 
{
    signature <- .rs.format(base::args(object))
    length(signature) <- length(signature) - 1
    trimmed <- gsub("^\\s+", "", signature)
    paste(trimmed, collapse = "")
}
<environment: 0x000001883f4b86b8>

$.rs.python.getVirtualEnvironmentInfo
function (envPath) 
{
    exeSuffix <- if (.rs.platform.isWindows) 
        "Scripts/python.exe"
    else "bin/python"
    exePath <- file.path(envPath, exeSuffix)
    if (!file.exists(exePath)) {
        fmt <- "Python executable '%s' does not exist."
        reason <- sprintf(fmt, exePath)
        return(.rs.python.invalidInterpreter(path = exePath, 
            type = "virtualenv", reason = reason))
    }
    .rs.python.interpreterInfo(path = exePath, type = "virtualenv")
}
<environment: 0x000001883f4b86b8>

$.rs.previewDataFrame
function (data, script) 
{
    preparedData <- .rs.prepareViewerData(data, maxFactors = 100, 
        maxCols = 100, maxRows = 1000)
    preview <- list(data = preparedData$data, columns = preparedData$columns, 
        title = if (is.character(script)) .rs.scalar(script) else NULL)
    .rs.enqueClientEvent("data_output_completed", preview)
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.quartoFileProject
function (target) 
{
    .Call("rs_quartoFileProject", basename(target), dirname(target), 
        PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.api.bundledDictionariesPath
function () 
{
    .Call("rs_dictionariesPath", "bundled", PACKAGE = "(embedding)")
}
<environment: 0x000001883fe08588>

$.rs.sql.isTableScopedKeyword
function (keyword) 
{
    keyword %in% c("from", "into", "join", "update", "drop")
}
<environment: 0x000001883f4b86b8>

$.rs.isPackratModeOn
function (dir) 
{
    on <- packrat:::isPackratModeOn(dir)
    if (on) {
        identical(.libPaths()[[1]], packrat:::libDir(dir))
    }
    else {
        FALSE
    }
}
<environment: 0x000001883f4b86b8>

$.rs.selectIsSubsequence
function (strings, string) 
{
    .subset(strings, .rs.isSubsequence(strings, string))
}
<environment: 0x000001883f4b86b8>

$.rs.libPathsAppend
function (path) 
{
    .libPaths(.libPaths()[.libPaths() != path])
    .libPaths(append(.libPaths(), path))
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.shiny.tag
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    htmlfile <- tempfile("_rs_html_", tmpdir = ctx$outputFolder, 
        fileext = ".html")
    depfile <- tempfile("_rs_html_deps_", tmpdir = ctx$outputFolder, 
        fileext = ".json")
    rendered <- htmltools::renderTags(x)
    htmldeps <- rendered$dependencies
    html <- rendered$html
    if (length(htmldeps)) {
        cat(.rs.toJSON(htmldeps, unbox = TRUE), file = depfile, 
            sep = "\n")
        htmltools::save_html(x, file = htmlfile, libdir = ctx$libraryFolder)
    }
    else {
        cat(as.character(html), file = htmlfile, sep = "\n")
    }
    .rs.recordHtmlWidget(x, htmlfile, depfile)
}
<environment: 0x000001883f4b86b8>

$.rs.api.documentId
function (allowConsole = TRUE) 
{
    payload <- list(allow_console = .rs.scalar(allowConsole))
    request <- .rs.api.createRequest(type = .rs.api.eventTypes$TYPE_DOCUMENT_ID, 
        sync = TRUE, target = .rs.api.eventTargets$TYPE_ACTIVE_WINDOW, 
        payload = payload)
    response <- .rs.api.sendRequest(request)
    response$id
}
<environment: 0x000001883fd6f0e0>

$.rs.getNAMESPACEImportedSymbols
function (documentId) 
{
    .Call("rs_getNAMESPACEImportedSymbols", documentId)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionUnregisterWindowsDriver
function (driverName) 
{
    .rs.odbcBundleRegistryRemove(list(list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", "ODBC Drivers", fsep = "\\"), 
        key = driverName), list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", driverName, fsep = "\\"))))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_plumber_viewer_type
function () 
{
    .rs.scalar(.rs.getPlumberViewerType())
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.renv_actions
function (action) 
{
    project <- .rs.getProjectDirectory()
    actions <- renv:::actions(tolower(action), project = project)
    if (length(actions) == 0) 
        return(list())
    remap <- c(Package = "packageName", `Library Version` = "libraryVersion", 
        `Library Source` = "librarySource", `Lockfile Version` = "lockfileVersion", 
        `Lockfile Source` = "lockfileSource", Action = "action")
    matches <- match(names(actions), names(remap), nomatch = 0L)
    names(actions)[matches] <- remap[matches]
    data <- lapply(seq_len(nrow(actions)), function(i) {
        as.list(actions[i, ])
    })
    .rs.scalarListFromList(data)
}
<environment: 0x000001883f4b86b8>

$.rs.parseSecondaryReposIni
function (conf) 
{
    entries <- .rs.readIniFile(conf)
    repos <- list()
    for (entryName in names(entries)) {
        repo <- list(name = .rs.scalar(trimws(entryName)), url = .rs.scalar(trimws(entries[[entryName]])), 
            host = .rs.scalar("Custom"), country = .rs.scalar(""))
        if (identical(tolower(as.character(repo$name)), "cran")) {
            repo$name <- .rs.scalar("CRAN")
            repos <- append(list(repo), repos, 1)
        }
        else {
            repos[[length(repos) + 1]] <- repo
        }
    }
    repos
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.restoreCache
function (cacheDir) 
{
    cache <- .rs.explorer.getCache()
    ids <- list.files(cacheDir)
    for (id in ids) {
        tryCatch({
            path <- file.path(cacheDir, id)
            object <- readRDS(path)
            cache[[id]] <- object
        }, error = warning)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.profile_sources
function (filePath, normPath) 
{
    tryCatch({
        validPath <- ""
        paths <- c(filePath, normPath)
        found <- file.exists(paths)
        if (any(found == TRUE)) {
            validPath <- paths[[which(found == TRUE)[[1]]]]
        }
        return(.rs.scalar(validPath))
    }, error = function(e) {
        return(list(error = .rs.scalar(e$message)))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.topoSortPackages
function (nodes, edges) 
{
    sorted <- c()
    visited <- c()
    visit <- function(node, stack) {
        if (node %in% visited) {
            return()
        }
        if (node %in% stack) {
            stop("Package dependency graph is not a directed acyclic graph.")
        }
        stack <- c(stack, node)
        for (edge in edges) {
            if (identical(edge$from, node)) {
                visit(edge$to, stack)
            }
        }
        visited <<- c(visited, node)
        sorted <<- c(sorted, node)
    }
    while (length(visited) < length(nodes)) {
        for (node in nodes) {
            if (!(node %in% visited)) {
                visit(node, c())
                break
            }
        }
    }
    sorted
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_user_from_token
function (url, token, privateKey) 
{
    user <- rsconnect:::getUserFromRawToken(serverUrl = url, 
        token = token, privateKey = privateKey)
    .rs.scalarListFromList(user)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsInstallPackages
function (token) 
{
    contrib.url <- contrib.url(getOption("repos"), getOption("pkgType"))
    packages <- Reduce(union, lapply(contrib.url, function(url) {
        result <- .rs.getCachedAvailablePackages(url)
        if (is.null(result)) 
            .rs.downloadAvailablePackages(url)
        result <- .rs.getCachedAvailablePackages(url)
        result
    }))
    .rs.makeCompletions(token = token, results = .rs.selectFuzzyMatches(packages, 
        token), quote = TRUE, type = .rs.acCompletionTypes$PACKAGE, 
        excludeOtherCompletions = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.stan.extractFromNamespace
function (key) 
{
    if (!requireNamespace("rstan", quietly = TRUE)) 
        return(NULL)
    rstan <- asNamespace("rstan")
    rstan[[key]]
}
<environment: 0x000001883f4b86b8>

$.rs.python.emptyCompletions
function () 
{
    character()
}
<environment: 0x000001883f4b86b8>

$.rs.isDataTableExtractCall
function (string, envir) 
{
    tryCatch({
        bracketIdx <- regexpr("[", string, fixed = TRUE)
        if (bracketIdx == -1) 
            return(FALSE)
        objectName <- substring(string, 1L, bracketIdx - 1L)
        inherits(.rs.getAnywhere(objectName, envir = envir), 
            "data.table")
    }, error = function(e) FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.withTimeLimit
function (seconds, expr, fail = NULL) 
{
    setTimeLimit(elapsed = seconds, transient = TRUE)
    on.exit(setTimeLimit(), add = TRUE)
    tryCatch(expr, error = function(e) fail)
}
<environment: 0x000001883f4b86b8>

$.rs.isPackageVersionInstalled
function (name, version) 
{
    .rs.isPackageInstalled(name) && (.rs.getPackageVersion(name) >= 
        version)
}
<environment: 0x000001883f4b86b8>

$.rs.valueContents
function (val) 
{
    tryCatch(.rs.valueContentsImpl(val), error = function(e) "NO_VALUE")
}
<environment: 0x000001883f4b86b8>

$.rs.getRCompletions
function (token, index, string, context, numCommas, functionCall, 
    documentId, envir) 
{
    completions <- if (context == .rs.acContextTypes$FUNCTION) 
        .rs.getCompletionsFunction(token, string, functionCall, 
            numCommas, envir)
    else if (context == .rs.acContextTypes$ARGUMENT) 
        .rs.getCompletionsArgument(token, string, functionCall, 
            envir)
    else if (context == .rs.acContextTypes$SINGLE_BRACKET) 
        .rs.getCompletionsSingleBracket(token, string, functionCall, 
            numCommas, index, envir)
    else if (context == .rs.acContextTypes$DOUBLE_BRACKET) 
        .rs.getCompletionsDoubleBracket(token, string, functionCall, 
            envir)
    else .rs.emptyCompletions()
    if (index == 1L) {
        libraryContextCompletions <- .rs.getCompletionsLibraryContext(token, 
            string, context, numCommas, functionCall, documentId, 
            envir)
        if (any(libraryContextCompletions$type == .rs.acCompletionTypes$ARGUMENT)) {
            completions <- .rs.subsetCompletions(completions, 
                completions$type != .rs.acCompletionTypes$ARGUMENT)
        }
        completions <- .rs.appendCompletions(completions, libraryContextCompletions)
    }
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.isCustomCompletionsEnabled
function () 
{
    completer <- utils::rc.getOption("custom.completer")
    is.function(completer)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.follow_help_topic
function (url) 
{
    rx <- "^.*/help/library/([^/]*)/help/(.*)$"
    pkg <- sub(rx, "\\1", url)
    topic <- utils::URLdecode(sub(rx, "\\2", url))
    .rs.followHelpTopic(pkg = pkg, topic = topic)
}
<environment: 0x000001883f4b86b8>

$.rs.restoreOptions
function (filename) 
{
    load(filename)
    options(opt)
}
<environment: 0x000001883f4b86b8>

$.rs.downloadAllDictionaries
function (targetDir, secure) 
{
    fmt <- "%s://s3.amazonaws.com/rstudio-buildtools/dictionaries/%s"
    protocol <- if (secure) 
        "https"
    else "http"
    archive <- "all-dictionaries.zip"
    url <- sprintf(fmt, protocol, archive)
    archivePath <- file.path(tempdir(), archive)
    if (file.exists(archivePath)) 
        file.remove(archivePath)
    download.file(url = url, destfile = archivePath, cacheOK = FALSE, 
        quiet = TRUE)
    unlink(targetDir, recursive = TRUE)
    dir.create(targetDir, showWarnings = FALSE, recursive = TRUE)
    tryCatch(unzip(archivePath, exdir = targetDir), error = function(e) {
        unlink(targetDir, recursive = TRUE)
        stop(e)
    })
    unlink(archivePath)
    invisible(targetDir)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionReadSnippets
function () 
{
    snippetsPaths <- .rs.connectionFiles("\\.R$", .rs.connectionFilesPath())
    snippets <- lapply(snippetsPaths, function(fullPath) {
        paste(readLines(fullPath), collapse = "\n")
    })
    lapply(names(snippets), function(snippetName) {
        tryCatch({
            snippet <- snippets[[snippetName]]
            list(package = .rs.scalar(NULL), version = .rs.scalar(NULL), 
                name = .rs.scalar(snippetName), type = .rs.scalar("Snippet"), 
                snippet = .rs.scalar(snippet), help = .rs.scalar(NULL), 
                iconData = .rs.scalar(.Call("rs_connectionIcon", 
                  snippetName)), licensed = .rs.scalar(FALSE), 
                source = .rs.scalar("Snippet"), hasInstaller = .rs.scalar(FALSE))
        }, error = function(e) {
            warning(e$message)
            NULL
        })
    })
}
<environment: 0x000001883f4b86b8>

$.rs.rAddinsEnv
<environment: 0x000001883dafeb68>

$.rs.api.navigateToFile
function (filePath = character(0), line = -1L, col = -1L, moveCursor = TRUE) 
{
    .rs.api.documentOpen(filePath, line = line, col = col, moveCursor = moveCursor)
}
<environment: 0x000001883fd10ff8>

$.rs.mergeLists
function (baseList, overlayList, recursive = TRUE) 
{
    if (length(baseList) == 0) 
        overlayList
    else if (length(overlayList) == 0) 
        baseList
    else {
        mergedList <- baseList
        for (name in names(overlayList)) {
            base <- baseList[[name]]
            overlay <- overlayList[[name]]
            if (is.list(base) && is.list(overlay) && recursive) 
                mergedList[[name]] <- merge_lists(base, overlay)
            else {
                mergedList[[name]] <- NULL
                mergedList <- append(mergedList, overlayList[which(names(overlayList) %in% 
                  name)])
            }
        }
        mergedList
    }
}
<environment: 0x000001883f4b86b8>

$.rs.invokePlumberPaneViewer
function (url) 
{
    invisible(.Call("rs_plumberviewer", url, getwd(), "pane", 
        PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"plumberViewerType")
[1] "pane"

$.rs.getSecretService
function () 
{
    "RStudio Keyring Secrets"
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.prepare_for_addin
function () 
{
    .rs.addins.addShinyResponseFilter()
}
<environment: 0x000001883f4b86b8>

$.rs.base64decode
function (data, binary = FALSE) 
{
    .Call("rs_base64decode", data, binary)
}
<environment: 0x000001883f4b86b8>

$.rs.environmentList
function (startEnv) 
{
    env <- startEnv
    envs <- list()
    local <- TRUE
    if (!identical(env, globalenv())) {
        while (!identical(env, globalenv()) && !identical(env, 
            emptyenv())) {
            frame <- .rs.environmentCallFrameName(env)
            if (frame$frame > 0) {
                envs[[length(envs) + 1]] <- frame
                env <- parent.env(env)
            }
            else {
                break
            }
        }
    }
    while (!identical(env, emptyenv())) {
        if (identical(env, globalenv())) 
            local <- FALSE
        envName <- environmentName(env)
        if (nzchar(envName) && !envName %in% c("tools:rstudio", 
            "Autoloads")) {
            envs[[length(envs) + 1]] <- list(name = .rs.scalar(envName), 
                frame = .rs.scalar(0L), local = .rs.scalar(local))
        }
        env <- parent.env(env)
    }
    envs
}
<environment: 0x000001883f4b86b8>

$.rs.getCustomRCompletions
function (line) 
{
    utils:::.assignLinebuffer(line)
    utils:::.assignEnd(nchar(line))
    token <- utils:::.guessTokenFromLine()
    utils:::.completeToken()
    results <- utils:::.retrieveCompletions()
    packages <- NULL
    type <- .rs.formCompletionVector(attr(results, "type"), .rs.acCompletionTypes$UNKNOWN, 
        length(results))
    if (type[[1]] %in% c(.rs.acCompletionTypes$UNKNOWN, .rs.acCompletionTypes$FUNCTION)) {
        packages <- sub("^package:", "", .rs.which(results))
        results <- sub("=$", " = ", results)
        choose <- packages == ".GlobalEnv"
        results <- c(results[choose], results[!choose])
        packages <- c(packages[choose], packages[!choose])
        type <- c(type[choose], type[!choose])
        packages <- sub("^\\.GlobalEnv$", "", packages)
    }
    .rs.makeCompletions(token = token, results = results, packages = packages, 
        type = type)
}
<environment: 0x000001883f4b86b8>

$.rs.addApiFunction
function (name, FN) 
{
    fullName <- paste("api.", name, sep = "")
    envir <- .rs.symbolLookupEnv()
    environment(FN) <- envir
    .rs.addFunction(fullName, FN, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.r.keywords
 [1] "TRUE"          "FALSE"         "NA"            "NA_real_"      "NA_complex_"   "NA_integer_"   "NA_character_" "NULL"         
 [9] "Inf"           "else"          "in"           
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.createCommentBgRule
function (themeName, isDark, overrides = list()) 
{
    commentFgColor <- if (isDark) 
        "#4D4333"
    else "#3C4C72"
    commentBgColor <- if (isDark) 
        "#D1B78A"
    else "#FFECCB"
    override <- overrides[[themeName]]
    if (!is.null(override) && !is.null(override$fg)) 
        commentFgColor <- override$fg
    if (!is.null(override) && !is.null(override$bg)) 
        commentBgColor <- override$bg
    sprintf(paste(sep = "\n", ".ace_comment-highlight {", "  color: %s;", 
        "  background-color: %s;", "}"), commentFgColor, commentBgColor)
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.registry
<environment: 0x000001883f4e2a80>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.parseQuitArguments
function (command) 
{
    expr <- parse(text = command)
    if (length(expr) == 0) 
        stop("Not a fully formed command: ", command)
    call <- as.call(expr[[1]])
    call <- match.call(quit, call)
    as.list(call)[-1]
}
<environment: 0x000001883f4b86b8>

$.rs.api.setJobStatus
function (job, status) 
{
    if (missing(job)) 
        stop("Must specify job ID to set status for.")
    if (missing(status)) 
        stop("Must specify job status to update.")
    .Call("rs_setJobStatus", job, status, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f04da78>

$.rs.explorer.tags
$.rs.explorer.tags$ATTRIBUTES
[1] "attributes"

$.rs.explorer.tags$VIRTUAL
[1] "virtual"

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.isS3Generic
function (object) 
{
    if (!is.function(object)) 
        return(FALSE)
    if (inherits(object, "groupGenericFunction")) 
        return(TRUE)
    .rs.callsUseMethod(body(object))
}
<environment: 0x000001883f4b86b8>

$.rs.readUserPref
function (prefName) 
{
    .rs.readPrefInternal("rs_readUserPref", prefName)
}
<environment: 0x000001883f4b86b8>

$.rs.stopf
function (fmt, ..., call. = FALSE) 
{
    msg <- sprintf(fmt, ...)
    stop(msg, call. = call.)
}
<environment: 0x000001883f4b86b8>

$.rs.api.buildToolsCheck
function () 
{
    .Call("rs_canBuildCpp", PACKAGE = "(embedding)")
}
<environment: 0x000001883fdf6be8>

$.rs.writeUiPref
function (prefName, value) 
{
    if (is.list(value)) {
        value <- .rs.scalarListFromList(value)
    }
    .rs.writePrefInternal("rs_writeUserPref", prefName, value)
}
<environment: 0x000001883f4b86b8>

$.rs.readlineCompletions
function (token) 
{
    nframes <- sys.nframe()
    for (i in seq_len(nframes)) {
        fun <- sys.function(i)
        if (identical(fun, base::readline)) {
            frame <- sys.frame(i)
            rx <- "^.*(\\(|\\[)(.*)(\\)|\\]).*$"
            prompt <- frame$prompt
            if (is.character(prompt) && grepl(rx, prompt)) {
                results <- strsplit(sub(rx, "\\2", prompt), "/")[[1L]]
                cap <- grepl("^[A-Z]", results)
                c(results[cap], results[!cap])
                return(.rs.makeCompletions(token = token, results = results, 
                  quote = FALSE, type = .rs.acCompletionTypes$STRING))
            }
            else {
                return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
            }
        }
    }
}
<bytecode: 0x000001883be77160>
<environment: 0x000001883f4b86b8>

$.rs.connectionReadWindowsRegistry
function () 
{
    registryOdbcPath <- "SOFTWARE\\ODBC\\ODBCINST.INI\\"
    registryEntries <- lapply(names(readRegistry(registryOdbcPath)), 
        function(driver) {
            driverPath <- readRegistry(paste(registryOdbcPath, 
                driver, sep = ""))$Driver
            list(name = driver, attribute = "Driver", value = driverPath)
        })
    registryEntriesValue <- Filter(function(e) !is.null(e$value), 
        registryEntries)
    do.call(rbind, lapply(registryEntriesValue, function(e) data.frame(e, 
        stringsAsFactors = FALSE)))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.open_profile
function (profilerOptions) 
{
    tryCatch({
        resources <- .rs.profileResources()
        htmlFile <- normalizePath(tempfile(fileext = ".html", 
            tmpdir = resources$tempPath), winslash = "/", mustWork = FALSE)
        if (identical(profilerOptions$profvis, NULL)) {
            if (identical(tools::file_ext(profilerOptions$fileName), 
                "Rprof")) {
                profvis <- profvis::profvis(prof_input = profilerOptions$fileName, 
                  split = "h")
                htmlwidgets::saveWidget(profvis, htmlFile, selfcontained = TRUE)
            }
            else {
                .rs.rpc.copy_profile(profilerOptions$fileName, 
                  htmlFile)
            }
        }
        else {
            profvis <- profilerOptions$profvis
            htmlwidgets::saveWidget(profvis, htmlFile, selfcontained = TRUE)
        }
        return(list(htmlPath = .rs.scalar(paste("profiles/", 
            basename(htmlFile), sep = "")), htmlLocalPath = .rs.scalar(htmlFile)))
    }, error = function(e) {
        return(list(error = .rs.scalar(e$message)))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.setOptionDefault
function (name, value) 
{
    if (!is.null(getOption(name))) 
        return(FALSE)
    data <- list(value)
    names(data) <- name
    options(data)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.listDatasetsProvidedByPackage
function (package) 
{
    if (!is.character(package) || length(package) != 1 || !nzchar(package)) 
        return(character())
    location <- find.package(package, quiet = TRUE)
    if (!length(location) || !file.exists(location)) 
        return(character())
    datalist <- file.path(location, "data/datalist")
    if (!file.exists(datalist)) 
        return(character())
    readLines(datalist, warn = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionOdbcRStudioDriver
function () 
{
    " with RStudio Driver"
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.matplotlib.onLoaded
function () 
{
    canInstallHooks <- requireNamespace("png", quietly = TRUE) && 
        reticulate::py_module_available("matplotlib")
    if (!canInstallHooks) 
        return()
    matplotlib <- reticulate::import("matplotlib", convert = TRUE)
    backend <- matplotlib$get_backend()
    if (!identical(tolower(backend), "agg")) {
        sys <- reticulate::import("sys", convert = TRUE)
        if ("matplotlib.backends" %in% names(sys$modules)) 
            matplotlib$pyplot$switch_backend("agg")
        else matplotlib$use("agg", warn = FALSE, force = TRUE)
    }
    moduleNames <- c("matplotlib.pyplot", "matplotlib.pylab")
    for (moduleName in moduleNames) {
        if (exists(moduleName, envir = .rs.reticulate.hookedMatplotlibModules)) 
            next
        sys <- reticulate::import("sys", convert = TRUE)
        if (is.null(sys$modules[[moduleName]])) 
            next
        module <- reticulate::import(moduleName, convert = TRUE)
        module$show <- .rs.reticulate.matplotlib.showHook
        assign(moduleName, TRUE, envir = .rs.reticulate.hookedMatplotlibModules)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.registryKey
function (name, package) 
{
    paste(package, name, sep = "::")
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.htmlCaptureHooks
function () 
{
    list(print.htmlwidget = .rs.rnbHooks.print.htmlwidget, print.html = .rs.rnbHooks.print.html, 
        print.shiny.tag = .rs.rnbHooks.print.shiny.tag, print.shiny.tag.list = .rs.rnbHooks.print.shiny.tag.list, 
        print.knit_asis = .rs.rnbHooks.print.knit_asis, print.knit_image_paths = .rs.rnbHooks.print.knit_image_paths)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleWriteIni
function (odbcinstPath, data) 
{
    lines <- c()
    for (name in names(data)) {
        lines <- c(lines, if (identical(name, "__header__")) "" else paste("[", 
            name, "]", sep = ""))
        lines <- c(lines, unlist(data[[name]]), "")
    }
    if (is.null(lines)) 
        lines <- c("")
    writeLines(lines, odbcinstPath)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.python_active_interpreter
function () 
{
    pythonPath <- Sys.getenv("RETICULATE_PYTHON", unset = NA)
    if (is.na(pythonPath)) 
        pythonPath <- Sys.getenv("RETICULATE_PYTHON_FALLBACK", 
            unset = NA)
    info <- if (is.na(pythonPath)) {
        .rs.python.invalidInterpreter(path = pythonPath, type = NULL, 
            reason = "RETICULATE_PYTHON and RETICULATE_PYTHON_FALLBACK are unset.")
    }
    else {
        .rs.python.getPythonInfo(pythonPath, strict = TRUE)
    }
    .rs.scalarListFromList(info)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionHasInstaller
function (name) 
{
    installerName <- paste(name, "dcf", sep = ".")
    connectionFiles <- as.character(.rs.connectionFiles("\\.dcf$", 
        .rs.connectionOdbcInstallerPath()))
    any(basename(connectionFiles) == installerName)
}
<environment: 0x000001883f4b86b8>

$.rs.db.listSchemas
function (conn) 
{
    if ("odbc" %in% loadedNamespaces() && inherits(conn, "OdbcConnection")) {
        objects <- odbc::odbcListObjects(conn)
        return(objects$name[objects$type == "schema"])
    }
    objects <- DBI::dbListObjects(conn)
    items <- Filter(function(x) "schema" %in% names(x@name), 
        objects$table)
    schemas <- vapply(items, function(item) item@name[["schema"]], 
        character(1))
    if ("RSQLite" %in% loadedNamespaces() && inherits(conn, "SQLiteConnection")) {
        databases <- DBI::dbGetQuery(conn, "PRAGMA database_list;")
        schemas <- unique(c(databases$name, schemas))
    }
    schemas
}
<environment: 0x000001883f4b86b8>

$.rs.getRArch
function () 
{
    .Platform$r_arch
}
<environment: 0x000001883f4b86b8>

$.rs.parseArrayElement
function (arrayElement, keyName) 
{
    if (xml2::xml_length(arrayElement) < 1) {
        stop("\"array\" element cannot be empty.", call. = FALSE)
    }
    if (is.null(keyName)) {
        stop("Unable to find a key for array value.", call. = FALSE)
    }
    if (keyName != "settings") {
        stop("Incorrect key for array element. Expected: \"settings\"; Actual: \"", 
            keyName, "\".", call. = FALSE)
    }
    values <- list()
    index <- 1
    for (element in xml2::xml_children(arrayElement)) {
        elName <- xml2::xml_name(element)
        if (elName != "comment") {
            if (elName != "dict") {
                stop("Expecting \"dict\" element; found \"", 
                  elName, "\".", call. = FALSE)
            }
            values[[index]] <- .rs.parseDictElement(element, 
                "")
            index <- index + 1
        }
    }
    values
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsFunction
function (token, string, functionCall, numCommas, envir = parent.frame(), 
    object = .rs.resolveObjectFromFunctionCall(functionCall, 
        envir)) 
{
    result <- .rs.emptyCompletions()
    if (!is.null(object) && is.function(object)) {
        if (.rs.isR6NewMethod(object)) 
            object <- .rs.getR6ClassGeneratorMethod(object, "initialize")
        matchedCall <- .rs.matchCall(object, functionCall, numCommas = numCommas)
        formals <- NULL
        if (.rs.isKnitrObject(object)) {
            ns <- asNamespace("knitr")
            tryGetKnitrGetter <- function(name, ns = asNamespace("knitr")) tryCatch(get(name, 
                envir = ns)$get, error = function(e) NULL)
            tryGetKnitrSetter <- function(name, ns = asNamespace("knitr")) tryCatch(get(name, 
                envir = ns)$set, error = function(e) NULL)
            tryGet <- function(name, ns = asNamespace("knitr")) list(getter = tryGetKnitrGetter(name, 
                ns), setter = tryGetKnitrSetter(name, ns))
            knitrOpts <- list(tryGet("opts_chunk", ns), tryGet("opts_knit", 
                ns), tryGet("opts_current", ns), tryGet("opts_template", 
                ns), tryGet("knit_hooks", ns), tryGet("knit_theme", 
                ns))
            for (opt in knitrOpts) {
                if (identical(object, opt$getter)) {
                  results <- .rs.selectFuzzyMatches(names(opt$getter()), 
                    token)
                  return(.rs.makeCompletions(token = token, results = results, 
                    type = .rs.acCompletionTypes$STRING, quote = TRUE))
                }
                if (identical(object, opt$setter)) {
                  formals <- list(formals = names(opt$getter()))
                  break
                }
            }
        }
        if (is.null(formals) && inherits(object, "classGeneratorFunction")) {
            try(silent = TRUE, {
                class <- object@className
                defn <- getClass(class)
                slots <- defn@slots
                formals <- list(formals = names(slots), methods = rep(class, 
                  length(slots)))
            })
        }
        if (is.null(formals)) {
            formals <- .rs.resolveFormals(token, object, string, 
                functionCall, matchedCall, envir)
        }
        if (length(formals$formals)) {
            formals$formals <- vapply(formals$formals, function(fml) {
                paste(deparse(as.name(fml), backtick = TRUE), 
                  "= ")
            }, FUN.VALUE = character(1))
        }
        if (identical(object, base::c) || identical(object, base::list)) {
            formals <- list(formals = character(), methods = character())
        }
        activeArg <- .rs.getActiveArgument(object, matchedCall)
        if (!length(activeArg) || is.na(activeArg)) 
            activeArg <- ""
        if (!is.null(activeArg) && activeArg == "..." && "dplyr" %in% 
            loadedNamespaces() && identical(object, get("group_by", 
            envir = asNamespace("dplyr")))) {
            .data <- .rs.getAnywhere(matchedCall[[".data"]], 
                envir = envir)
            if (!is.null(.data)) {
                .names <- .rs.selectFuzzyMatches(.rs.getNames(.data), 
                  token)
                if (length(.names)) {
                  namesCall <- names(matchedCall)
                  .drop <- setdiff(namesCall, c("", ".data", 
                    ".drop", ".keep"))
                  unnamed <- as.list(matchedCall)[namesCall == 
                    ""][-1]
                  for (arg in unnamed) {
                    if (is.symbol(arg)) 
                      .drop <- c(.drop, as.character(arg))
                  }
                  groupByCompletions <- .rs.makeCompletions(token = token, 
                    results = setdiff(.names, .drop), quote = FALSE, 
                    type = .rs.acCompletionTypes$COLUMN, package = as.character(matchedCall[[".data"]]))
                  return(groupByCompletions)
                }
            }
        }
        argCompletions <- .rs.getCompletionsArgument(token = token, 
            activeArg = activeArg, functionCall = functionCall, 
            envir = envir)
        if (identical(activeArg, "formula") && !is.null(argCompletions) && 
            !.rs.isEmptyCompletion(argCompletions)) {
            return(argCompletions)
        }
        fguess <- if (length(formals$methods)) 
            formals$methods[[1]]
        else ""
        used <- names(as.list(matchedCall)[-1])
        keep <- !names(formals$formals) %in% c("...", used)
        result <- .rs.appendCompletions(argCompletions, .rs.makeCompletions(token = token, 
            results = formals$formals[keep], packages = formals$methods[keep], 
            type = .rs.acCompletionTypes$ARGUMENT, excludeOtherCompletions = FALSE, 
            excludeOtherArgumentCompletions = TRUE, fguess = fguess, 
            orderStartsWithAlnumFirst = FALSE))
    }
    result
}
<bytecode: 0x000001883e1bc408>
<environment: 0x000001883f4b86b8>

$.rs.updatePackageEvents
function () 
{
    reportPackageStatus <- function(status) function(pkgname, 
        ...) {
        packageStatus = list(name = pkgname, path = .rs.createAliasedPath(.rs.pathPackage(pkgname, 
            quiet = TRUE)), loaded = status)
        .rs.enqueClientEvent("package_status_changed", packageStatus)
    }
    notifyPackageLoaded <- function(pkgname, ...) {
        .Call("rs_packageLoaded", pkgname, PACKAGE = "(embedding)")
        .rs.reattachS3Overrides()
    }
    notifyPackageUnloaded <- function(pkgname, ...) {
        .rs.beforePackageUnloaded(pkgname)
        .Call("rs_packageUnloaded", pkgname, PACKAGE = "(embedding)")
    }
    pkgNames <- base::list.dirs(.libPaths(), full.names = FALSE, 
        recursive = FALSE)
    sapply(pkgNames, function(packageName) {
        if (!(packageName %in% .rs.hookedPackages)) {
            attachEventName = packageEvent(packageName, "attach")
            setHook(attachEventName, reportPackageStatus(TRUE), 
                action = "append")
            loadEventName = packageEvent(packageName, "onLoad")
            setHook(loadEventName, notifyPackageLoaded, action = "append")
            unloadEventName = packageEvent(packageName, "onUnload")
            setHook(unloadEventName, notifyPackageUnloaded, action = "append")
            detachEventName = packageEvent(packageName, "detach")
            setHook(detachEventName, reportPackageStatus(FALSE), 
                action = "append")
            .rs.setVar("hookedPackages", append(.rs.hookedPackages, 
                packageName))
        }
    })
}
<environment: 0x000001883f4b86b8>

$.rs.builtWithRtoolsGcc493
function () 
{
    identical(.Platform$OS.type, "windows") && getRversion() >= 
        "3.3" && .rs.haveRequiredRSvnRev(70462)
}
<environment: 0x000001883f4b86b8>

$.rs.S3Overrides
<environment: 0x00000188402b1508>

$.rs.breakOnAnyError
function () 
{
    .rs.breakOnError(FALSE)
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE
attr(,"errorHandlerType")
[1] "break"

$.rs.rnb.pagedTableHtml
function (rdfPath) 
{
    data <- .rs.readDataCapture(rdfPath)
    paste("<div data-pagedtable=\"false\">", "  <script data-pagedtable-source type=\"application/json\">", 
        jsonlite::toJSON(data), "  </script>", "</div>", sep = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.rstudioapi.processRequestImpl
function (requests, response, secret) 
{
    data <- readRDS(requests)
    if (!identical(data$secret, secret)) 
        stop("invalid secret in rstudioapi IPC")
    call <- data$call
    output <- eval(call, envir = baseenv())
    saveRDS(output, file = response)
}
<environment: 0x000001883f4b86b8>

$.rs.showPresentation
function (file = ".") 
{
    if (!is.character(file)) 
        stop("file must be of type character")
    invisible(.Call(getNativeSymbolInfo("rs_showPresentation", 
        PACKAGE = ""), .rs.normalizePath(path.expand(file))))
}
<environment: 0x000001883f4b86b8>

$.rs.api.documentNew
function (type, code, row = 0, column = 0, execute = FALSE) 
{
    type <- switch(type, rmd = "r_markdown", rmarkdown = "r_markdown", 
        sql = "sql", "r_script")
    payload <- list(type = .rs.scalar(type), code = .rs.scalar(paste(code, 
        collapse = "\n")), row = .rs.scalar(as.integer(row)), 
        column = .rs.scalar(as.integer(column)), execute = .rs.scalar(execute))
    request <- .rs.api.createRequest(type = .rs.api.eventTypes$TYPE_DOCUMENT_NEW, 
        sync = TRUE, target = .rs.api.eventTargets$TYPE_ACTIVE_WINDOW, 
        payload = payload)
    response <- .rs.api.sendRequest(request)
    response$id
}
<environment: 0x000001883fd892e0>

$.rs.rpc.save_active_document
function (contents, sweave, rnwWeave) 
{
    previousWd = getwd()
    setwd("~/")
    on.exit(setwd(previousWd))
    activeRStudioDoc <- "~/.active-rstudio-document"
    if (file.exists(activeRStudioDoc)) 
        file.remove(activeRStudioDoc)
    Encoding(contents) <- "UTF-8"
    writeLines(contents, activeRStudioDoc, useBytes = TRUE)
    if (sweave) {
        op <- function() {
            .Call("rs_rnwTangle", activeRStudioDoc, "UTF-8", 
                rnwWeave)
            file.remove(activeRStudioDoc)
            file.rename(paste(activeRStudioDoc, ".R", sep = ""), 
                activeRStudioDoc)
        }
        capture.output(op())
    }
    .Call("rs_ensureFileHidden", activeRStudioDoc)
    return()
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.connection_test
function (code) 
{
    error <- ""
    oldConnectionObserver <- getOption("connectionObserver")
    on.exit(options(connectionObserver = oldConnectionObserver))
    disconnectCalls <- list()
    options(connectionObserver = list(connectionOpened = function(type, 
        host, displayName, icon = NULL, connectCode, disconnect, 
        listObjectTypes, listObjects, listColumns, previewObject, 
        connectionObject, actions = NULL) {
        disconnectCalls <<- c(disconnectCalls, disconnect)
    }, connectionClosed = function(type, host, ...) {
    }, connectionUpdated = function(type, host, hint, ...) {
    }))
    .envir <- .rs.getActiveFrame()
    tryCatch({
        eval(parse(text = code), envir = .envir)
    }, error = function(e) {
        error <<- e$message
    })
    lapply(disconnectCalls, function(e) e())
    .rs.scalar(error)
}
<environment: 0x000001883f4b86b8>

$.rs.doShinyServerCompletions
function (object, inputs, outputs, inputCount, outputCount) 
{
    if (is.call(object)) {
        operator <- as.character(object[[1]])
        if (length(object) == 3 && (operator == "$" || operator == 
            "[[")) {
            name <- if (is.symbol(object[[2]])) 
                as.character(object[[2]])
            else if (is.character(object[[2]]) && length(object[[2]]) == 
                1) 
                object[[2]]
            else ""
            value <- as.character(object[[3]])
            if (name == "output") {
                outputCount$count <- outputCount$count + 1
                outputs[[as.character(outputCount$count)]] <- .rs.stripSurrounding(value)
            }
            if (name == "input") {
                inputCount$count <- inputCount$count + 1
                inputs[[as.character(inputCount$count)]] <- .rs.stripSurrounding(value)
            }
        }
        if (length(object) > 1) {
            for (j in 2:length(object)) {
                if (is.call(object[[j]])) {
                  .rs.doShinyServerCompletions(object[[j]], inputs, 
                    outputs, inputCount, outputCount)
                }
            }
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getFunctionArgumentNames
function (object) 
{
    if (is.primitive(object)) 
        object <- args(object)
    result <- character()
    if (is.function(object)) 
        result <- names(formals(object))
    result
}
<environment: 0x000001883f4b86b8>

$.rs.unquote
function (strings) 
{
    tryCatch(.rs.unquoteImpl(strings), error = function(e) strings)
}
<environment: 0x000001883f4b86b8>

$.rs.initializeProjectFromTemplate
function (projectFilePath, projectPath, description, inputs) 
{
    parentPath <- dirname(projectPath)
    .rs.ensureDirectory(parentPath)
    owd <- setwd(parentPath)
    on.exit(setwd(owd), add = TRUE)
    fn <- if (identical(description$package, "(local)")) 
        as.name(description$binding)
    else call(":::", as.name(description$package), as.name(description$binding))
    skeleton <- c(fn, basename(projectPath), inputs)
    eval(as.call(skeleton), envir = .GlobalEnv)
    .rs.addFirstRunDocumentsForTemplate(projectFilePath, projectPath, 
        description$open_files)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.python.tokenCursor
function (tokens) 
{
    .tokens <- tokens
    .offset <- 1L
    .n <- length(tokens)
    .lbrackets <- c("(", "{", "[")
    .rbrackets <- c(")", "}", "]")
    .complements <- list(`(` = ")", `[` = "]", `{` = "}", `)` = "(", 
        `]` = "[", `}` = "{")
    tokenValue <- function() {
        .tokens[[.offset]]$value
    }
    tokenType <- function() {
        .tokens[[.offset]]$type
    }
    tokenOffset <- function() {
        .tokens[[.offset]]$offset
    }
    cursorOffset <- function() {
        .offset
    }
    moveToOffset <- function(offset) {
        if (offset < 1L) 
            .offset <<- 1L
        else if (offset > .n) 
            .offset <<- .n
        else .offset <<- offset
    }
    moveToNextToken <- function(i = 1L) {
        offset <- .offset + i
        if (offset > .n) 
            return(FALSE)
        .offset <<- offset
        return(TRUE)
    }
    moveToPreviousToken <- function(i = 1L) {
        offset <- .offset - i
        if (offset < 1L) 
            return(FALSE)
        .offset <<- offset
        return(TRUE)
    }
    moveRelative <- function(i = 1L) {
        offset <- .offset + i
        if (offset < 1L || offset > .n) 
            return(FALSE)
        .offset <<- offset
        return(TRUE)
    }
    fwdToMatchingBracket <- function() {
        token <- .tokens[[.offset]]
        value <- token$value
        if (!value %in% .lbrackets) 
            return(FALSE)
        lhs <- value
        rhs <- .complements[[lhs]]
        count <- 1
        while (moveToNextToken()) {
            value <- tokenValue()
            if (value == lhs) {
                count <- count + 1
            }
            else if (value == rhs) {
                count <- count - 1
                if (count == 0) 
                  return(TRUE)
            }
        }
        return(FALSE)
    }
    bwdToMatchingBracket <- function() {
        token <- .tokens[[.offset]]
        value <- token$value
        if (!value %in% .rbrackets) 
            return(FALSE)
        lhs <- value
        rhs <- .complements[[lhs]]
        count <- 1
        while (moveToPreviousToken()) {
            value <- tokenValue()
            if (value == lhs) {
                count <- count + 1
            }
            else if (value == rhs) {
                count <- count - 1
                if (count == 0) 
                  return(TRUE)
            }
        }
        return(FALSE)
    }
    peek <- function(i = 0L) {
        offset <- .offset + i
        if (offset < 1L || offset > .n) 
            return(.rs.python.token("", "unknown", -1L))
        return(.tokens[[offset]])
    }
    find <- function(predicate, forward = TRUE) {
        if (forward) {
            offset <- .offset + 1L
            while (offset <= .n) {
                token <- .tokens[[offset]]
                if (predicate(token)) {
                  .offset <<- offset
                  return(TRUE)
                }
                offset <- offset + 1L
            }
            return(FALSE)
        }
        else {
            offset <- .offset - 1L
            while (offset >= 1L) {
                token <- .tokens[[offset]]
                if (predicate(token)) {
                  .offset <<- offset
                  return(TRUE)
                }
                offset <- offset - 1L
            }
            return(FALSE)
        }
    }
    moveToStartOfEvaluation <- function() {
        repeat {
            if (bwdToMatchingBracket()) {
                if (!moveToPreviousToken()) 
                  return(TRUE)
                next
            }
            previous <- peek(-1L)
            if (previous$value %in% "." || previous$type %in% 
                "identifier") {
                moveToPreviousToken()
                next
            }
            break
        }
        TRUE
    }
    list(tokenValue = tokenValue, tokenType = tokenType, tokenOffset = tokenOffset, 
        cursorOffset = cursorOffset, moveToNextToken = moveToNextToken, 
        moveToPreviousToken = moveToPreviousToken, fwdToMatchingBracket = fwdToMatchingBracket, 
        bwdToMatchingBracket = bwdToMatchingBracket, moveToOffset = moveToOffset, 
        moveRelative = moveRelative, peek = peek, find = find, 
        moveToStartOfEvaluation = moveToStartOfEvaluation)
}
<environment: 0x000001883f4b86b8>

$.rs.internalLintEngine
function (filePath) 
{
    if (!file.exists(filePath)) 
        return(list())
    filePath <- .rs.normalizePath(filePath, mustWork = TRUE)
    lint <- .rs.lintRFile(filePath)
    invisible(.rs.showLintMarkers(lint, filePath))
}
<environment: 0x000001883f4b86b8>

$.rs.resolveEnvironment
function (envir) 
{
    if (is.environment(envir)) 
        return(envir)
    if (is.numeric(envir)) 
        return(as.environment(envir))
    if (is.null(envir) || identical(envir, "")) 
        return(globalenv())
    index <- match(envir, search())
    if (!is.na(index)) 
        return(as.environment(index))
    if (substring(envir, 1L, 10L) == "namespace:") {
        package <- substring(envir, 11L)
        return(getNamespace(package))
    }
    getNamespace(envir)
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletionsTables
function (token, conn, ctx) 
{
    conn <- .rs.sql.asDBIConnection(conn)
    if (grepl(".", token, fixed = TRUE)) {
        parts <- .rs.strsplit(token, ".", fixed = TRUE)
        schema <- parts[[1]]
        token <- parts[[2]]
        tables <- .rs.tryCatch(.rs.db.listTables(conn, schema))
        if (inherits(tables, "error")) 
            return(.rs.emptyCompletions(language = "SQL"))
        results <- .rs.selectFuzzyMatches(tables, token)
        completions <- .rs.makeCompletions(token = token, results = results, 
            packages = "table", type = .rs.acCompletionTypes$DATAFRAME)
        return(completions)
    }
    tables <- as.character(ctx$tables)
    if (!is.null(conn)) {
        listedTables <- .rs.sql.listTables(conn)
        if (length(listedTables)) 
            tables <- listedTables
    }
    tables <- c(tables, names(ctx$aliases))
    tables <- setdiff(tables, token)
    results <- .rs.selectFuzzyMatches(tables, token)
    .rs.makeCompletions(token = token, results = results, packages = "table", 
        type = .rs.acCompletionTypes$DATAFRAME)
}
<environment: 0x000001883f4b86b8>

$.rs.discoverPackageDependencies
function (id, extension) 
{
    available <- .rs.availablePackages()
    if (is.null(available$value)) 
        return(character())
    contents <- .rs.readSourceDocument(id)
    if (is.null(contents)) 
        return(character())
    packages <- .rs.parsePackageDependencies(contents, extension)
    if (is.null(packages)) 
        return(character())
    if (identical(extension, ".Rmd") || identical(extension, 
        ".qmd")) 
        packages <- c("rmarkdown", packages)
    packages <- packages[packages %in% rownames(available$value)]
    installed <- list.files(.libPaths())
    missing <- setdiff(packages, installed)
    missing
}
<environment: 0x000001883f4b86b8>

$.rs.topicsEnv
<environment: 0x000001883f4e6f70>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.initializeDataViewer
function (server) 
{
    if (server) {
        .rs.registerReplaceHook("edit", "utils", function(original, 
            name, ...) {
            if (is.data.frame(name) || is.matrix(name)) 
                stop("Editing of data frames and matrixes is not supported in RStudio.", 
                  call. = FALSE)
            else original(name, ...)
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.create_aliased_path
function (path) 
{
    if (file.exists(path)) {
        return(.rs.scalar(.rs.createAliasedPath(normalizePath(path))))
    }
    else {
        return(.rs.scalar(""))
    }
}
<environment: 0x000001883f4b86b8>

$.rs.createMarkersFromLint
function (lint, file) 
{
    lapply(lint, function(x) {
        list(type = x$type, file = file, line = x$start.row, 
            column = x$start.column, message = x$message)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.beforePackageUnloaded
function (package) 
{
    for (namespaceName in loadedNamespaces()) {
        .rs.tryCatch({
            ns <- asNamespace(namespaceName)
            table <- ns[[".__S3MethodsTable__."]]
            as.list(table)
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.retrieveSecret
function (name) 
{
    if (!.rs.isPackageInstalled("keyring") || !.rs.hasSecret(name)) {
        NULL
    }
    else {
        keyring_get <- get("key_get", envir = asNamespace("keyring"))
        keyring_get(.rs.getSecretService(), username = name)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.userIdentity
function () 
{
    .Call("rs_userIdentity", PACKAGE = "(embedding)")
}
<environment: 0x000001883fe23638>

$.rs.connectionListObjects
function (type, host, ...) 
{
    connection <- .rs.findActiveConnection(type, host)
    if (!is.null(connection)) 
        connection$listObjects(...)
    else character()
}
<environment: 0x000001883f4b86b8>

$.rs.jsonProperty
function (name, value) 
{
    paste(sep = "", "\"", .rs.jsonEscapeString(enc2utf8(name)), 
        "\":\"", .rs.jsonEscapeString(enc2utf8(value)), "\"")
}
<environment: 0x000001883f4b86b8>

$.rs.api.removeTheme
function (name) 
{
    tryCatch(.rs.removeTheme(name, .rs.getThemes()), error = function(e) {
        stop("Unable to remove the theme \"", name, "\". ", e$message)
    })
}
<environment: 0x000001883f3f0350>

$.rs.dirExists
function (path) 
{
    utils::file_test("-d", path)
}
<environment: 0x000001883f4b86b8>

$.rs.getProjectDirectory
function () 
{
    .Call("rs_getProjectDirectory")
}
<environment: 0x000001883f4b86b8>

$.rs.rememberSecret
function (name, secret) 
{
    if (.rs.isPackageInstalled("keyring")) {
        keyring_set <- get("key_set_with_value", envir = asNamespace("keyring"))
        keyring_set(.rs.getSecretService(), username = name, 
            password = secret)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.replBusy
function (busy) 
{
    .rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$REPL_BUSY, 
        list(busy = .rs.scalar(busy)))
}
<environment: 0x000001883f4b86b8>

$.rs.getRChainCompletions
function (token, chainObjectName, additionalArgs, excludeArgs, 
    excludeArgsFromObject, envir) 
{
    result <- .rs.emptyCompletions()
    if (is.null(chainObjectName)) 
        return(result)
    if (.rs.isDataTableExtractCall(chainObjectName, envir = envir)) 
        return(result)
    object <- .rs.getAnywhere(chainObjectName, envir = envir)
    if (inherits(object, "python.builtin.object")) 
        return(result)
    if (length(additionalArgs)) {
        additionalArgsCompletions <- .rs.makeCompletions(token = token, 
            results = .rs.selectFuzzyMatches(additionalArgs, 
                token), packages = paste0(chainObjectName, " %>% ..."), 
            type = .rs.acCompletionTypes$COLUMN)
        result <- .rs.appendCompletions(result, additionalArgsCompletions)
    }
    if (!excludeArgsFromObject && .rs.hasColumns(object)) {
        columnCompletions <- .rs.makeCompletions(token = token, 
            results = .rs.selectFuzzyMatches(setdiff(.rs.getNames(object), 
                additionalArgs), token), packages = chainObjectName, 
            quote = FALSE, type = .rs.acCompletionTypes$COLUMN)
        result <- .rs.appendCompletions(result, columnCompletions)
    }
    if (length(excludeArgs)) {
        indices <- which(!(result$results %in% excludeArgs))
        result <- .rs.subsetCompletions(result, indices)
    }
    result
}
<bytecode: 0x000001883c185d08>
<environment: 0x000001883f4b86b8>

$.rs.rpc.python_find_interpreters
function () 
{
    .rs.python.findPythonInterpreters()
}
<environment: 0x000001883f4b86b8>

$.rs.restorePreviousPath
function () 
{
    .Call("rs_restorePreviousPath", PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.breakOnUserError
function () 
{
    .rs.breakOnError(TRUE)
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE
attr(,"errorHandlerType")
[1] "break"

$.rs.finishExpression
function (string) 
{
    .Call("rs_finishExpression", as.character(string))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_help_at_cursor
function (line, cursorPos) 
{
    token <- .rs.guessToken(line, cursorPos)
    if (token == "") 
        return()
    pieces <- strsplit(token, ":{2,3}")[[1]]
    if ("devtools_shims" %in% search() && "devtools" %in% loadedNamespaces() && 
        exists("shim_help", envir = asNamespace("devtools"))) {
        help <- devtools:::shim_help
    }
    else {
        help <- utils::help
    }
    capture.output(suppressMessages({
        if (length(pieces) > 1) {
            print(help(pieces[2], package = pieces[1], help_type = "html"))
        }
        else {
            helpUrl <- .rs.getCustomHelpUrl(token)
            if (!is.null(helpUrl)) {
                if (nzchar(helpUrl)) 
                  utils::browseURL(helpUrl)
            }
            else {
                print(help(pieces[1], help_type = "html", try.all.packages = TRUE))
            }
        }
    }))
}
<environment: 0x000001883f4b86b8>

$.rs.nrow
function (x) 
{
    rows <- 0
    tryCatch({
        rows <- NROW(x)
    }, error = function(e) {
        stop("Failed to determine rows for object of class '", 
            class(x), "': ", e$message)
    })
    if (is.null(rows)) 
        0
    else rows
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.transform_snippet
function (snippet) 
{
    Encoding(snippet) <- "UTF-8"
    reRCode <- "`[Rr]\\s+[^`]+`"
    matches <- gregexpr(reRCode, snippet, perl = TRUE)[[1]]
    if (identical(c(matches), -1L)) 
        return(snippet)
    match.length <- attr(matches, "match.length")
    if (is.null(match.length)) 
        return(snippet)
    ranges <- lapply(seq_along(matches), function(i) {
        c(matches[[i]], matches[[i]] + match.length[[i]])
    })
    extracted <- lapply(ranges, function(range) {
        substring(snippet, range[[1]] + 2, range[[2]] - 2)
    })
    frame <- parent.frame()
    evaluated <- lapply(extracted, function(code) {
        tryCatch({
            captured <- capture.output(result <- paste(collapse = " ", 
                as.character(suppressWarnings(eval(parse(text = code), 
                  envir = frame)))))
            if (!length(result) && length(captured)) 
                paste(captured, collapse = " ")
            else result
        }, error = function(e) "")
    })
    newSnippet <- snippet
    for (i in seq_along(evaluated)) {
        range <- ranges[[i]]
        text <- substring(snippet, range[[1]], range[[2]] - 1)
        replacement <- evaluated[[i]]
        newSnippet <- gsub(text, replacement, newSnippet, fixed = TRUE)
    }
    .rs.scalar(newSnippet)
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.setHtmlCaptureContext
function (...) 
{
    .rs.setVar("rnb.htmlCaptureContext", list(...))
}
<environment: 0x000001883f4b86b8>

$.rs.surround
function (string, with) 
{
    paste(with, string, with, sep = "")
}
<environment: 0x000001883f4b86b8>

$.rs.packageNewsURLsEnv
<environment: 0x000001883fe0d780>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.python.keywords
function () 
{
    keywords <- .rs.getVar("python.keywordList")
    if (length(keywords)) 
        return(keywords)
    keyword <- reticulate::import("keyword", convert = TRUE)
    kwlist <- keyword$kwlist
    .rs.setVar("python.keywordList", kwlist)
    kwlist
}
<environment: 0x000001883f4b86b8>

$.rs.saveGraphics
function (filename) 
{
    plot <- grDevices::recordPlot()
    save(plot, file = filename)
}
<environment: 0x000001883f4b86b8>

$.rs.formatDataColumnNumeric
function (col, ...) 
{
    storage.mode(col) <- "double"
    naVals <- is.na(col)
    vals <- format(col, trim = TRUE, justify = "none", ...)
    if (any(naVals)) 
        vals[naVals] <- col[naVals]
    vals
}
<environment: 0x000001883f4b86b8>

$.rs.handleNotebookError
function () 
{
    .rs.recordTraceback(FALSE, 2, function(err) {
        .Call("rs_recordNotebookError", err)
    })
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE
attr(,"errorHandlerType")
[1] 4

$.rs.loadUserCommands
function (keybindingPath) 
{
    env <- new.env(parent = globalenv())
    env$registerUserCommand <- .rs.registerUserCommand
    paths <- c("~/.R/keybindings", keybindingPath)
    for (path in paths) {
        files <- list.files(file.path(path, "R"), full.names = TRUE)
        lapply(files, function(file) {
            source(file, local = env)
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.objectClass
function (object) 
{
    .Call("rs_objectClass", object, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.availableRSymbols
function () 
{
    unlist(c(.rs.objectsOnSearchPath(excludeGlobalEnv = TRUE), 
        .rs.getVar("r.keywords")))
}
<environment: 0x000001883f4b86b8>

$.rs.getThemeDirFromUrl
function (url) 
{
    decodedUrl <- URLdecode(url)
    if (.rs.isGlobalTheme(decodedUrl)) {
        file.path(.rs.getThemeInstallDir(TRUE), basename(decodedUrl))
    }
    else if (.rs.isLocalTheme(decodedUrl)) {
        .Call("rs_getLocalThemePath", basename(decodedUrl), PACKAGE = "(embedding)")
    }
    else {
        NULL
    }
}
<environment: 0x000001883f4b86b8>

$.rs.makeHelpCall
function (topic, package = NULL, help_type = "html") 
{
    substitute(utils::help(TOPIC, package = PACKAGE, help_type = "html"), 
        list(TOPIC = topic, PACKAGE = package))
}
<environment: 0x000001883f4b86b8>

$.rs.isPackageLoaded
function (packageName, libName) 
{
    if (packageName %in% .packages()) {
        packagePath <- .rs.pathPackage(packageName, quiet = TRUE)
        packagePath <- .rs.createAliasedPath(packagePath)
        .rs.scalar(identical(packagePath, paste(libName, packageName, 
            sep = "/")))
    }
    else .rs.scalar(FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsAttr
function (token, functionCall, envir) 
{
    result <- tryCatch({
        wrapper <- function(x, which, exact = FALSE) {
        }
        matched <- .rs.matchCall(wrapper, functionCall)
        if (is.null(matched[["x"]])) 
            return(.rs.emptyCompletions())
        objectExpr <- matched[["x"]]
        objectName <- capture.output(print(objectExpr))
        object <- eval(objectExpr, envir = envir)
        completions <- .rs.selectFuzzyMatches(names(attributes(object)), 
            token)
        result <- .rs.makeCompletions(token, completions, paste("attributes(", 
            objectName, ")", sep = ""), quote = TRUE, type = .rs.acCompletionTypes$STRING)
    }, error = function(e) .rs.emptyCompletions())
    result
}
<environment: 0x000001883f4b86b8>

$.rs.readPackageDescription
function (packagePath) 
{
    metapath <- file.path(packagePath, "Meta/package.rds")
    if (file.exists(metapath)) {
        metadata <- readRDS(metapath)
        return(as.list(metadata$DESCRIPTION))
    }
    descPath <- file.path(packagePath, "DESCRIPTION")
    read.dcf(descPath, all = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.python.initialize
function (projectDir) 
{
    activate <- .rs.readUiPref("python_project_environment_automatic_activate")
    if (!identical(activate, TRUE)) 
        return()
    pythonPath <- .rs.python.configuredInterpreterPath(projectDir)
    if (!file.exists(pythonPath)) 
        return()
    pythonPath <- file.path(normalizePath(dirname(pythonPath), 
        winslash = "/", mustWork = FALSE), basename(pythonPath))
    pythonBin <- dirname(pythonPath)
    .rs.prependToPath(pythonBin)
    scriptsPath <- file.path(pythonBin, "Scripts")
    if (file.exists(scriptsPath)) 
        .rs.prependToPath(scriptsPath)
    pythonInfo <- .rs.python.getPythonInfo(pythonPath, strict = TRUE)
    if (identical(pythonInfo$type, "virtualenv")) {
        envPath <- dirname(dirname(pythonPath))
        Sys.setenv(VIRTUAL_ENV = envPath)
    }
    if (identical(pythonInfo$type, "conda")) {
        condaPrefix <- pythonBin
        if (!.rs.platform.isWindows) 
            condaPrefix <- dirname(condaPrefix)
        Sys.setenv(CONDA_PREFIX = condaPrefix)
        condaPath <- .rs.python.findCondaForEnvironment(condaPrefix)
        if (file.exists(condaPath)) 
            .rs.prependToPath(dirname(condaPath))
    }
    Sys.setenv(RETICULATE_PYTHON_FALLBACK = pythonPath)
    invisible(pythonPath)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectDefault
function (object, context = .rs.explorer.createContext()) 
{
    children <- NULL
    if (context$recursive && !is.null(names(object))) {
        names <- names(object)
        indices <- .rs.slice(seq_along(object), context$start, 
            context$end)
        context$more <- length(object) > context$end
        children <- lapply(indices, function(i) {
            if (is.null(names) || !nzchar(names[[i]])) {
                name <- sprintf("[[%i]]", i)
                access <- sprintf("#[[%i]]", i)
                tags <- .rs.explorer.tags$VIRTUAL
            }
            else {
                name <- names[[i]]
                access <- sprintf("#[[\"%s\"]]", name)
                tags <- character()
            }
            childContext <- .rs.explorer.createChildContext(context, 
                name, access, tags)
            .rs.explorer.inspectObject(object[[i]], childContext)
        })
    }
    .rs.explorer.createInspectionResult(object, context, children)
}
<environment: 0x000001883f4b86b8>

$.rs.WorkingDataEnv
<environment: 0x000001883ecd5650>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.notebookChunkCallbacks
<environment: 0x000001883fcd2b70>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.saveEnvironment
function (env, filename) 
{
    suppressWarnings(save(list = ls(envir = env, all.names = TRUE), 
        file = filename, envir = env))
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.updateSetting
function (content, newValue, cssClass, settingName) 
{
    classPat <- paste0("\\.", cssClass, "( *){")
    if (any(grepl(classPat, content, perl = TRUE))) {
        settingName <- paste0(settingName, ":")
        blockLoc <- grep(classPat, content, perl = TRUE)
        newLine <- paste0("  ", settingName, " ", newValue, ";")
        settingPat <- paste0("(^| )", settingName)
        if (!any(grepl(settingPat, content, perl = TRUE))) {
            settingLoc <- grep("}", content, perl = TRUE)
            loc <- settingLoc[settingLoc > blockLoc][1]
            content <- c(content[1:loc - 1], newLine, content[loc:length(content)])
        }
        else {
            settingLoc <- grep(settingPat, content, perl = TRUE)
            loc <- settingLoc[settingLoc > blockLoc][1]
            content[loc] <- newLine
        }
    }
    content
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.types
$.rs.explorer.types$NEW
[1] "new"

$.rs.explorer.types$OPEN_NODE
[1] "open_node"

$.rs.explorer.types$CLOSE_NODE
[1] "close_node"

$.rs.explorer.types$REFRESH
[1] "refresh"

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.rpc.explorer_inspect_object
function (id, extractingCode, name, access, tags, start) 
{
    object <- .rs.explorer.getCachedObject(id = id, extractingCode = extractingCode, 
        refresh = FALSE)
    context <- .rs.explorer.createContext(name = name, access = access, 
        tags = tags, recursive = 1, start = start + 1, end = start + 
            .rs.explorer.defaultRowLimit)
    result <- .rs.explorer.inspectObject(object, context)
    result
}
<environment: 0x000001883f4b86b8>

$.rs.defaultLibPathIsWriteable
function () 
{
    .rs.isLibraryWriteable(.libPaths()[1L])
}
<environment: 0x000001883f4b86b8>

$.rs.api.setPersistentValue
function (name, value) 
{
    invisible(.Call("rs_setPersistentValue", name, value))
}
<environment: 0x000001883fd66380>

$.rs.resolveAliasedSymbol
function (object) 
{
    if (!is.function(object)) 
        return(object)
    if (is.primitive(object)) 
        return(object)
    body <- body(object)
    if (is.symbol(body)) 
        return(object)
    env <- environment(object)
    if (length(body) && .rs.isSymbolCalled(body[[1]], ".rs.callAs")) 
        return(env$original)
    return(object)
}
<environment: 0x000001883f4b86b8>

$.rs.escapeForRegex
function (regex) 
{
    gsub("([\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.\\,\\\\\\^\\$\\|\\#\\s])", 
        "\\\\\\1", regex, perl = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.formatRowNames
function (x, start, len) 
{
    if (is.data.frame(x)) {
        info <- .row_names_info(x, type = 0L)
        if (is.integer(info) && length(info) > 0 && is.na(info[[1]])) {
            n <- abs(info[[2]])
            range <- seq(from = start, to = min(n, start + len))
            return(as.character(range))
        }
    }
    rownames <- row.names(x)
    rownames[start:min(length(rownames), start + len)]
}
<environment: 0x000001883f4b86b8>

$.rs.activeConnections
<environment: 0x000001883dc7e868>

$.rs.readUserState
function (stateName) 
{
    if (missing(stateName) || is.null(stateName)) 
        stop("No state name supplied")
    .Call("rs_readUserState", stateName, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.regexMatches
function (pattern, x) 
{
    matches <- gregexpr(pattern, x, perl = TRUE)[[1]]
    starts <- attr(matches, "capture.start")
    ends <- starts + attr(matches, "capture.length") - 1
    substring(x, starts, ends)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.preview_sql
function (code) 
{
    onError <- function(reason) {
        .rs.scalar(.rs.truncate(reason))
    }
    parsed <- .rs.tryCatch(parse(text = code)[[1]])
    if (inherits(parsed, "error")) 
        return(onError("Failed to parse SQL preview comment."))
    for (i in seq_along(parsed)) if (identical(parsed[[i]], quote(expr = ))) 
        parsed[i] <- list(NULL)
    matched <- .rs.tryCatch(match.call(.rs.previewSql, parsed))
    if (inherits(matched, "error")) 
        return(onError("Unexpected SQL preview comment."))
    if (is.null(matched$conn)) 
        return(onError("No connection was specified in SQL preview comment."))
    status <- .rs.tryCatch(eval(parsed, envir = globalenv()))
    if (inherits(status, "error")) 
        return(onError(conditionMessage(status)))
    invisible(status)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_auth_token
function (name) 
{
    .rs.scalarListFromList(rsconnect:::getAuthToken(server = name))
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleRegistryDelete
function (path) 
{
    system2("REG", args = list("DELETE", shQuote(path), "/f"))
    identical(ret, 0L)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_deployment_files
function (target, asMultipleDoc, quartoSrcFile) 
{
    .rs.rsconnectDeployList(target, asMultipleDoc, quartoSrcFile)
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.knit_image_paths
function (x, ...) 
{
    .Call("rs_recordExternalPlot", vapply(x, function(path) {
        dest <- tempfile(fileext = paste(".", tools::file_ext(path), 
            sep = ""))
        if (identical(substr(path, 1, 7), "http://") || identical(substr(path, 
            1, 8), "https://")) {
            tryCatch({
                suppressMessages(download.file(path, dest, quiet = TRUE))
            }, error = function(e) {
            })
        } else {
            file.copy(path, dest, copy.mode = FALSE)
        }
        dest
    }, ""))
}
<environment: 0x000001883f4b86b8>

$.rs.setVar
function (name, var) 
{
    envir <- .rs.toolsEnv()
    fullName <- paste(".rs.", name, sep = "")
    environment(var) <- envir
    assign(fullName, var, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.attachConflicts
function (envirs) 
{
    if ("conflicted" %in% loadedNamespaces()) {
        tryCatch(conflicted:::conflicts_register(), error = function(e) {
            .rs.logErrorMessage(conditionMessage(e))
        })
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getIndexedFilesAndFolders
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L) 
{
    .rs.doGetIndex(term, inDirectory, maxCount, .rs.listIndexedFilesAndFolders)
}
<environment: 0x000001883f4b86b8>

$.rs.shinyServerCompletions
function (file) 
{
    fileCacheName <- paste(file, "shinyServerLastModifiedTime", 
        sep = "-")
    completionsCacheName <- paste(file, "shinyServerCompletions", 
        sep = "-")
    info <- .rs.fileInfo(file)
    mtime <- info[1, "mtime"]
    if (identical(mtime, .rs.get(fileCacheName)) && !is.null(.rs.get(completionsCacheName))) {
        return(.rs.get(completionsCacheName))
    }
    parsed <- tryCatch(suppressWarnings(parse(file)), error = function(e) NULL)
    if (is.null(parsed)) 
        return(NULL)
    inputEnv <- new.env(parent = emptyenv())
    outputEnv <- new.env(parent = emptyenv())
    inputCount <- new.env(parent = emptyenv())
    inputCount$count <- 1
    outputCount <- new.env(parent = emptyenv())
    outputCount$count <- 1
    lapply(parsed, function(object) {
        .rs.doShinyServerCompletions(object, inputEnv, outputEnv, 
            inputCount, outputCount)
    })
    completions <- list(input = unlist(mget(objects(inputEnv), 
        envir = inputEnv), use.names = FALSE), output = unlist(mget(objects(outputEnv), 
        envir = outputEnv), use.names = FALSE))
    .rs.assign(fileCacheName, mtime)
    .rs.assign(completionsCacheName, completions)
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.findTutorialsImpl
function (tutorialDir) 
{
    tutorialFiles <- list.files(tutorialDir, pattern = "[.]Rmd$", 
        full.names = TRUE, ignore.case = TRUE)
    if (length(tutorialFiles) == 0) 
        return(NULL)
    tutorialFile <- tutorialFiles[[1]]
    contents <- readLines(tutorialFile, encoding = "UTF-8", warn = FALSE)
    reYamlSeparator <- "^\\s*(?:---|[.][.][.])\\s*$"
    yamlSeparators <- grep(reYamlSeparator, contents)
    if (length(yamlSeparators) == 0) 
        return(NULL)
    yamlRange <- seq.int(from = yamlSeparators[[1]] + 1, length.out = yamlSeparators[[2]] - 
        yamlSeparators[[1]] - 1)
    yamlCode <- paste(contents[yamlRange], collapse = "\n")
    yaml <- .Call("rs_fromYAML", yamlCode, PACKAGE = "(embedding)")
    title <- .rs.nullCoalesce(yaml$title, "")
    desc <- .rs.nullCoalesce(yaml$description, "")
    list(name = .rs.scalar(basename(tutorialDir)), file = .rs.scalar(tutorialFile), 
        title = .rs.scalar(title), description = .rs.scalar(desc))
}
<environment: 0x000001883f4b86b8>

$.rs.getRSConnectDeployments
function (path, rpubsUploadId) 
{
    deploymentsFrame <- data.frame(name = character(0), account = character(0), 
        server = character(0), bundleId = character(0), appId = character(0), 
        asStatic = logical(0), hostUrl = character(0), username = character(0), 
        when = numeric(0))
    deployments <- list()
    servers <- data.frame(name = character(0), url = character(0))
    accounts <- data.frame(name = character(0), server = character(0))
    tryCatch({
        deploymentsFrame <- rsconnect::deployments(appPath = path, 
            excludeOrphaned = FALSE)
        deployments <- .rs.scalarListFromFrame(deploymentsFrame)
        servers <- rsconnect::servers()
        accounts <- rsconnect::accounts()
    }, error = function(e) {
    })
    if (nrow(deploymentsFrame) > 0) {
        servers <- servers[as.character(servers$name) %in% as.character(accounts$server), 
            ]
        urls <- as.character(servers[["url"]])
        names <- c(as.character(servers[["name"]]), "rpubs.com")
        deploymentsFrame <- cbind(deploymentsFrame, list(serverRegistered = as.character(deploymentsFrame[["server"]]) %in% 
            names | as.character(deploymentsFrame[["hostUrl"]]) %in% 
            urls))
        deployments <- .rs.scalarListFromFrame(deploymentsFrame)
    }
    if (!is.character(rpubsUploadId) || nchar(rpubsUploadId) == 
        0) {
        return(deployments)
    }
    if ("rpubs.com" %in% deployments$server) {
        return(deployments)
    }
    rpubsDeployment <- list()
    for (col in colnames(deploymentsFrame)) {
        if (col == "name") 
            rpubsDeployment[col] = ""
        else if (col == "account") 
            rpubsDeployment[col] = "rpubs"
        else if (col == "server") 
            rpubsDeployment[col] = "rpubs.com"
        else if (col == "appId") 
            rpubsDeployment[col] = rpubsUploadId
        else if (col == "bundleId") 
            rpubsDeployment[col] = rpubsUploadId
        else if (col == "asStatic") 
            rpubsDeployment[col] = TRUE
        else if (col == "when") 
            rpubsDeployment[col] = 0
        else if (col == "hostUrl") 
            rpubsDeployment[col] = "rpubs.com"
        else if (col == "username") 
            rpubsDeployment[col] = "rpubs"
        else rpubsDeployment[col] = NA
    }
    c(deployments, list(.rs.scalarListFromList(rpubsDeployment)))
}
<environment: 0x000001883f4b86b8>

$.rs.api.sendToConsole
function (code, echo = TRUE, execute = TRUE, focus = TRUE, animate = FALSE) 
{
    if (!is.character(code)) 
        stop("'code' should be a character vector", call. = FALSE)
    code <- paste(code, collapse = "\n")
    data <- list(code = .rs.scalar(code), echo = .rs.scalar(as.logical(echo)), 
        execute = .rs.scalar(as.logical(execute)), focus = .rs.scalar(as.logical(focus)), 
        animate = .rs.scalar(as.logical(animate)), language = "R")
    .rs.enqueClientEvent("send_to_console", data)
    invisible(data)
}
<environment: 0x000001883fd30f38>

$.rs.scriptActions
function () 
{
    list(stop = function(id) {
        .Call("rs_stopScriptJob", id, PACKAGE = "(embedding)")
    }, replay = function(id) {
        .Call("rs_replayScriptJob", id, PACKAGE = "(embedding)")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.slice
function (object, start = 1, end = length(object)) 
{
    n <- length(object)
    if (n == 0) 
        return(object)
    if (start < 0) 
        start <- n + start
    if (end < 0) 
        end <- n + end
    start <- max(1, start)
    end <- min(n, end)
    if (start > end) 
        return(object[0])
    return(object[start:end])
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.html
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    htmlfile <- tempfile("_rs_html_", tmpdir = ctx$outputFolder, 
        fileext = ".html")
    depfile <- tempfile("_rs_html_deps_", tmpdir = ctx$outputFolder, 
        fileext = ".json")
    rendered <- htmltools::renderTags(x)
    htmldeps <- rendered$dependencies
    html <- rendered$html
    if (length(htmldeps)) {
        cat(.rs.toJSON(htmldeps, unbox = TRUE), file = depfile, 
            sep = "\n")
        htmltools::save_html(x, file = htmlfile, libdir = ctx$libraryFolder)
    }
    else {
        cat(as.character(html), file = htmlfile, sep = "\n")
    }
    .rs.recordHtmlWidget(x, htmlfile, depfile)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.default_sql_connection_name
function () 
{
    dbiClassNames <- lapply(methods::.S4methods("dbGetQuery"), 
        function(methodInfo) {
            methodInfoSplit <- strsplit(methodInfo, split = ",")[[1]]
            methodInfoSplit[[2]]
        })
    dbiObjectNames <- Filter(function(objName) {
        any(class(get(objName, envir = globalenv())) %in% dbiClassNames)
    }, ls(envir = globalenv()))
    if (length(dbiObjectNames) > 0) 
        .rs.scalar(dbiObjectNames[[1]])
    else NULL
}
<environment: 0x000001883f4b86b8>

$.rs.toDataFrame
function (x, name, flatten) 
{
    if (inherits(x, "data.table")) 
        x <- as.data.frame(x)
    if (!is.data.frame(x)) {
        frame <- NULL
        tryCatch({
            `__RSTUDIO_VIEWER_COLUMN__` <- x
            frame <- eval(substitute(as.data.frame(`__RSTUDIO_VIEWER_COLUMN__`, 
                optional = TRUE)), envir = globalenv())
        }, error = function(e) {
        })
        if (!is.null(frame) && !is.null(names(frame))) 
            names(frame)[names(frame) == "__RSTUDIO_VIEWER_COLUMN__"] <- name
        x <- frame
    }
    if (is.data.frame(x)) {
        if (is.null(names(x))) 
            names(x) <- paste("V", seq_along(x), sep = "")
        if (flatten) {
            x <- .rs.flattenFrame(x)
        }
        return(x)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.newDesktopGraphicsDevice
function () 
{
    sysName <- Sys.info()[["sysname"]]
    if (identical(sysName, "Windows")) 
        windows()
    else if (identical(sysName, "Darwin")) 
        quartz()
    else if (capabilities("X11")) 
        X11()
    else {
        warning("Unable to create a new graphics device ", "(RStudio device already active and only a ", 
            "single RStudio device is supported)", call. = FALSE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getInferredCompletions
function (packages = character(), simplify = TRUE) 
{
    completionList <- .Call("rs_getInferredCompletions", as.character(packages), 
        PACKAGE = "(embedding)")
    completionList <- lapply(completionList, function(completion) {
        datasetTypes <- rep.int(.rs.acCompletionTypes$DATASET, 
            length(completion$datasets))
        completion$exports <- c(completion$exports, completion$datasets)
        completion$types <- c(completion$types, datasetTypes)
        completion$datasets <- NULL
        completion
    })
    if (simplify && length(completionList) == 1) 
        return(completionList[[1]])
    completionList
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.preview_data_import_clean
function (dataImportOptions) 
{
    tryCatch({
        if (!identical(dataImportOptions$localFiles, NULL)) {
            lapply(dataImportOptions$localFiles, function(e) {
                file.remove(paste(e))
            })
            dataImportOptions
        }
    }, error = function(e) {
        return(list(error = e))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.createAliasedPath
function (path) 
{
    homeDir <- path.expand("~/")
    homePathIdx <- substr(path, 1, nchar(homeDir)) == homeDir
    homePaths <- path[homePathIdx]
    path[homePathIdx] <- paste("~", substr(homePaths, nchar(homeDir), 
        nchar(homePaths)), sep = "")
    path
}
<environment: 0x000001883f4b86b8>

$.rs.extractNativeSymbols
function (DLL, collapse = TRUE) 
{
    info <- getDLLRegisteredRoutines(DLL)
    result <- lapply(info, function(routine) {
        as.character(names(routine))
    })
    if (collapse) 
        result <- as.character(unlist(result))
    result
}
<environment: 0x000001883f4b86b8>

$.rs.connectionReadOdbcEntry
function (drivers, uniqueDriverNames, driver) 
{
    tryCatch({
        currentDriver <- drivers[drivers$attribute == "Driver" & 
            drivers$name == driver, ]
        driverInstaller <- drivers[drivers$attribute == "Installer" & 
            drivers$name == driver, ]
        driverId <- gsub(.rs.connectionOdbcRStudioDriver(), "", 
            driver)
        basePath <- sub(paste(tolower(driver), ".*$", sep = ""), 
            "", currentDriver$value)
        snippetsFile <- file.path(basePath, tolower(driver), 
            "snippets", paste(tolower(driverId), ".R", sep = ""))
        if (identical(file.exists(snippetsFile), TRUE)) {
            snippet <- paste(readLines(snippetsFile), collapse = "\n")
        }
        else {
            snippet <- paste("library(DBI)\n", "con <- dbConnect(odbc::odbc(), .connection_string = \"", 
                "Driver={", driver, "};${1:Parameters}\", timeout = 10)", 
                sep = "")
        }
        licenseFile <- file.path(dirname(currentDriver$value), 
            "license.lock")
        iconData <- .Call("rs_connectionIcon", driverId)
        if (nchar(iconData) == 0) 
            iconData <- .Call("rs_connectionIcon", "ODBC")
        hasInstaller <- identical(driverInstaller$value, "RStudio")
        warningMessage <- NULL
        if (hasInstaller) {
            installerVersion <- .rs.connectionInstallerInfo(driverId)$version
            currentVersion <- drivers[drivers$attribute == "Version" & 
                drivers$name == driver, ]
            if (nrow(currentVersion) == 1) {
                if (compareVersion(installerVersion, currentVersion$value) > 
                  0) {
                  warningMessage <- "A new driver version is available, to upgrade, uninstall and then reinstall."
                }
            }
        }
        list(package = .rs.scalar(NULL), version = .rs.scalar(NULL), 
            name = .rs.scalar(driver), type = .rs.scalar("Snippet"), 
            snippet = .rs.scalar(snippet), help = .rs.scalar(NULL), 
            iconData = .rs.scalar(iconData), licensed = .rs.scalar(identical(file.exists(licenseFile), 
                TRUE)), source = .rs.scalar("ODBC"), hasInstaller = .rs.scalar(hasInstaller), 
            warning = .rs.scalar(warningMessage), installer = .rs.scalar(driverInstaller$value))
    }, error = function(e) {
        warning(e$message)
        NULL
    })
}
<environment: 0x000001883f4b86b8>

$.rs.parsePackageDependencies
function (contents, extension) 
{
    code <- if (identical(extension, ".R")) 
        contents
    else if (identical(extension, ".Rmd")) 
        .rs.extractRCode(contents, "^[\t >]*```+\\s*\\{[Rr]\\b.*\\}\\s*$", 
            "^[\t >]*```+\\s*$")
    else if (identical(extension, ".Rnw")) 
        .rs.extractRCode(contents, "^\\s*<<(.*)>>=.*$", "^\\s*@\\s*(%+.*|)$")
    else if (identical(extension, ".qmd")) 
        .rs.extractRCode(contents, "^[\t >]*```+\\s*\\{[Rr]\\b.*\\}\\s*$", 
            "^[\t >]*```+\\s*$")
    if (is.null(code)) 
        return(NULL)
    if (identical(gsub("\n", "", code), .rs.scalar("")) && identical(extension, 
        ".qmd")) 
        return(NULL)
    parsed <- .rs.tryCatch(parse(text = code, encoding = "UTF-8"))
    if (inherits(parsed, "error")) {
        if (getRversion() < "3.5.2") 
            Sys.setlocale()
        return(character())
    }
    discoveries <- new.env(parent = emptyenv())
    if (identical(extension, ".Rmd") && is.null(dynGet("__NameSpacesLoading__", 
        NULL)) && requireNamespace("rmarkdown", quietly = TRUE) && 
        requireNamespace("yaml", quietly = TRUE)) {
        partitions <- rmarkdown:::partition_yaml_front_matter(strsplit(x = contents, 
            split = "\n", fixed = TRUE)[[1]])
        front_matter <- partitions[["front_matter"]]
        if (!is.null(front_matter)) {
            front <- NULL
            tryCatch({
                front <- yaml::read_yaml(text = front_matter, 
                  eval.expr = TRUE)
            }, error = function(e) {
            })
            output <- NULL
            if (!is.null(names(front[["output"]]))) {
                output <- names(front[["output"]])[[1]]
            }
            else if (is.character(front[["output"]])) {
                output <- front[["output"]]
            }
            if (!is.null(output)) {
                format <- unlist(strsplit(output, "::"))
                if (length(format) > 1) {
                  discoveries[[format[[1]]]] <- TRUE
                }
            }
            runtime <- front[["runtime"]]
            server <- front[["server"]]
            params <- front[["params"]]
            if (identical(runtime, "shiny") || identical(runtime, 
                "shinyrmd") || identical(runtime, "shiny_prerendered") || 
                identical(server, "shiny") || (is.list(server) && 
                identical(server[["type"]], "shiny")) || !is.null(params)) {
                discoveries[["shiny"]] <- TRUE
            }
        }
    }
    handleLibraryRequireCall <- function(node) {
        if (!is.call(node)) 
            return(FALSE)
        isLibraryOrRequire <- identical(node[[1]], as.name("library")) || 
            identical(node[[1]], as.name("require"))
        if (!isLibraryOrRequire) 
            return(FALSE)
        matched <- .rs.tryCatch(match.call(base::library, node))
        if (inherits(matched, "error")) 
            return(FALSE)
        isPackageArgumentString <- is.character(matched$package) && 
            length(matched$package) == 1
        if (isPackageArgumentString) {
            discoveries[[matched$package]] <<- TRUE
            return(TRUE)
        }
        isSafeSymbolLibraryCall <- is.symbol(matched$package) && 
            (is.null(matched$character.only) || identical(matched$character.only, 
                FALSE))
        if (isSafeSymbolLibraryCall) {
            discoveries[[as.character(matched$package)]] <<- TRUE
            return(TRUE)
        }
        FALSE
    }
    handleRequireNamespaceCall <- function(node) {
        if (!is.call(node)) 
            return(FALSE)
        if (!identical(node[[1]], as.name("requireNamespace"))) 
            return(FALSE)
        matched <- .rs.tryCatch(match.call(base::requireNamespace, 
            node))
        if (inherits(matched, "error")) 
            return(FALSE)
        if (is.character(matched$package) && length(matched$package == 
            1)) {
            discoveries[[matched$package]] <<- TRUE
            return(TRUE)
        }
        FALSE
    }
    handleColonCall <- function(node) {
        if (!is.call(node)) 
            return(FALSE)
        isColonCall <- length(node) == 3 && (identical(node[[1]], 
            as.name("::")) || identical(node[[1]], as.name(":::")))
        if (!isColonCall) 
            return(FALSE)
        package <- node[[2L]]
        if (is.symbol(package)) 
            package <- as.character(package)
        if (!is.character(package) || length(package) != 1) 
            return(FALSE)
        discoveries[[package]] <<- TRUE
        TRUE
    }
    .rs.recursiveWalk(parsed, function(node) {
        handleLibraryRequireCall(node) || handleColonCall(node) || 
            handleRequireNamespaceCall(node)
    })
    ls(envir = discoveries)
}
<environment: 0x000001883f4b86b8>

$.rs.addCachedData
function (obj, objName) 
{
    cacheKey <- .Call("rs_generateShortUuid")
    .rs.assignCachedData(cacheKey, obj, objName)
    cacheKey
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleRegistryAdd
function (entries) 
{
    validateEntry <- function(entry) {
        tryCatch({
            verify <- readRegistry(entry$path, "HLM", view = .rs.odbcOsBitness())
            identical(verify[[entry$key]], entry$value)
        }, error = function(e) {
            FALSE
        })
    }
    odbcFileEscape <- function(value) {
        gsub("\\\\", "\\\\\\\\", value)
    }
    if (all(sapply(entries, function(e) validateEntry(e)))) 
        return()
    bitness <- .rs.odbcOsBitness()
    allAdded <- TRUE
    for (entry in entries) {
        fullPath <- file.path("HKEY_LOCAL_MACHINE", entry$path, 
            fsep = "\\")
        system2("REG", args = list("ADD", shQuote(fullPath), 
            "/v", shQuote(entry$key), "/t", "REG_SZ", "/d", shQuote(entry$value), 
            "/f", paste("/reg:", bitness, sep = "")), stdout = getOption("odbc.installer.verbose", 
            FALSE), stderr = getOption("odbc.installer.verbose", 
            FALSE))
        if (!validateEntry(entry)) {
            allAdded <- FALSE
            break
        }
    }
    if (!allAdded) {
        if (.rs.odbcIsWow()) {
            stop("Failed to install x86 driver in x64 machine, retry running as administrator.")
        }
        message("Could not add registry keys from R, retrying using registry prompt.")
        addReg <- tempfile(fileext = ".reg")
        lineEntries <- sapply(entries, function(entry) {
            fullPath <- file.path("HKEY_LOCAL_MACHINE", entry$path, 
                fsep = "\\")
            c(paste("[", fullPath, "]", sep = ""), paste("\"", 
                entry$key, "\"=\"", odbcFileEscape(entry$value), 
                "\"", sep = ""), "")
        })
        lines <- c("REGEDIT4", "", lineEntries)
        writeLines(lines, addReg)
        message("Waiting for ", addReg, " to be registered.")
        system2("explorer", addReg)
        allEntriesValid <- function() {
            all(sapply(entries, function(e) validateEntry(e)))
        }
        registryStart <- Sys.time()
        registryWait <- 30
        while (!allEntriesValid() && Sys.time() < registryStart + 
            registryWait) {
            Sys.sleep(1)
            cat(".")
        }
        if (!allEntriesValid()) {
            stop("Failed to add all registry keys using registry file.")
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.check_for_package_updates
function () 
{
    updates <- as.data.frame(utils::old.packages(lib.loc = .rs.writeableLibraryPaths()), 
        stringsAsFactors = FALSE)
    row.names(updates) <- NULL
    repos <- getOption("repos")
    cranRep <- if ("CRAN" %in% names(repos)) 
        repos["CRAN"]
    else c(CRAN = repos[[1]])
    data.frame(packageName = updates$Package, libPath = updates$LibPath, 
        installed = updates$Installed, available = updates$ReposVer, 
        stringsAsFactors = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.objectSize
function (object) 
{
    format(object.size(object), units = "auto")
}
<environment: 0x000001883f4b86b8>

$.rs.pager
function (files, header, title, delete.file) 
{
    for (i in 1:length(files)) {
        if ((i > length(header)) || !nzchar(header[[i]])) 
            fileTitle <- title
        else fileTitle <- header[[i]]
        .Call("rs_showFile", fileTitle, files[[i]], delete.file)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.invokePlumberWindowExternal
function (url) 
{
    invisible(.Call("rs_plumberviewer", url, getwd(), "browser", 
        PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"plumberViewerType")
[1] "browser"

$.rs.python.listModules
function () 
{
    pkgutil <- reticulate::import("pkgutil", convert = FALSE)
    builtins <- reticulate::import_builtins(convert = FALSE)
    modules <- tryCatch(builtins$list(pkgutil$iter_modules()), 
        error = identity)
    if (inherits(modules, "error")) 
        return(character())
    modules <- reticulate::py_to_r(modules)
    key <- if (.rs.python.isPython3()) 
        "name"
    else 2L
    names <- vapply(modules, `[[`, key, FUN.VALUE = character(1))
    sort(unique(names))
}
<environment: 0x000001883f4b86b8>

$.rs.connectionSupportedPackages
function () 
{
    list(list(name = "ODBC", package = "odbc", version = "1.1.1"), 
        list(name = "Spark", package = "sparklyr", version = "0.5.6"))
}
<environment: 0x000001883f4b86b8>

$.rs.hasVar
function (name) 
{
    envir <- .rs.toolsEnv()
    fullName <- paste(".rs.", name, sep = "")
    exists(fullName, envir = envir)
}
<environment: 0x000001883f4b86b8>

$.rs.isDownloadMethodSecure
function (method) 
{
    if (identical(method, "auto")) 
        method <- .rs.autoDownloadMethod()
    if (method %in% c("wininet", "libcurl", "wget", "curl")) {
        TRUE
    }
    else if (identical(method, "internal")) {
        identical(Sys.info()[["sysname"]], "Windows") && isTRUE(.rs.setInternet2(NA))
    }
    else {
        FALSE
    }
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletionsIdentifiers
function (token, conn, ctx) 
{
    identifiers <- setdiff(as.character(ctx$identifiers), token)
    results <- .rs.selectFuzzyMatches(identifiers, token)
    .rs.makeCompletions(token = token, results = results, type = .rs.acCompletionTypes$CONTEXT, 
        language = "SQL")
}
<environment: 0x000001883f4b86b8>

$.rs.isREADME
function (file) 
{
    identical(tools::file_path_sans_ext(basename(file)), "README")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.is_function
function (nameString, envString) 
{
    object <- NULL
    if (envString == "") {
        object <- .rs.getAnywhere(nameString, parent.frame())
    }
    else {
        envString <- .rs.stripSurrounding(envString)
        if (envString %in% search()) {
            object <- tryCatch(get(nameString, pos = which(envString == 
                search())), error = function(e) NULL)
        }
        else if (envString %in% loadedNamespaces()) {
            object <- tryCatch(get(nameString, envir = asNamespace(envString)), 
                error = function(e) NULL)
        }
        else if (!is.null(container <- .rs.getAnywhere(envString, 
            parent.frame()))) {
            if (isS4(container)) {
                object <- tryCatch(eval(call("@", container, 
                  nameString)), error = function(e) NULL)
            }
            else {
                object <- tryCatch(eval(call("$", container, 
                  nameString)), error = function(e) NULL)
            }
        }
    }
    .rs.scalar(!is.null(object) && is.function(object))
}
<environment: 0x000001883f4b86b8>

$.rs.python.getParameterHelp
function (source) 
{
    error <- list(args = character(), arg_descriptions = character())
    object <- .rs.tryCatch(reticulate::py_eval(source, convert = FALSE))
    if (inherits(object, "error")) 
        return(error)
    inspect <- reticulate::import("inspect", convert = TRUE)
    spec <- .rs.tryCatch(inspect$getargspec(object))
    if (inherits(spec, "error")) 
        return(error)
    args <- spec$args
    docs <- reticulate::py_get_attr(object, "__doc__", silent = TRUE)
    if (inherits(docs, "python.builtin.object")) 
        docs <- reticulate::py_to_r(docs)
    if (is.null(docs)) 
        docs <- ""
    lines <- strsplit(docs, "\n", fixed = TRUE)[[1]]
    arg_descriptions <- lapply(args, function(arg) {
        tryCatch({
            pattern <- sprintf("^\\s*%s\\s*:", arg)
            index <- grep(pattern, lines)
            if (!length(index)) 
                return("")
            index <- index[[1]]
            line <- lines[[index]]
            desc <- ""
            colon <- regexpr(":", line, fixed = TRUE)
            if (colon != -1L) 
                desc <- substring(line, colon + 1)
            indent <- regexpr("(?:\\S|$)", line)
            start <- end <- index + 1
            while (TRUE) {
                if (regexpr("(?:\\S|$)", lines[[end]]) <= indent) 
                  break
                end <- end + 1
            }
            if (start != end) 
                desc <- c(desc, lines[start:(end - 1L)])
            paste(gsub("^\\s*|\\s*$", "", desc), collapse = "\n")
        }, error = function(e) "")
    })
    list(args = as.character(args), arg_descriptions = as.character(arg_descriptions))
}
<environment: 0x000001883f4b86b8>

$.rs.replayNotebookPlots
function (width, height, pixelRatio, tempFile, extraArgs) 
{
    stdin <- file("stdin")
    require(grDevices, quietly = TRUE)
    snapshots <- readLines(stdin, warn = FALSE)
    lapply(snapshots, function(snapshot) {
        if (nchar(tools::file_ext(snapshot)) < 1) 
            return(invisible(NULL))
        output <- paste(tools::file_path_sans_ext(snapshot), 
            "resized.png", sep = ".")
        height <- if (height <= 0) 
            width/1.618
        else height
        .rs.createNotebookGraphicsDevice(output, height, width, 
            "px", pixelRatio, extraArgs)
        tryCatch({
            .rs.restoreGraphics(snapshot)
        }, error = function(e) {
        })
        dev.off()
        if (file.exists(output)) {
            if (tempFile) {
                chunksPath <- dirname(snapshot)
                chunksTempPath <- file.path(chunksPath, "temp")
                if (!dir.exists(chunksTempPath)) 
                  dir.create(chunksTempPath)
                chunkBaseName <- basename(tools::file_path_sans_ext(snapshot))
                final <- file.path(chunksTempPath, paste(chunkBaseName, 
                  "png", sep = "."))
            }
            else {
                final <- paste(tools::file_path_sans_ext(snapshot), 
                  "png", sep = ".")
            }
            if (file.exists(final)) 
                unlink(final)
            file.copy(output, final)
            if (file.exists(output)) 
                unlink(output)
            if (file.exists(final)) {
                cat(final, "\n")
            }
        }
    })
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.listFilesFuzzy
function (directory, token) 
{
    pattern <- if (nzchar(token)) 
        paste("^", .rs.asCaseInsensitiveRegex(.rs.escapeForRegex(token)), 
            sep = "")
    formals <- as.list(formals(base::list.files))
    formals$path <- directory
    formals$pattern <- pattern
    formals$all.files <- TRUE
    formals$full.names <- TRUE
    if ("include.dirs" %in% names(formals)) 
        formals[["include.dirs"]] <- TRUE
    if ("no.." %in% names(formals)) 
        formals[["no.."]] <- TRUE
    result <- do.call(base::list.files, formals)
    absolutePaths <- gsub("/+", "/", result)
    if (!("no.." %in% names(formals))) {
        absolutePaths <- grep("/\\.+$", absolutePaths, invert = TRUE, 
            value = TRUE)
    }
    absolutePaths
}
<environment: 0x000001883f4b86b8>

$.rs.makeDeploymentList
function (target, asMultipleDoc, quartoSrcFile, max_size) 
{
    ext <- tolower(tools::file_ext(target))
    if (ext %in% c("qmd", "rmd", "html", "htm", "md")) 
        .rs.docDeployList(target, asMultipleDoc, quartoSrcFile)
    else rsconnect::listBundleFiles(appDir = target)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.extract_chunk_options
function (chunkText) 
{
    parsed <- try(parse(text = chunkText), silent = TRUE)
    if (inherits(parsed, "try-error")) 
        return(list())
    chunkOptionsEnv <- new.env(parent = emptyenv())
    lapply(parsed, function(node) {
        .rs.recursiveWalk(node, function(node) {
            if (!is.call(node) || length(node) < 2) 
                return()
            callName <- as.character(node)[[1L]]
            if (callName == "knitr:::opts_chunk$set" || callName == 
                "knitr::opts_chunk$set" || callName == "opts_chunk$set") {
                names <- names(node)
                for (i in 2:length(node)) {
                  key <- names[[i]]
                  if (key == "") 
                    next
                  val <- if (is.character(node[[i]])) 
                    .rs.surround(node[[i]], with = "\"")
                  else format(node[[i]])
                  chunkOptionsEnv[[key]] <- val
                }
            }
        })
    })
    result <- as.list(chunkOptionsEnv)
    for (i in seq_along(result)) result[[i]] <- .rs.scalar(result[[i]])
    return(result)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.callCustomInspector
function (object, context) 
{
    classes <- class(object)
    method <- NULL
    for (class in classes) {
        candidate <- .rs.explorer.inspectorRegistry[[class]]
        if (is.function(candidate)) {
            method <- candidate
            break
        }
    }
    if (is.null(method)) 
        return(NULL)
    result <- .rs.withTimeLimit(1, method(object, context))
    if (is.null(result)) 
        return(NULL)
    special <- c("name", "access", "tags")
    for (field in special) if (is.null(result[[field]])) 
        result[[field]] <- context[[field]]
    if (!.rs.explorer.isValidInspectionResult(result)) 
        return(NULL)
    result
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_vignette_title
function (topic, package) 
{
    title <- tryCatch(utils::vignette(topic, package)$Title, 
        error = function(e) "", warning = function(e) "")
    .rs.scalar(title)
}
<environment: 0x000001883f4b86b8>

$.rs.parseStringElement
function (element, keyName) 
{
    value <- xml2::xml_text(element)
    if (is.null(keyName)) {
        stop("Unable to find a key for the \"string\" element with value \"", 
            value, "\".", call. = FALSE)
    }
    value
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsDoubleBracket
function (token, string, functionCall, envir = parent.frame()) 
{
    result <- .rs.emptyCompletions()
    if (.rs.isDataTableExtractCall(string, envir = envir)) 
        return(result)
    object <- .rs.getAnywhere(string, envir)
    if (is.null(object)) 
        return(result)
    completions <- .rs.getNames(object)
    completions <- .rs.selectFuzzyMatches(completions, token)
    if (length(completions)) {
        result <- .rs.makeCompletions(token = token, results = completions, 
            packages = string, quote = TRUE, type = .rs.acCompletionTypes$STRING, 
            overrideInsertParens = TRUE)
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.extractChunkInnerCode
function (code) 
{
    Encoding(code) <- "UTF-8"
    code <- unlist(strsplit(code, "\n", fixed = TRUE))
    start <- max(1, grep(.rs.reRmdChunkBegin(), code, perl = TRUE))
    end <- min(length(code), grep(.rs.reRmdChunkEnd(), code, 
        perl = TRUE))
    code <- code[(start + 1):(end - 1)]
    code <- gsub("#[|].*$", "", code)
    paste(code, collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.describeCols
function (x, maxFactors) 
{
    colNames <- names(x)
    colLabels <- attr(x, "variable.labels", exact = TRUE)
    if (!is.character(colLabels)) {
        colLabels <- character()
    }
    rowNameCol <- list(col_name = .rs.scalar(""), col_type = .rs.scalar("rownames"), 
        col_min = .rs.scalar(0), col_max = .rs.scalar(0), col_search_type = .rs.scalar("none"), 
        col_label = .rs.scalar(""), col_vals = "", col_type_r = .rs.scalar(""))
    if (length(colNames) == 0) {
        return(rowNameCol)
    }
    colAttrs <- lapply(seq_along(colNames), function(idx) {
        col_name <- if (idx <= length(colNames)) 
            colNames[idx]
        else as.character(idx)
        col_type <- "unknown"
        col_type_r <- "unknown"
        col_breaks <- c()
        col_counts <- c()
        col_vals <- ""
        col_search_type <- ""
        label <- attr(x[[idx]], "label", exact = TRUE)
        col_label <- if (is.character(label)) {
            label
        }
        else if (idx <= length(colLabels)) {
            if (col_name %in% names(colLabels)) 
                colLabels[[col_name]]
            else colLabels[[idx]]
        }
        else {
            ""
        }
        if (length(x[[idx]]) > 0) {
            val <- x[[idx]][[1]]
            col_type_r <- typeof(val)
            if (is.factor(val)) {
                col_type <- "factor"
                if (length(levels(val)) > maxFactors) {
                  col_search_type <- "character"
                }
                else {
                  col_search_type <- "factor"
                  col_vals <- levels(val)
                }
            }
            else if (is.numeric(x[[idx]]) && !is.object(x[[idx]])) {
                hist_vals <- x[[idx]][is.finite(x[[idx]])]
                if (length(hist_vals) > 1) {
                  h <- suppressWarnings(graphics::hist(hist_vals, 
                    plot = FALSE))
                  col_breaks <- h$breaks
                  col_counts <- h$counts
                  col_type <- "numeric"
                  col_search_type <- "numeric"
                }
            }
            else if (inherits(x[[idx]], "integer64")) {
                col_type <- "numeric"
                col_search_type <- "character"
            }
            else if (is.character(val)) {
                col_type <- "character"
                col_search_type <- "character"
            }
            else if (is.logical(val)) {
                col_type <- "boolean"
                col_search_type <- "boolean"
            }
            else if (is.data.frame(val)) {
                col_type <- "data.frame"
            }
            else if (is.list(val)) {
                col_type <- "list"
            }
        }
        list(col_name = .rs.scalar(col_name), col_type = .rs.scalar(col_type), 
            col_breaks = as.character(col_breaks), col_counts = col_counts, 
            col_search_type = .rs.scalar(col_search_type), col_label = .rs.scalar(col_label), 
            col_vals = col_vals, col_type_r = .rs.scalar(col_type_r))
    })
    c(list(rowNameCol), colAttrs)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.hookedMatplotlibModules
<environment: 0x000001883d1f3a90>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.cppSourceFile
function (file) 
{
    lines <- .rs.tryCatch(readLines(file, warn = FALSE))
    call <- call("fun", file)
    if (is.character(lines) && any(grepl("cpp11::register", lines))) 
        call[[1L]] <- quote(cpp11::cpp_source)
    else call[[1L]] <- quote(Rcpp::sourceCpp)
    deparse(call)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleFindDriver
function (name, installPath, libraryPattern) 
{
    osExtensions <- list(osx = "dylib$", windows = "dll$", linux = "so$")
    osExtension <- osExtensions[[.rs.odbcBundleOsName()]]
    driverName <- gsub(paste(" |", trimws(.rs.connectionOdbcRStudioDriver()), 
        sep = ""), "", name)
    if (is.null(libraryPattern) || nchar(libraryPattern) == 0) {
        libraryPattern <- paste(driverName, "[^/\\\\]+\\.", osExtension, 
            sep = "")
    }
    osName <- .rs.odbcBundleOsName()
    bitness <- .rs.odbcOsBitness()
    libraryPattern <- gsub("\\(os\\)", osName, libraryPattern)
    libraryPattern <- gsub("\\(bitness\\)", bitness, libraryPattern)
    allFiles <- dir(installPath, recursive = TRUE, full.names = TRUE)
    driverPath <- allFiles[grepl(libraryPattern, allFiles, ignore.case = TRUE)]
    if (!identical(length(driverPath), 1L)) 
        stop("Failed to find ", library, " inside driver bundle.")
    normalizePath(driverPath)
}
<environment: 0x000001883f4b86b8>

$.rs.markdownToHTML
function (content) 
{
    .Call("rs_markdownToHTML", content, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.enqueLoadedPackageUpdates
function (installCmd) 
{
    .Call("rs_enqueLoadedPackageUpdates", installCmd, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.matchCall
function (func, call, numCommas = NULL) 
{
    names <- names(call)
    if (is.null(names)) 
        names <- rep("", length(call))
    funFormals <- names(formals(func))
    hasDots <- any(funFormals == "...")
    if (is.null(numCommas)) 
        numCommas <- length(call)
    j <- 1L
    i <- 2L
    while (TRUE) {
        if (i > length(call)) 
            break
        if (identical(call[[i]], quote(...)) || (names[i] == 
            "" && j > numCommas) || (!hasDots && names[i] != 
            "" && !any(names[i] == funFormals))) {
            call <- call[-i]
            names <- names[-i]
        }
        else {
            i <- i + 1
        }
        j <- j + 1L
    }
    tryCatch(match.call(func, call), error = function(e) call)
}
<bytecode: 0x0000018840d89bb0>
<environment: 0x000001883f4b86b8>

$.rs.connectionOdbcInstallPath
function () 
{
    normalizePath(file.path(.Call("rs_connectionOdbcInstallPath"), 
        "odbc", "drivers"), mustWork = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.replIsActive
function () 
{
    if (.rs.isBrowserActive()) 
        return(FALSE)
    if (!"reticulate" %in% loadedNamespaces()) 
        return(FALSE)
    active <- tryCatch(reticulate:::py_repl_active(), error = identity)
    if (inherits(active, "error")) 
        return(FALSE)
    active
}
<environment: 0x000001883f4b86b8>

$.rs.getPackageInformation
function (...) 
{
    rgl.useNULL <- getOption("rgl.useNULL")
    options(rgl.useNULL = TRUE)
    on.exit(options(rgl.useNULL = rgl.useNULL), add = TRUE)
    packages <- list(...)
    lapply(packages, function(package) {
        tryCatch(.rs.emitPackageInformation(package), error = function(e) .rs.emptyFunctionInfo())
    })
}
<environment: 0x000001883f4b86b8>

$.rs.withBuildTools
function (code) 
{
    .rs.addRToolsToPath()
    on.exit(.rs.restorePreviousPath(), add = TRUE)
    force(code)
}
<environment: 0x000001883f4b86b8>

$.rs.renvCache
<environment: 0x000001883fd418f8>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.python.findWindowsPython
function () 
{
    pythonCommands <- c("py", "python3", "python")
    available <- nzchar(Sys.which(pythonCommands))
    if (!any(available)) 
        return("")
    else pythonCommand <- pythonCommands[available][1]
    pythonPath <- .rs.tryCatch(system2(command = pythonCommand, 
        args = c("-E", "-Xutf8"), input = "import sys; print(sys.executable)", 
        stdout = TRUE, stderr = TRUE))
    if (inherits(pythonPath, "error")) 
        return("")
    Encoding(pythonPath) <- "UTF-8"
    pythonPath
}
<environment: 0x000001883f4b86b8>

$.rs.restoreGraphics
function (filename) 
{
    envir <- new.env(parent = emptyenv())
    load(filename, envir = envir)
    plot <- envir$plot
    dlls <- getLoadedDLLs()
    rVersion <- getRversion()
    wasPairlist <- is.pairlist(plot[[1]])
    items <- as.list(plot[[1]])
    restored <- lapply(items, function(item) {
        symbol <- item[[2]][[1]]
        if (!inherits(symbol, "NativeSymbolInfo")) 
            return(item)
        name <- if (is.null(symbol$package)) 
            symbol$dll[["name"]]
        else symbol$package[["name"]]
        nativeSymbol <- getNativeSymbolInfo(name = symbol$name, 
            PACKAGE = dlls[[name]])
        item[[2]][[1]] <- nativeSymbol
        item
    })
    if (wasPairlist) 
        restored <- as.pairlist(restored)
    if (!is.null(restored)) 
        plot[[1]] <- restored
    plotPid <- attr(plot, "pid")
    if (is.null(plotPid) || (plotPid != Sys.getpid())) 
        attr(plot, "pid") <- Sys.getpid()
    for (item in plot) {
        name <- attr(item, "pkgName", exact = TRUE)
        if (is.character(name) && name[[1L]] %in% c("grid", "ggplot2")) {
            if (requireNamespace("grid", quietly = TRUE)) 
                grid::grid.newpage()
            break
        }
    }
    suppressWarnings(grDevices::replayPlot(plot))
}
<environment: 0x000001883f4b86b8>

$.rs.findConnectionName
function (type, host) 
{
    connections <- ls(.rs.activeConnections)
    for (name in connections) {
        connection <- get(name, envir = .rs.activeConnections)
        if (identical(connection$type, type) && identical(connection$host, 
            host)) {
            return(name)
        }
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.findShinyTestsDir
function (appDir) 
{
    tryCatch(expr = shinytest:::findTestsDir(appDir = appDir, 
        mustExit = FALSE, quiet = TRUE), error = function(e) {
        file.path(appDir, "tests")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.isRtoolsOnPath
function () 
{
    if (!nzchar(Sys.which("ls.exe"))) 
        return(FALSE)
    rv <- getRversion()
    if (rv >= "3.3.0" && rv < "4.0.0") {
        if (is.na(Sys.getenv("BINPREF", unset = NA))) 
            return(FALSE)
    }
    if (rv < "3.3.0") {
        if (!nzchar(Sys.which("gcc.exe"))) 
            return(FALSE)
    }
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.createDefaultShellRd
function (`_name`, `_type`) 
{
    dirName <- tempfile("RdShell")
    dir.create(dirName)
    previousWd <- getwd()
    on.exit(setwd(previousWd))
    setwd(dirName)
    if (identical(`_type`, "function")) {
        assign(`_name`, function(x) {
        })
        return(.rs.normalizePath(paste(getwd(), utils::prompt(name = `_name`), 
            sep = "/")))
    }
    else if (identical(`_type`, "data")) {
        assign(`_name`, data.frame(x = integer(), y = integer()))
        return(.rs.normalizePath(paste(getwd(), utils::promptData(name = `_name`), 
            sep = "/")))
    }
    else {
        return("")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rstudioapi.processRequest
function (requests, response, secret) 
{
    result <- .rs.tryCatch(.rs.rstudioapi.processRequestImpl(requests, 
        response, secret))
    unlink(requests)
    if (inherits(result, "error")) {
        saveRDS(result, response)
        return(FALSE)
    }
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.setCRANReposFromSettings
function (cran, secondary) 
{
    if (.rs.isCRANReposFromSettings()) 
        .rs.setCRANRepos(cran, secondary)
}
<environment: 0x000001883f4b86b8>

$.rs.addJsonRpcHandler
function (name, FN) 
{
    fullName <- paste("rpc.", name, sep = "")
    .rs.addFunction(fullName, FN, TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.makePrimitiveWrapper
function (x) 
{
    args(x)
}
<environment: 0x000001883f4b86b8>

$.rs.expandDependencies
function (available, installed, dependencies) 
{
    nodes <- c()
    packages <- dependencies
    edges <- list()
    for (dep in dependencies) {
        nodes <- c(nodes, dep$name)
    }
    for (dep in dependencies) {
        fields <- c("Depends", "Imports", "LinkingTo")
        for (field in fields) {
            contents <- available[dep$name, field]
            if (is.na(contents) || !is.character(contents)) 
                next
            prereqs <- strsplit(contents, "\\s*,\\s*")[[1]]
            parsed <- regexec("([a-zA-Z0-9._]+)(?:\\s*\\(([><=]+)\\s*([0-9.-]+)\\))?", 
                prereqs)
            matches <- regmatches(prereqs, parsed)
            for (match in matches) {
                if (length(match) < 2) 
                  next
                pkgName <- match[[2]]
                if (!(pkgName %in% rownames(available))) 
                  next
                if (!pkgName %in% nodes) {
                  nodes <- c(nodes, pkgName)
                  satisfied <- if (pkgName %in% rownames(installed)) {
                    if (length(match >= 4) && nchar(match[[4]]) > 
                      0) {
                      installedVer <- as.package_version(installed[pkgName, 
                        "Version"])
                      requiredVer <- as.package_version(match[[4]])
                      if (identical(match[[3]], ">")) {
                        installedVer > requiredVer
                      }
                      else {
                        installedVer >= requiredVer
                      }
                    }
                    else {
                      TRUE
                    }
                  }
                  else {
                    FALSE
                  }
                  if (!satisfied) {
                    packages <- append(packages, list(list(name = pkgName, 
                      location = "cran", version = available[pkgName, 
                        "Version"], source = FALSE)))
                  }
                }
                edges <- append(edges, list(list(from = dep$name, 
                  to = pkgName)))
            }
        }
    }
    sorted <- .rs.topoSortPackages(nodes, edges)
    result <- list()
    for (package in sorted) {
        for (record in packages) {
            if (record$name == package) {
                result <- append(result, list(record))
                break
            }
        }
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.objectType
function (object) 
{
    type <- typeof(object)
    if (type %in% "closure") 
        type <- "function"
    else if (type %in% c("builtin", "special")) 
        type <- "function (primitive)"
    dimensions <- dim(object)
    if (!is.null(dimensions)) {
        dimtext <- paste(dimensions, collapse = " x ")
        type <- paste(type, sprintf("[%s]", dimtext))
    }
    else if (is.character(object) || is.numeric(object) || is.raw(object) || 
        is.complex(object) || is.list(object) || is.environment(object) || 
        is.factor(object) || is.logical(object)) {
        type <- paste(type, sprintf("[%s]", length(object)))
    }
    type
}
<environment: 0x000001883f4b86b8>

$.rs.registerPackageLoadHook
function (package, hook) 
{
    if (package %in% loadedNamespaces()) 
        return(hook())
    setHook(hookName = packageEvent(package, "onLoad"), value = hook, 
        action = "append")
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.isValidInspectionResult
function (result) 
{
    if (!is.list(result)) 
        return(FALSE)
    expected <- .rs.explorer.createInspectionResult(NULL)
    keys <- names(expected)
    missing <- setdiff(keys, names(result))
    if (length(missing)) 
        return(FALSE)
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.loadedPackageUpdates
function (pkgs) 
{
    ignore <- .rs.ignoreNextLoadedPackageCheck
    .rs.setVar("ignoreNextLoadedPackageCheck", FALSE)
    if (ignore) 
        return(FALSE)
    defaultNamespaces <- c("base", "datasets", "graphics", "grDevices", 
        "methods", "stats", "tools", "utils")
    if (identical(defaultNamespaces, loadedNamespaces()) && length(.dynLibs()) == 
        4) 
        return(FALSE)
    if (.rs.packagesLoaded(pkgs)) {
        return(TRUE)
    }
    else {
        avail <- available.packages()
        deps <- suppressMessages(suppressWarnings(utils:::getDependencies(pkgs, 
            available = avail)))
        return(.rs.packagesLoaded(deps))
    }
}
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.connectionUpdated
function (type, host, hint, ...) 
{
    tryCatch(.rs.connectionObserver.connectionUpdatedImpl(type, 
        host, hint, ...), error = .rs.connectionObserver.connectionError)
}
<environment: 0x000001883f4b86b8>

$.rs.markdown.resolveCompletionRoot
function (path) 
{
    props <- .rs.getSourceDocumentProperties(path)
    workingDirProp <- props$properties$working_dir
    useProject <- identical(workingDirProp, "project") && is.character(props$path) && 
        is.character(props$project_path)
    if (useProject) {
        path <- substring(props$path, 1L, nchar(props$path) - 
            nchar(props$project_path) - 1L)
        return(path)
    }
    if (identical(workingDirProp, "current")) {
        return(getwd())
    }
    if ("knitr" %in% loadedNamespaces()) {
        rootDir <- knitr::opts_knit$get("root.dir")
        if (is.character(rootDir)) 
            return(rootDir)
    }
    dirname(path)
}
<environment: 0x000001883f4b86b8>

$.rs.extractFunctionNameFromCall
function (object) 
{
    if (!is.call(object)) 
        return("")
    if (.rs.isSymbolCalled(object[[1]], "::") || .rs.isSymbolCalled(object[[1]], 
        ":::") || (is.character(object[[1]]) && object[[1]] %in% 
        c("::", ":::"))) {
        if (length(object) > 2) 
            return(as.character(object[[3]]))
        else return("")
    }
    if (is.character(object[[1]]) || is.symbol(object[[1]])) 
        return(as.character(object[[1]]))
    if (is.call(object[[1]])) 
        return(.rs.extractFunctionNameFromCall(object[[1]]))
    return("")
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.onPythonInitialized
function () 
{
    builtins <- reticulate::import_builtins(convert = FALSE)
    help <- builtins$help
    .rs.setVar("reticulate.help", builtins$help)
    builtins$help <- function(...) {
        dots <- list(...)
        if (length(dots) == 0) {
            message("Error: Interactive Python help not available within RStudio")
            return()
        }
        help(...)
    }
    setHook("reticulate::matplotlib.pyplot::load", function(...) .rs.reticulate.matplotlib.onLoaded())
    setHook("reticulate::matplotlib.pylab::load", function(...) .rs.reticulate.matplotlib.onLoaded())
    setHook("reticulate::matplotlib::load", function(...) .rs.reticulate.matplotlib.onLoaded())
}
<environment: 0x000001883f4b86b8>

$.rs.lint
function (filePath) 
{
    engine <- .rs.getLintEngine()
    invisible(engine(filePath))
}
<environment: 0x000001883f4b86b8>

$.rs.api.addTheme
function (themePath, apply = FALSE, force = FALSE, globally = FALSE) 
{
    tryCatch(.rs.addTheme(themePath, apply, force, globally), 
        error = function(e) {
            stop("Unable to add the theme file \"", themePath, 
                "\". ", e$message)
        })
}
<environment: 0x000001883f3d0aa0>

$.rs.CachedDataEnv
<environment: 0x000001883ecd0d38>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.showErrorMessage
function (title, message) 
{
    .Call("rs_showErrorMessage", title, message, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.loaded_package_updates_required
function (pkgs) 
{
    .rs.scalar(.rs.loadedPackageUpdates(as.character(pkgs)))
}
<environment: 0x000001883f4b86b8>

$.rs.api.unregisterCommandCallback
function (handle = NULL) 
{
    if (!is.null(handle) && !exists(handle, envir = .rs.commandCallbacks)) 
        warning("Handle '", handle, " is not a registered RStudio command callback.")
    else {
        rm(list = handle, envir = .rs.commandCallbacks)
        .rs.enqueClientEvent("command_callbacks_changed", .rs.scalarListFromList(as.list(.rs.getCommandsWithCallbacks())))
    }
    invisible(NULL)
}
<environment: 0x000001883fe42c60>

$.rs.api.terminalClear
function (id) 
{
    if (is.null(id) || !is.character(id) || length(id) != 1) 
        stop("'id' must be a character vector of length one")
    .Call("rs_terminalClear", id)
    invisible(NULL)
}
<environment: 0x000001883fd97c80>

$.rs.getSrcref
function (fun) 
{
    attr(.rs.untraced(fun), "srcref")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_secondary_repos
function (cran, custom) 
{
    .rs.getSecondaryRepos(cran, custom)
}
<environment: 0x000001883f4b86b8>

$.rs.formCompletionVector
function (object, default, n) 
{
    if (length(object) == 0) 
        rep(default, length.out = n)
    else if (length(object) == 1) 
        rep.int(object, n)
    else if (length(object) == n) 
        object
    else rep(object, length.out = n)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.has_orphaned_accounts
function () 
{
    accountDir <- .rs.connectConfigDir("rsconnect", "accounts")
    if (!file.exists(accountDir)) 
        accountDir <- .rs.connectConfigDir("connect", "accounts")
    if (file.exists(accountDir)) {
        files <- list.files(accountDir, recursive = TRUE, include.dirs = FALSE)
        if (length(files) > 0 && !.rs.isPackageInstalled("rsconnect")) {
            return(.rs.scalar(length(files)))
        }
    }
    return(.rs.scalar(0))
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleExtract
function (bundleFileTemp, installPath) 
{
    untar(bundleFileTemp, exdir = installPath)
}
<environment: 0x000001883f4b86b8>

$.rs.writeUserPref
function (prefName, value) 
{
    if (is.list(value)) {
        value <- .rs.scalarListFromList(value)
    }
    .rs.writePrefInternal("rs_writeUserPref", prefName, value)
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.onResume
function (path) 
{
}
<environment: 0x000001883f4b86b8>

$.rs.getS4MethodsForFunction
function (func) 
{
    sigs <- findMethodSignatures(methods = findMethods(func))
    apply(sigs, 1, function(sig) {
        paste(func, " {", paste(sig, collapse = ", "), "}", sep = "", 
            collapse = "")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.defaultHttpUserAgent
function () 
{
    fields <- c(format(getRversion()), format(R.version$platform), 
        format(R.version$arch), format(R.version$os))
    sprintf("R (%s)", paste(fields, collapse = " "))
}
<environment: 0x000001883f4b86b8>

$.rs.stringBuilder
function () 
{
    (function() {
        indent_ <- "  "
        indentSize_ <- 0
        data_ <- character()
        indented_ <- function(data) {
            indent <- paste(character(indentSize_ + 1), collapse = indent_)
            for (i in seq_along(data)) if (is.list(data[[i]])) 
                data[[i]] <- indented_(data[[i]])
            else data[[i]] <- paste(indent, data[[i]], sep = "")
            data
        }
        list(append = function(...) {
            data_ <<- c(data_, indented_(list(...)))
        }, appendf = function(...) {
            data_ <<- c(data_, indented_(sprintf(...)))
        }, indent = function() {
            indentSize_ <<- indentSize_ + 1
        }, unindent = function() {
            indentSize_ <<- max(0, indentSize_ - 1)
        }, data = function() unlist(data_))
    })()
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.refresh
function (id, entry) 
{
    handle <- list(id = .rs.scalar(id), name = .rs.scalar(entry$name), 
        title = .rs.scalar(entry$title), language = .rs.scalar(entry$language))
    .rs.explorer.fireEvent(.rs.explorer.types$REFRESH, handle)
}
<environment: 0x000001883f4b86b8>

$.rs.api.documentPath
function (id = NULL) 
{
    id <- .rs.nullCoalesce(id, .rs.api.documentId(allowConsole = FALSE))
    if (is.null(id)) 
        return(NULL)
    properties <- .Call("rs_documentProperties", id, FALSE, PACKAGE = "(embedding)")
    properties$path
}
<environment: 0x000001883fd75fa0>

$.rs.internal.addTheme
function (themePath) 
{
    Encoding(themePath) <- "UTF-8"
    warnings <- c()
    tryCatch(withCallingHandlers(.rs.addTheme(themePath, apply = FALSE, 
        force = FALSE, globally = FALSE), warning = function(w) {
        warnings <<- conditionMessage(w)
        invokeRestart("muffleWarning")
    }), error = function(e) {
        if (length(warnings) > 0) 
            e$message <- paste(e$message, paste0(warnings, collapse = "\n    "), 
                sep = "\nAlso, warnings:\n    ")
        e
    })
}
<environment: 0x000001883f4b86b8>

$.rs.findCustomHelpContext
function (token, handler) 
{
    if (grepl("\\$", token)) {
        components <- strsplit(token, "\\$")[[1]]
        topic <- components[[length(components)]]
        source <- paste(components[1:(length(components) - 1)], 
            collapse = "$")
        source <- tryCatch(eval(parse(text = source), envir = globalenv()), 
            error = function(e) NULL)
        if (!is.null(source)) {
            for (cls in class(source)) {
                res <- utils::getAnywhere(paste(handler, ".", 
                  cls, sep = ""))
                if (length(res$objs) > 0) {
                  return(list(topic = topic, source = source, 
                    handler = res$objs[[1]]))
                }
            }
        }
    }
    NULL
}
<bytecode: 0x000001883c1d3f00>
<environment: 0x000001883f4b86b8>

$.rs.hasColumns
function (object) 
{
    if (inherits(object, c("data.frame"))) 
        return(TRUE)
    if (isNamespaceLoaded("arrow") && inherits(object, c("ArrowTabular", 
        "Dataset", "arrow_dplyr_query"))) 
        return(TRUE)
    FALSE
}
<environment: 0x000001883f4b86b8>

$.rs.getRmdPublishDetails
function (target, encoding) 
{
    lines <- readLines(target, encoding = encoding, warn = FALSE)
    frontMatter <- rmarkdown:::parse_yaml_front_matter(lines)
    if (is.list(frontMatter) && (identical(frontMatter$runtime, 
        "shiny_prerendered") || identical(frontMatter$runtime, 
        "shinyrmd") || identical(frontMatter$server, "shiny") || 
        (is.list(frontMatter$server) && identical(frontMatter$server$type, 
            "shiny")))) {
        is_multi_rmd <- FALSE
    }
    else {
        rmds <- list.files(path = dirname(target), pattern = glob2rx("*.Rmd"), 
            all.files = FALSE, recursive = FALSE, ignore.case = TRUE, 
            include.dirs = FALSE)
        is_multi_rmd <- length(rmds) > 1
    }
    selfContained <- TRUE
    outputFormat <- rmarkdown:::output_format_from_yaml_front_matter(lines)
    if (is.list(outputFormat$options) && identical(outputFormat$options$self_contained, 
        FALSE)) {
        selfContained <- FALSE
    }
    title <- ""
    if (is.list(frontMatter) && is.character(frontMatter$title)) {
        title <- frontMatter$title
    }
    renderFunction <- .rs.getCustomRenderFunction(target)
    list(is_multi_rmd = .rs.scalar(is_multi_rmd), is_shiny_rmd = .rs.scalar(renderFunction == 
        "rmarkdown::run"), is_self_contained = .rs.scalar(selfContained), 
        title = .rs.scalar(title), has_connect_account = .rs.scalar(.rs.hasConnectAccount()))
}
<environment: 0x000001883f4b86b8>

$.rs.getSingleClass
function (obj) 
{
    class(obj)[[1L]]
}
<environment: 0x000001883f4b86b8>

$.rs.isLocalTheme
function (themeUrl) 
{
    grepl("^theme/custom/local/.*\\.rstheme$", themeUrl, ignore.case = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.prepareViewerData
function (data, maxFactors, maxCols, maxRows) 
{
    columns <- list()
    if (ncol(data)) {
        columns <- .rs.describeCols(data, maxFactors)
        if (ncol(data) > maxCols) {
            columns <- head(columns, maxCols)
            data <- data[1:maxCols]
        }
    }
    cnames <- names(data)
    size <- nrow(data)
    if (!identical(maxRows, NULL) && size > maxRows) {
        data <- head(data, maxRows)
        size <- nrow(data)
    }
    if (nrow(data) > 0) {
        for (i in seq_along(data)) {
            data[[i]] <- .rs.formatDataColumn(data[[i]], 1, size)
        }
    }
    list(data = unname(as.list(data)), columns = columns)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.clear_profile
function (filePath, htmlPath) 
{
    tryCatch({
        resources <- .rs.profileResources()
        pathPrefix <- tools::file_path_sans_ext(basename(filePath))
        filePrefix <- tools::file_path_sans_ext(basename(htmlPath))
        rprofFile <- file.path(resources$tempPath, paste(pathPrefix, 
            ".Rprof", sep = ""))
        if (file.exists(rprofFile)) {
            file.remove(rprofFile)
        }
        profileHtml <- file.path(resources$tempPath, paste(filePrefix, 
            ".html", sep = ""))
        if (file.exists(profileHtml)) {
            file.remove(profileHtml)
        }
        profileDir <- file.path(resources$tempPath, paste(filePrefix, 
            "_files", sep = ""))
        if (file.exists(profileDir)) {
            unlink(profileDir, recursive = TRUE)
        }
        rsconnectDir <- file.path(resources$tempPath, "rsconnect", 
            "documents", paste(filePrefix, ".html", sep = ""))
        if (.rs.dirExists(rsconnectDir)) {
            unlink(rsconnectDir, recursive = TRUE)
        }
        return(list())
    }, error = function(e) {
        return(list(error = .rs.scalar(e$message)))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.valueContentsImpl
function (val) 
{
    if (inherits(val, "ore.frame")) {
        query <- attr(val, "dataQry", exact = TRUE)
        if (is.null(query)) 
            return("NO_VALUE")
        attributes(query) <- NULL
        paste("   Query:", query)
    }
    else if (inherits(val, "pandas.core.frame.DataFrame")) {
        output <- reticulate::py_to_r(val$to_string(max_rows = 150L))
        strsplit(output, "\n", fixed = TRUE)[[1]]
    }
    else {
        output <- .rs.valueFromStr(val)
        n <- length(output)
        if (n > 150) {
            fmt <- "  [... %i lines omitted]"
            tail <- sprintf(fmt, n - 150)
            output <- c(output[2:150], tail)
        }
        else if (n > 1) {
            output <- output[-1]
        }
        output
    }
}
<environment: 0x000001883f4b86b8>

$.rs.platform.isWindows
[1] TRUE

$.rs.explorer.defaultRowLimit
[1] 1000
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.api.buildToolsInstall
function (action) 
{
    if (is.null(action) || !nzchar(action)) 
        return(.Call("rs_installBuildTools", PACKAGE = "(embedding)"))
    .rs.installBuildTools(action)
}
<environment: 0x000001883fdf9388>

$.rs.api.buildToolsExec
function (expr) 
{
    .rs.withBuildTools(expr)
}
<environment: 0x000001883fdf19d8>

$.rs.profileResources
function () 
{
    tempPath <- getOption("profvis.prof_output", default = .rs.profilesPath())
    tryCatch(dir.create(tempPath, recursive = TRUE, showWarnings = FALSE), 
        error = warning)
    list(tempPath = tempPath)
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalVisible
function () 
{
    .Call("rs_terminalVisible")
}
<environment: 0x000001883fdd1d00>

$.rs.odbcBundleReadIni
function (odbcinstPath) 
{
    if (!file.exists(odbcinstPath)) 
        return(list())
    lines <- readLines(odbcinstPath)
    data <- list()
    currentDriver <- "__header__"
    for (line in lines) {
        if (grepl("^ *\\[[^]]+\\] *", line)) {
            currentDriver <- gsub("^ *\\[|\\] *", "", line)
            data[[currentDriver]] <- ""
        }
        else if (!grepl("^ *$", line)) {
            if (identical(data[[currentDriver]], "")) 
                data[[currentDriver]] <- line
            else data[[currentDriver]] <- c(data[[currentDriver]], 
                line)
        }
    }
    data
}
<environment: 0x000001883f4b86b8>

$.rs.packageVersion
function (name, libPath, pkgs) 
{
    pkgs <- subset(pkgs, Package == name & LibPath == libPath)
    if (nrow(pkgs) == 1) 
        pkgs$Version
    else ""
}
<environment: 0x000001883f4b86b8>

$.rs.api.getPackageDependencies
function () 
{
    .Call("rs_packageDependencies", PACKAGE = "(embedding)")
}
<environment: 0x000001883fe20808>

$.rs.api.addJobProgress
function (job, units) 
{
    if (missing(job)) 
        stop("Must specify job ID to add progress to.")
    if (missing(units)) 
        stop("Must specify number of progress units to add")
    .Call("rs_addJobProgress", job, units, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f057ac8>

$.rs.explorer.getCachedObject
function (id, extractingCode = NULL, refresh = FALSE) 
{
    cache <- .rs.explorer.getCache()
    entry <- cache[[id]]
    if (is.null(entry)) 
        return(NULL)
    if (refresh && is.character(entry$title)) {
        tryCatch(expr = {
            object <- eval(parse(text = entry$title), envir = entry$envir)
            entry$object <- object
            cache[[id]] <- entry
        }, error = identity)
    }
    object <- entry$object
    if (is.null(extractingCode)) 
        return(object)
    if (.rs.reticulate.replIsActive()) {
        pyid <- paste("_rstudio_viewer", id, sep = "_")
        code <- sub("`__OBJECT__`", pyid, extractingCode, fixed = TRUE)
        builtins <- reticulate::import_builtins(convert = FALSE)
        cache <- .rs.reticulate.explorerCache()
        tryCatch(builtins$eval(code, cache, cache), error = warning)
    }
    else {
        envir <- new.env(parent = globalenv())
        envir[["__OBJECT__"]] <- object
        tryCatch(eval(parse(text = extractingCode), envir = envir), 
            error = warning)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.reYamlOptChunkBegin
function () 
{
    "^#\\| .*"
}
<environment: 0x000001883f4b86b8>

$.rs.extractHTMLBodyElement
function (html) 
{
    begin <- regexpr("<body[^>]*>", html, perl = TRUE)
    end <- regexpr("</body>", html, perl = TRUE)
    contents <- substring(html, begin + attr(begin, "match.length"), 
        end - 1)
    .rs.trimWhitespace(contents)
}
<environment: 0x000001883f4b86b8>

$.rs.getRmdRuntime
function (file) 
{
    lines <- readLines(file, warn = FALSE)
    yamlFrontMatter <- tryCatch(rmarkdown:::parse_yaml_front_matter(lines), 
        error = function(e) {
            list()
        })
    if (!is.null(yamlFrontMatter$runtime)) 
        yamlFrontMatter$runtime
    else ""
}
<environment: 0x000001883f4b86b8>

$.rs.pathRelativeToWorkingDir
function (target) 
{
    if (is.null(target)) {
        target
    }
    else {
        currentPath <- paste(getwd(), .Platform$file.sep, sep = "")
        fullPath <- path.expand(target)
        if (identical(substr(fullPath, 0, nchar(currentPath)), 
            currentPath)) {
            substr(fullPath, nchar(currentPath) + 1, nchar(fullPath))
        }
        else {
            target
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.diagnosticsReport
function () 
{
    invisible(.Call("rs_sourceDiagnostics", PACKAGE = "(embedding)"))
}
<environment: 0x000001883fcecc08>

$.rs.unloadPackage
function (packageName) 
{
    pkg = paste("package:", packageName, sep = "")
    detach(pos = match(pkg, search()))
}
<environment: 0x000001883f4b86b8>

$.rs.getHelpFromObject
function (object, envir, name = NULL) 
{
    namespace <- NULL
    if (is.primitive(object)) 
        namespace <- "base"
    else if (is.function(object)) {
        envString <- .rs.format(environment(object))[[1L]]
        if (!grepl("namespace:", envString)) 
            return()
        namespace <- sub(".*namespace:", "", envString)
        namespace <- sub(">.*", "", namespace)
    }
    else if (isS4(object)) 
        namespace <- attr(class(object), "package")
    if (is.null(namespace)) 
        return()
    ns <- try(asNamespace(namespace), silent = TRUE)
    if (inherits(ns, "try-error")) 
        return()
    datasets <- tryCatch(suppressWarnings(data(package = namespace)), 
        error = function(e) NULL)
    objectNames <- objects(ns, all.names = TRUE)
    datasetNames <- unname(grep(" ", datasets$results[, "Item"], 
        fixed = TRUE, value = TRUE, invert = TRUE))
    objects <- tryCatch(mget(objectNames, envir = ns, inherits = TRUE), 
        error = function(e) NULL)
    data <- lapply(datasetNames, function(x) {
        tryCatch(get(x, envir = ns), error = function(e) NULL)
    })
    if (length(data)) {
        objects <- c(objects, data)
        objectNames <- c(objectNames, datasetNames)
    }
    success <- FALSE
    for (i in seq_along(objects)) {
        if (!identical(class(object), class(objects[[i]]))) 
            next
        formals <- as.list(formals(base::identical))
        formals$x <- object
        formals$y <- objects[[i]]
        if ("ignore.environment" %in% names(formals)) 
            formals[["ignore.environment"]] <- TRUE
        result <- tryCatch(do.call(base::identical, formals), 
            error = function(e) FALSE)
        if (result) {
            success <- TRUE
            break
        }
    }
    if (success) {
        object <- objects[[i]]
        objectName <- objectNames[[i]]
        sigName <- if (is.null(name)) 
            objectName
        else name
        signature <- NULL
        if (is.function(object)) 
            signature <- sub("function ", sigName, .rs.getSignature(object))
        result <- .rs.getHelp(topic = objectName, package = namespace, 
            sig = signature)
        if (length(result)) 
            return(result)
        dotPos <- gregexpr(".", objectName, fixed = TRUE)[[1]]
        for (i in seq_along(dotPos)) {
            maybeGeneric <- substring(objectName, 1, dotPos[[i]] - 
                1)
            methods <- suppressWarnings(tryCatch(eval(substitute(methods(x), 
                list(x = maybeGeneric)), envir = envir), error = function(e) NULL))
            if (objectName %in% methods) {
                result <- .rs.getHelp(maybeGeneric)
                if (length(result)) 
                  return(result)
            }
        }
    }
    NULL
}
<bytecode: 0x000001883d22f818>
<environment: 0x000001883f4b86b8>

$.rs.tutorial.runTutorial
function (name, package, shiny_args = NULL) 
{
    if (.rs.tutorial.openExistingTutorial(name, package)) 
        return()
    .rs.tutorial.installPackageDependencies(name, package)
    shiny_args$launch.browser <- quote(rstudioapi:::tutorialLaunchBrowser)
    call <- substitute(learnr::run_tutorial(name = name, package = package, 
        shiny_args = shiny_args), list(name = name, package = package, 
        shiny_args = shiny_args))
    deparsed <- deparse(call)
    path <- tempfile("rstudio-tutorial-", fileext = ".R")
    writeLines(deparsed, con = path)
    job <- .rs.api.runScriptJob(path = path, name = paste("Tutorial:", 
        name), encoding = "UTF-8")
    tutorial <- .rs.tutorial.registryCreate(name, package)
    tutorial[["job"]] <- job
    .rs.setVar("tutorial.pendingTutorial", tutorial)
    invisible(job)
}
<environment: 0x000001883f4b86b8>

$.rs.RdLoadMacros
function (file) 
{
    dir <- dirname(dirname(file))
    macros <- suppressWarnings(tools::loadPkgRdMacros(dir))
    tools::loadPkgRdMacros(file.path(R.home("share"), "Rd", "macros", 
        "system.Rd"), macros = macros)
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletionsKeys
function (source, token) 
{
    builtins <- reticulate::import_builtins(convert = TRUE)
    object <- tryCatch(reticulate::py_eval(source, convert = FALSE), 
        error = identity)
    if (inherits(object, "error")) 
        return(.rs.python.emptyCompletions())
    method <- reticulate::py_get_attr(object, "keys", silent = TRUE)
    if (!inherits(method, "python.builtin.object")) 
        return(.rs.python.emptyCompletions())
    keys <- reticulate::py_to_r(method)
    candidates <- if (.rs.python.isPython3()) 
        as.character(builtins$list(reticulate::py_to_r(keys())))
    else reticulate::py_to_r(keys())
    .rs.python.completions(token, candidates)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleCheckPrereqsWindows
function () 
{
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.record_command_execution
function (commandId) 
{
    for (handle in names(.rs.commandCallbacks)) {
        handler <- get(handle, envir = .rs.commandCallbacks)
        if (!is.list(handler)) {
            next
        }
        if (!is.function(handler$callback)) {
            next
        }
        if (identical(handler$command, "*")) {
            handler$callback(commandId)
            next
        }
        if (identical(handler$command, commandId)) {
            handler$callback()
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.convertTheme
function (themePath, add, outputLocation, apply, force, globally) 
{
    tmTheme <- .rs.parseTmTheme(themePath)
    name <- tmTheme$name
    fileName <- paste0(tools::file_path_sans_ext(basename(themePath)), 
        ".rstheme")
    aceTheme <- .rs.convertTmTheme(tmTheme)
    rsTheme <- .rs.convertAceTheme(name, aceTheme$theme, aceTheme$isDark)
    isTemp <- is.null(outputLocation)
    location <- if (is.null(outputLocation)) 
        file.path(tempdir(), fileName)
    else file.path(outputLocation, fileName)
    if (!file.create(location)) {
        stop("Unable to create the theme file in the requested location: ", 
            location, ". Please see above for relevant warnings.", 
            call. = FALSE)
    }
    cat(paste(rsTheme, collapse = "\n"), file = location)
    if (add) {
        .rs.addTheme(location, apply, force, globally)
    }
    else if (apply) {
        stop("Invalid input: unable to apply a theme which has not been added.", 
            call. = FALSE)
    }
    name
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.python_go_to_definition
function (line, offset) 
{
    result <- .rs.python.goToDefinition(line, offset)
    .rs.scalar(result)
}
<environment: 0x000001883f4b86b8>

$.rs.getActivePythonStackTrace
function () 
{
    stack <- list()
    tryCatch({
        traceback <- reticulate::py_last_error()$traceback
        for (i in 1:length(traceback)) {
            lineData <- .rs.pyStackItemToLineDataList(traceback[[i]])
            if (!is.null(lineData)) 
                stack[[length(stack) + 1]] <- lineData
        }
    }, error = function(e) NULL)
    stack
}
<environment: 0x000001883f4b86b8>

$.rs.getSourceIndexCompletions
function (token) 
{
    .Call("rs_getSourceIndexCompletions", token)
}
<environment: 0x000001883f4b86b8>

$.rs.getHelpDataTableSpecialSymbol
function (what) 
{
    html <- strsplit(.rs.getHelp(what, "data.table", subset = FALSE)$html, 
        "\n")[[1L]]
    description <- grep(paste0("<p><code>", what, "</code>[^,]"), 
        html, value = TRUE)
    description <- sub("<li><p>", "", description)
    out <- list(html = paste0("<h2>data.table special symbol ", 
        what, "</h2><h3>Description</h3><p>", description, "</p>"), 
        signature = NULL, pkgname = "data.table")
    out
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_completions
function (token, string, context, numCommas, functionCallString, 
    chainObjectName, additionalArgs, excludeArgs, excludeArgsFromObject, 
    filePath, documentId, line, isConsole) 
{
    token <- .rs.setEncodingUnknownToUTF8(token)
    string <- .rs.setEncodingUnknownToUTF8(string)
    functionCallString <- .rs.setEncodingUnknownToUTF8(functionCallString)
    chainObjectName <- .rs.setEncodingUnknownToUTF8(chainObjectName)
    additionalArgs <- .rs.setEncodingUnknownToUTF8(additionalArgs)
    excludeArgs <- .rs.setEncodingUnknownToUTF8(excludeArgs)
    excludeArgsFromObject <- .rs.setEncodingUnknownToUTF8(excludeArgsFromObject)
    filePath <- .rs.setEncodingUnknownToUTF8(filePath)
    readLineCompletions <- .rs.readlineCompletions(token)
    if (!is.null(readLineCompletions)) 
        return(readLineCompletions)
    if (isConsole && .rs.reticulate.replIsActive()) 
        return(.rs.rpc.python_get_completions(line, NULL))
    if (.rs.injectKnitrParamsObject(documentId)) 
        on.exit(.rs.removeKnitrParamsObject(), add = TRUE)
    if (.rs.isCustomCompletionsEnabled()) {
        completions <- tryCatch(.rs.getCustomRCompletions(line), 
            error = identity)
        if (!inherits(completions, "error")) 
            return(completions)
    }
    envir <- .rs.getActiveFrame()
    filePath <- suppressWarnings(.rs.normalizePath(filePath))
    additionalArgs <- as.character(additionalArgs)
    excludeArgs <- as.character(excludeArgs)
    isPiped <- nzchar(chainObjectName)
    if (length(string)) {
        pipes <- c("%>%", "%<>%", "%T>%", "%>>%", "\\|>")
        pattern <- paste(pipes, collapse = "|")
        stringPipeMatches <- gregexpr(pattern, string[[1]], perl = TRUE)[[1]]
        if (!identical(c(stringPipeMatches), -1L)) {
            n <- length(stringPipeMatches)
            idx <- stringPipeMatches[n] + attr(stringPipeMatches, 
                "match.length")[n]
            isPiped <- TRUE
            string[[1]] <- gsub("^[\\s\\n]*", "", substring(string[[1]], 
                idx), perl = TRUE)
            firstPipeIdx <- stringPipeMatches[[1]]
            parentObject <- .rs.trimWhitespace(substring(functionCallString, 
                1, firstPipeIdx - 1L))
            functionCallString <- gsub("^\\s*", "", substring(functionCallString, 
                idx), perl = TRUE)
            functionCallString <- sub("(", paste("(", parentObject, 
                ",", sep = ""), functionCallString, fixed = TRUE)
        }
        else if (nzchar(chainObjectName)) {
            functionCallString <- sub("(", paste("(", chainObjectName, 
                ",", sep = ""), functionCallString, fixed = TRUE)
        }
    }
    if (isPiped && context[[1L]] == .rs.acContextTypes$FUNCTION) 
        numCommas[[1L]] <- numCommas[[1L]] + 1L
    functionCall <- tryCatch({
        parse(text = .rs.finishExpression(functionCallString))[[1]]
    }, error = function(e) NULL)
    if (.rs.acContextTypes$FUNCTION %in% context) {
        scope <- string[[1]]
        custom <- .rs.findCustomHelpContext(scope, "help_formals_handler")
        if (!is.null(custom)) {
            formals <- custom$handler(custom$topic, custom$source)
            if (!is.null(formals)) {
                results <- paste(formals$formals, "= ")
                results <- .rs.selectFuzzyMatches(results, token)
                return(.rs.makeCompletions(token = token, results = results, 
                  packages = scope, type = .rs.acCompletionTypes$ARGUMENT, 
                  excludeOtherCompletions = TRUE, helpHandler = formals$helpHandler, 
                  context = .rs.acContextTypes$FUNCTION))
            }
            else {
                return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
            }
        }
    }
    if (.rs.acContextTypes$HELP %in% context) 
        return(.rs.getCompletionsHelp(token))
    if (.rs.acContextTypes$ROXYGEN %in% context) 
        return(.rs.attemptRoxygenTagCompletion(token, line))
    if (.rs.acContextTypes$PLUMBER %in% context) 
        return(.rs.attemptPlumberTagCompletion(token, line))
    if (length(string) && string[[1]] == "install.packages" && 
        numCommas[[1]] == 0) 
        return(.rs.getCompletionsInstallPackages(token))
    if (nzchar(token) && length(string) && string[[1]] %in% c("help", 
        "example") && numCommas[[1]] == 0) {
        return(.rs.getCompletionsHelp(token, quote = TRUE))
    }
    if (length(string) && string[[1]] == "vignette" && numCommas[[1]] == 
        0) 
        return(.rs.getCompletionsVignettes(token))
    if (length(string) && string[[1]] %in% c(".Call", ".C", ".Fortran", 
        ".External") && numCommas[[1]] == 0) {
        return(.rs.getCompletionsNativeRoutine(token, string[[1]]))
    }
    if (length(context) && context[[1]] == .rs.acContextTypes$FUNCTION && 
        string[[1]] == "data" && numCommas[[1]] == 0) {
        return(.rs.getCompletionsData(token))
    }
    if (.rs.acContextTypes$PACKAGE %in% context) 
        return(.rs.getCompletionsPackages(token = token, appendColons = TRUE, 
            excludeOtherCompletions = TRUE))
    if (length(string) && string[[1]] %in% c("Sys.getenv", "Sys.setenv") && 
        numCommas[[1]] == 0) 
        return(.rs.getCompletionsEnvironmentVariables(token))
    if (length(string) && string[[1]] %in% c("use_virtualenv", 
        "reticulate::use_virtualenv") && numCommas[[1]] == 0) {
        return(.rs.getCompletionsPythonVirtualEnvironments(token))
    }
    if (!length(string)) {
        if (token == "") 
            return(.rs.emptyCompletions(excludeOtherCompletions = TRUE))
        completions <- Reduce(.rs.appendCompletions, list(.rs.getCompletionsSearchPath(token), 
            .rs.getCompletionsNAMESPACE(token, documentId), .rs.getCompletionsPackages(token, 
                TRUE), .rs.getCompletionsActiveFrame(token, envir), 
            .rs.getCompletionsLibraryContext(token, string, context, 
                numCommas, functionCall, documentId, envir)))
        if (!.rs.startsWith(token, ".")) {
            startsWithDot <- .rs.startsWith(completions$results, 
                ".")
            completions <- .rs.subsetCompletions(completions, 
                which(!startsWithDot))
        }
        if (.rs.isRScriptInPackageBuildTarget(filePath)) {
            pkgName <- .rs.packageNameForSourceFile(filePath)
            completions <- .rs.appendCompletions(completions, 
                .rs.getCompletionsActivePackage(token, pkgName))
        }
        return(.rs.sortCompletions(completions, token))
    }
    if ("install.packages" %in% string[[1]]) {
        fn <- .rs.getAnywhere("install.packages", envir)
        if (is.function(fn) && identical(names(formals(fn)), 
            "...")) {
            string[[1]] <- "utils::install.packages"
        }
    }
    if (string[[1]] %in% c("library", "require", "requireNamespace") && 
        numCommas[[1]] == 0) {
        quote <- !(string[[1]] %in% c("library", "require"))
        return(.rs.getCompletionsPackages(token, excludeOtherCompletions = TRUE, 
            quote = quote))
    }
    if (.rs.acContextTypes$FILE %in% context) {
        whichIndex <- which(context == .rs.acContextTypes$FILE)
        tokenToUse <- string[[whichIndex]]
        directoriesOnly <- FALSE
        if (length(string) > whichIndex) {
            if (string[[whichIndex + 1]] %in% c("list.files", 
                "list.dirs", "dir", "setwd")) {
                directoriesOnly <- TRUE
            }
        }
        isNotebook <- .rs.endsWith(tolower(filePath), ".rmd") || 
            .rs.endsWith(tolower(filePath), ".qmd")
        path <- NULL
        if (isNotebook) {
            path <- .Call("rs_getNotebookWorkingDir", filePath, 
                documentId)
        }
        if (is.null(path) && isNotebook) {
            path <- .rs.markdown.resolveCompletionRoot(filePath)
        }
        if (is.null(path)) {
            path <- getwd()
        }
        return(.rs.getCompletionsFile(token = tokenToUse, path = path, 
            quote = FALSE, directoriesOnly = directoriesOnly))
    }
    if (context[[1]] %in% c(.rs.acContextTypes$DOLLAR, .rs.acContextTypes$DOUBLE_BRACKET) && 
        tolower(basename(filePath)) == "server.r" && string[[1]] %in% 
        c("input", "output")) {
        completions <- .rs.getCompletionsFromShinyUI(token, filePath, 
            string[[1]], context[[1]])
        if (!is.null(completions)) 
            return(completions)
    }
    if (context[[1]] == .rs.acContextTypes$DOLLAR && tolower(basename(filePath)) == 
        "server.r" && string[[1]] == "session") {
        completions <- .rs.getCompletionsShinySession(token)
        if (!is.null(completions)) 
            return(completions)
    }
    if (context[[1]] == .rs.acContextTypes$FUNCTION && tolower(basename(filePath)) == 
        "ui.r" && numCommas[[1]] == 0 && .rs.mightBeShinyFunction(string[[1]])) {
        completions <- .rs.getCompletionsFromShinyServer(token, 
            filePath, string[[1]], context[[1]])
        if (!is.null(completions)) 
            return(completions)
    }
    completions <- if (string[[1]] == "attr") {
        .rs.getCompletionsAttr(token, functionCall, envir)
    }
    else if (string[[1]] == "getOption" && numCommas[[1]] == 
        0) {
        .rs.getCompletionsGetOption(token)
    }
    else if (string[[1]] == "options" && context == .rs.acContextTypes$FUNCTION) {
        .rs.getCompletionsOptions(token)
    }
    else {
        .rs.emptyCompletions()
    }
    dontLookBack <- length(context) && context[[1]] %in% c(.rs.acContextTypes$DOLLAR, 
        .rs.acContextTypes$AT, .rs.acContextTypes$NAMESPACE_EXPORTED, 
        .rs.acContextTypes$NAMESPACE_ALL)
    if (dontLookBack) {
        if (context[[1]] %in% c(.rs.acContextTypes$DOLLAR, .rs.acContextTypes$AT)) {
            completions <- .rs.getCompletionsDollar(token, string[[1]], 
                functionCall, envir, context[[1]] == .rs.acContextTypes$AT)
        }
        else if (context[[1]] %in% c(.rs.acContextTypes$NAMESPACE_EXPORTED, 
            .rs.acContextTypes$NAMESPACE_ALL)) {
            completions <- .rs.getCompletionsNamespace(token, 
                string[[1]], context[[1]] == .rs.acContextTypes$NAMESPACE_EXPORTED, 
                envir)
        }
    }
    else {
        for (i in seq_along(string)) {
            completions <- .rs.appendCompletions(completions, 
                .rs.getRCompletions(token, i, string[[i]], context[[i]], 
                  numCommas[[i]], functionCall, documentId, envir))
        }
    }
    if (!(context[[1]] == .rs.acContextTypes$FUNCTION && string[[1]] == 
        "group_by")) {
        completions <- .rs.appendCompletions(completions, .rs.getRChainCompletions(token, 
            chainObjectName, additionalArgs, excludeArgs, excludeArgsFromObject, 
            envir))
    }
    if (token != "" && context[[1]] %in% c(.rs.acContextTypes$UNKNOWN, 
        .rs.acContextTypes$FUNCTION, .rs.acContextTypes$ARGUMENT, 
        .rs.acContextTypes$SINGLE_BRACKET, .rs.acContextTypes$DOUBLE_BRACKET)) {
        completions <- Reduce(.rs.appendCompletions, list(completions, 
            .rs.getCompletionsSearchPath(token), .rs.getCompletionsNAMESPACE(token, 
                documentId), .rs.getCompletionsActiveFrame(token, 
                envir), .rs.getCompletionsLibraryContext(token, 
                string[[1]], context[[1]], numCommas[[1]], functionCall, 
                documentId, envir)))
        if (.rs.isRScriptInPackageBuildTarget(filePath)) {
            pkgName <- .rs.packageNameForSourceFile(filePath)
            completions <- .rs.appendCompletions(completions, 
                .rs.getCompletionsActivePackage(token, pkgName))
        }
    }
    if (token != "" && .rs.acContextTypes$UNKNOWN %in% context) 
        completions <- .rs.appendCompletions(completions, .rs.getCompletionsPackages(token, 
            TRUE))
    for (i in seq_along(context)) {
        if (context[[i]] %in% c(.rs.acContextTypes$FUNCTION, 
            .rs.acContextTypes$UNKNOWN)) {
            if (string[[i]] %in% c("help", "str", "args", "debug", 
                "debugonce", "trace")) {
                completions$overrideInsertParens <- .rs.scalar(TRUE)
            }
            else {
                object <- .rs.getAnywhere(string[[i]], envir)
                if (is.function(object)) {
                  argNames <- .rs.getFunctionArgumentNames(object)
                  if (any(c("f", "fun", "func") %in% tolower(gsub("[^a-zA-Z]", 
                    "", argNames)))) 
                    completions$overrideInsertParens <- .rs.scalar(TRUE)
                }
            }
        }
    }
    completions <- .rs.sortCompletions(completions, token)
    completions$token <- token
    completions
}
<bytecode: 0x0000018840e05128>
<environment: 0x000001883f4b86b8>

$.rs.secureDownloadMethod
function () 
{
    libcurlHandles404 <- function() {
        getRversion() >= "3.3" && .rs.haveRequiredRSvnRev(69197)
    }
    isR32 <- getRversion() >= "3.2"
    isR42 <- getRversion() >= "4.2"
    haveLibcurl <- isR32 && capabilities("libcurl") && libcurlHandles404()
    posixMethod <- function(utility) {
        if (haveLibcurl) 
            "libcurl"
        else if (nzchar(Sys.which(utility))) 
            utility
        else ""
    }
    sysName <- Sys.info()[["sysname"]]
    if (identical(sysName, "Windows")) {
        if (isR42 && haveLibcurl) 
            "libcurl"
        else if (isR32) 
            "wininet"
        else if (isTRUE(.rs.setInternet2(NA))) 
            "internal"
        else ""
    }
    else if (identical(sysName, "Darwin")) {
        posixMethod("curl")
    }
    else if (identical(sysName, "Linux")) {
        method <- posixMethod("wget")
        if (!nzchar(method)) 
            method <- posixMethod("curl")
        method
    }
    else {
        ""
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_server_urls
function () 
{
    servers <- rsconnect::servers()
    for (col in c("name", "url")) {
        if (col %in% colnames(servers)) {
            servers[[col]] <- as.character(servers[[col]])
        }
    }
    .rs.scalarListFromFrame(servers)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_data_preview
function (path) 
{
    nrows <- 20
    lines <- readLines(path, n = nrows, warn = F)
    siglines <- grep("^[^#].*", lines, value = TRUE)
    comment <- ""
    if (length(siglines) < length(lines)) {
        comment <- "#"
    }
    firstline <- siglines[1]
    dataline <- siglines[2]
    if (is.na(dataline) || length(grep("[^\\s]+", dataline)) == 
        0) 
        dataline <- firstline
    sep <- ""
    if (length(grep("\\t", firstline)) > 0) {
        sep <- "\t"
    }
    else if (length(grep(";", firstline)) > 0) {
        sep <- ";"
    }
    else if (length(grep(",", firstline)) > 0) {
        sep <- ","
    }
    dec <- "."
    if (length(grep("\\.", dataline)) == 0 && length(grep(",", 
        dataline)) > 0 && sep != ",") {
        dec <- ","
    }
    header <- length(grep("[0-9]", firstline)) == 0
    quote <- "\""
    output <- .rs.parseDataFile(path, encoding = "unknown", header = header, 
        sep = sep, dec = dec, quote = quote, comment = comment, 
        nrows = nrows)
    list(inputLines = paste(lines, collapse = "\n"), output = output, 
        outputNames = names(output), encoding = "unknown", header = header, 
        separator = sep, decimal = dec, quote = quote, comment = comment, 
        defaultStringsAsFactors = ifelse(getRversion() >= "4.2.0", 
            FALSE, default.stringsAsFactors()))
}
<environment: 0x000001883f4b86b8>

$.rs.setDefaultChunkOptions
function () 
{
    chunkOptions <- knitr::opts_chunk$get()
    if (!exists(".rs.knitr.chunkReferences", envir = .rs.toolsEnv())) 
        assign(".rs.knitr.chunkReferences", list(), envir = .rs.toolsEnv())
    chunkReferences <- get(".rs.knitr.chunkReferences", envir = .rs.toolsEnv())
    if (!is.null(chunkOptions$connection) && !is.character(chunkOptions$connection)) {
        idReference <- length(chunkReferences) + 1
        chunkReferences[[idReference]] <- chunkOptions$connection
        chunkOptions$connection <- idReference
    }
    assign(".rs.knitr.chunkOptions", chunkOptions, envir = .rs.toolsEnv())
    knitrCode <- knitr:::knit_code$get()
    assign(".rs.knitr.code", knitrCode, envir = .rs.toolsEnv())
    knitrDir <- knitr::opts_knit$get("root.dir")
    assign(".rs.knitr.root.dir", knitrDir, envir = .rs.toolsEnv())
    defaults <- list(error = .rs.scalar(FALSE))
    knitr::opts_chunk$restore(defaults)
    knitr:::knit_code$restore(list())
    knitr::opts_knit$set(root.dir = NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.callAs
function (name, f, ...) 
{
    withCallingHandlers(tryCatch(f(...), error = function(e) {
        cat("Error in ", name, " : ", e$message, "\n", sep = "")
    }), warning = function(w) {
        if (getOption("warn") >= 0) 
            cat("Warning in ", name, " :\n  ", w$message, "\n", 
                sep = "")
        invokeRestart("muffleWarning")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.add_content
function (content, ..., replace) 
c(content, do.call(sprintf, list(paste(..., sep = "\n"), replace)))
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.connectionOpenedImpl
function (type, host, displayName, icon = NULL, connectCode, 
    disconnect, listObjectTypes, listObjects, listColumns, previewObject, 
    connectionObject, actions = NULL) 
{
    if (!inherits(listObjectTypes, "function")) {
        stop("listObjectTypes must be a function returning a list of object types", 
            call. = FALSE)
    }
    promote <- function(name, l) {
        if (length(l) == 0) 
            return(list())
        if (is.null(l$contains)) {
            return(list(list(name = name, icon = l$icon, contains = "data")))
        }
        return(unlist(append(list(list(list(name = name, icon = l$icon, 
            contains = names(l$contains)))), lapply(names(l$contains), 
            function(name) {
                promote(name, l$contains[[name]])
            })), recursive = FALSE))
    }
    objectTree <- listObjectTypes()
    objectTypes <- lapply(names(objectTree), function(name) {
        promote(name, objectTree[[name]])
    })[[1]]
    connection <- list(type = type, host = host, displayName = displayName, 
        icon = icon, connectCode = connectCode, disconnect = disconnect, 
        objectTypes = objectTypes, listObjects = listObjects, 
        listColumns = listColumns, previewObject = previewObject, 
        actions = actions, connectionObject = connectionObject)
    class(connection) <- "rstudioConnection"
    .rs.validateConnection(connection)
    uuid <- .Call("rs_generateShortUuid", PACKAGE = "(embedding)")
    cacheKey <- paste(connection$type, connection$host, uuid, 
        sep = "_")
    assign(cacheKey, value = connection, envir = .rs.activeConnections)
    invisible(.Call("rs_connectionOpened", connection, PACKAGE = "(embedding)"))
}
<environment: 0x000001883f4b86b8>

$.rs.pyStackItemToLineDataList
function (item) 
{
    matches <- regmatches(item, regexec("^\\s+\\w+ \\\"([^\\\"]+)\\\", \\w+ (\\d+), \\w+ ([A-Za-z_0-9]+).*$", 
        item))[[1]]
    if (length(matches) == 4) {
        list(func = .rs.scalar(matches[[4]]), file = .rs.scalar(matches[[2]]), 
            line_number = .rs.scalar(matches[[3]]), end_line_nubmer = .rs.scalar(matches[[3]]), 
            character_number = .rs.scalar(0), character_number = .rs.scalar(0))
    }
    else {
        NULL
    }
}
<environment: 0x000001883f4b86b8>

$.rs.shinyUICompletions
function (file) 
{
    fileCacheName <- paste(file, "shinyUILastModifiedTime", sep = "-")
    completionsCacheName <- paste(file, "shinyUICompletions", 
        sep = "-")
    info <- .rs.fileInfo(file)
    mtime <- info[1, "mtime"]
    if (identical(mtime, .rs.get(fileCacheName)) && !is.null(.rs.get(completionsCacheName))) {
        return(.rs.get(completionsCacheName))
    }
    parsed <- tryCatch(suppressWarnings(parse(file)), error = function(e) NULL)
    if (is.null(parsed)) 
        return(NULL)
    inputEnv <- new.env(parent = emptyenv())
    outputEnv <- new.env(parent = emptyenv())
    inputCount <- new.env(parent = emptyenv())
    inputCount$count <- 1
    outputCount <- new.env(parent = emptyenv())
    outputCount$count <- 1
    shinyFunctions <- .rs.getInferredCompletions("shiny")$functions
    lapply(parsed, function(object) {
        .rs.doShinyUICompletions(object, inputEnv, outputEnv, 
            inputCount, outputCount, shinyFunctions)
    })
    completions <- list(input = unlist(mget(objects(inputEnv), 
        envir = inputEnv), use.names = FALSE), output = unlist(mget(objects(outputEnv), 
        envir = outputEnv), use.names = FALSE))
    .rs.assign(fileCacheName, mtime)
    .rs.assign(completionsCacheName, completions)
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.sql.listTables
function (conn) 
{
    conn <- .rs.sql.asDBIConnection(conn)
    if (is.null(conn)) 
        return(character())
    keys <- ls(envir = .rs.sql.defunctConnections)
    for (key in keys) if (!DBI::dbIsValid(.rs.sql.defunctConnections[[key]])) 
        rm(key, envir = .rs.sql.defunctConnections)
    timeout <- as.numeric(getOption("sql.completion.timeout", 
        2))
    if (timeout == 0) 
        return(character())
    id <- digest::digest(conn)
    if (!is.null(.rs.sql.defunctConnections[[id]])) 
        return(character())
    time <- system.time(tables <- .rs.tryCatch(DBI::dbListTables(conn)))
    if (time[["user.self"]] > timeout) {
        .rs.sql.defunctConnections[[id]] <- conn
        return(character())
    }
    if (inherits(tables, "error")) 
        return(character())
    tables
}
<environment: 0x000001883f4b86b8>

$.rs.validateAndTransformLocation
function (location) 
{
    invalidRangeMsg <- "'ranges' should be a list of 4-element integer vectors"
    if (!is.list(location) || inherits(location, "document_range")) 
        location <- list(location)
    ranges <- lapply(location, function(el) {
        if (identical(el, Inf)) 
            el <- c(Inf, 0, Inf, 0)
        n <- length(el)
        if (n == 2 && is.numeric(el)) 
            el <- c(el, el)
        if (is.list(el) && all(c("start", "end") %in% names(el))) 
            el <- c(el$start, el$end)
        if (length(el) != 4 || !is.numeric(el) || any(is.na(el))) 
            stop(invalidRangeMsg, call. = FALSE)
        el[el < 1] <- 1
        el[is.infinite(el)] <- NA
        result <- as.integer(el) - 1L
        result[is.na(result)] <- as.integer(2^31 - 1)
        result
    })
    ranges
}
<environment: 0x000001883f4b86b8>

$.rs.rnbHooks.print.shiny.tag.list
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    htmlfile <- tempfile("_rs_html_", tmpdir = ctx$outputFolder, 
        fileext = ".html")
    depfile <- tempfile("_rs_html_deps_", tmpdir = ctx$outputFolder, 
        fileext = ".json")
    rendered <- htmltools::renderTags(x)
    htmldeps <- rendered$dependencies
    html <- rendered$html
    if (length(htmldeps)) {
        cat(.rs.toJSON(htmldeps, unbox = TRUE), file = depfile, 
            sep = "\n")
        htmltools::save_html(x, file = htmlfile, libdir = ctx$libraryFolder)
    }
    else {
        cat(as.character(html), file = htmlfile, sep = "\n")
    }
    .rs.recordHtmlWidget(x, htmlfile, depfile)
}
<environment: 0x000001883f4b86b8>

$.rs.python.generateHtmlHelp
function (code) 
{
    Encoding(code) <- "UTF-8"
    code <- sub("[.]html$", "", code)
    dir <- file.path(tempdir(), "reticulate-python-help")
    if (!.rs.ensureDirectory(dir)) {
        warning("Failed to create Python help directory", call. = FALSE)
        return("")
    }
    stem <- utils::URLencode(code, reserved = TRUE)
    path <- file.path(dir, paste(stem, "html", sep = "."))
    if (file.exists(path)) 
        return(path)
    pydoc <- reticulate::import("pydoc", convert = TRUE)
    methods <- list(function() reticulate::py_eval(code), function() pydoc$resolve(code)[[1]])
    resolved <- NULL
    for (method in methods) {
        resolved <- .rs.tryCatch(method())
        if (!inherits(resolved, "error")) 
            break
    }
    if (inherits(resolved, "error")) {
        fmt <- "No Python documentation found for '%s'."
        warning(sprintf(fmt, code), call. = FALSE)
        return("")
    }
    module <- "<unknown>"
    if (reticulate::py_has_attr(resolved, "__module__")) 
        module <- resolved[["__module__"]]
    name <- "<unknown>"
    if (reticulate::py_has_attr(resolved, "__name__")) 
        name <- resolved[["__name__"]]
    if (identical(module, "<unknown>") && reticulate::py_has_attr(resolved, 
        "__class__")) {
        builtins <- reticulate::import_builtins(convert = TRUE)
        output <- builtins$repr(resolved[["__class__"]])
        if (grepl("<type '(.*)'>", output)) {
            class <- gsub("<type '(.*)'>", "\\1", output)
            splat <- .rs.strsplit(class, ".", fixed = TRUE)
            module <- paste(head(splat, n = 1), collapse = ".")
        }
    }
    reticulate::py_run_string("\n\n# Create HTML documentation object\ndef _rstudio_html_generator_():\n   import pydoc\n   html = pydoc.HTMLDoc()\n\n   # Override the heading function\n   def _heading(title, fgcol, bgcol, extra = ''):\n      return '''\n   <table width=\"100%%\" cellspacing=0 cellpadding=2 border=0 summary=\"heading\">\n   <tr><td><h2>%s</h2></td></tr>\n   </table>\n      ''' % (title)\n   \n   html.heading = _heading\n   return html\n", 
        local = FALSE)
    main <- reticulate::import_main(convert = TRUE)
    generator <- reticulate::py_to_r(reticulate::py_get_attr(main, 
        "_rstudio_html_generator_"))
    html <- generator()
    reticulate::py_del_attr(main, "_rstudio_html_generator_")
    page <- if (inherits(resolved, "numpy.ufunc")) {
        html$page(paste("numpy function", name), html$docroutine(resolved, 
            name))
    }
    else {
        pydoc <- reticulate::import("pydoc", convert = TRUE)
        html$page(pydoc$describe(resolved), html$document(resolved, 
            name))
    }
    page <- gsub("\\s?bgcolor=\"#[0-9a-fA-F]{6}\"", "", page, 
        perl = TRUE)
    writeLines(page, con = path)
    path
}
<environment: 0x000001883f4b86b8>

$.rs.breakOnError
function (userOnly) 
{
    calls <- sys.calls()
    if (length(calls) < 4) 
        return()
    foundUserCode <- FALSE
    inSource <- FALSE
    if (userOnly) {
        for (n in 1:(length(calls) - 1)) {
            isSourceCall <- FALSE
            if (.rs.isSourceCall(sys.call(n))) {
                isSourceCall <- TRUE
                inSource <- TRUE
            }
            func <- .rs.untraced(sys.function(n))
            srcref <- attr(func, "srcref")
            if (!is.null(srcref) && !is.null(attr(srcref, "srcfile"))) {
                if (inSource && !isSourceCall) {
                  inSource <- FALSE
                }
                else {
                  foundUserCode <- TRUE
                  break
                }
            }
        }
    }
    if (foundUserCode || !userOnly) {
        frame <- length(sys.frames()) - 2
        if (identical(deparse(sys.call(frame)[[1]]), "stop")) 
            frame <- frame - 1
        if (identical(deparse(sys.call(frame)[[1]]), "stopifnot")) 
            frame <- frame - 1
        eval(substitute(browser(skipCalls = pos), list(pos = (length(sys.frames()) - 
            frame) + 2)), envir = sys.frame(frame))
    }
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE

$.rs.hasExternalPointer
function (object, nullPtr = FALSE) 
{
    .Call("rs_hasExternalPointer", object, nullPtr, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.outputSourceHtml
function (fileName, fileContents, rnbData, chunkId, metadata, 
    ...) 
{
    jsonName <- .rs.withChangedExtension(fileName, ".json")
    jsonPath <- file.path(rnbData$cache_path, chunkId, jsonName)
    if (file.exists(jsonPath)) {
        jsonContents <- .rs.fromJSON(.rs.readFile(jsonPath, encoding = "UTF-8"))
        for (i in seq_along(jsonContents)) class(jsonContents[[i]]) <- "html_dependency"
        bodyEl <- .rs.extractHTMLBodyElement(fileContents)
        annotated <- rmarkdown:::html_notebook_annotated_output(bodyEl, 
            "htmlwidget", list(dependencies = jsonContents, metadata = metadata))
        preserved <- htmltools::htmlPreserve(annotated)
        widget <- knitr::asis_output(preserved)
        attr(widget, "knit_meta") <- jsonContents
        return(widget)
    }
    annotated <- rmarkdown:::html_notebook_annotated_output(fileContents, 
        "html", list(metadata = metadata))
    preserved <- htmltools::htmlPreserve(annotated)
    knitr::asis_output(preserved)
}
<environment: 0x000001883f4b86b8>

$.rs.registerHook
function (name, package, hookFactory, namespace = FALSE) 
{
    library(package, character.only = TRUE, quietly = TRUE)
    packageName <- paste("package", package, sep = ":")
    original <- base::get(name, packageName, mode = "function")
    if (is.null(original)) {
        fmt <- "internal error: function %s not found"
        msg <- sprintf(fmt, shQuote(name))
        stop(msg, call. = FALSE)
    }
    new <- hookFactory(original)
    packageEnv <- as.environment(packageName)
    unlockBinding(name, packageEnv)
    assign(name, new, packageName)
    lockBinding(name, packageEnv)
    if (namespace) {
        ns <- asNamespace(package)
        if (exists(name, envir = ns, mode = "function")) {
            unlockBinding(name, ns)
            assign(name, new, envir = ns)
            lockBinding(name, ns)
        }
    }
}
<bytecode: 0x000001883f29c930>
<environment: 0x000001883f4b86b8>

$.rs.api.removeJob
function (job) 
{
    if (missing(job)) 
        stop("Must specify job ID to remove.")
    .Call("rs_removeJob", job, PACKAGE = "(embedding)")
    invisible(NULL)
}
<environment: 0x000001883f03ba58>

$.rs.rnb.outputSource
function (rnbData) 
{
    force(rnbData)
    result <- function(code, context, ...) {
        chunkId <- .rs.rnb.resolveActiveChunkId(rnbData, context$label)
        includeSource <- isTRUE(context$echo) && isTRUE(context$include)
        if (identical(context$engine, "js") || identical(context$engine, 
            "css")) {
            htmlOutput <- ""
            if (isTRUE(context$eval)) {
                if (identical(context$engine, "js")) {
                  htmlOutput <- paste(c("<script type=\"text/javascript\">", 
                    code, "</script>"), collapse = "\n")
                }
                else if (identical(context$engine, "css")) {
                  htmlOutput <- paste(c("<style type=\"text/css\">", 
                    code, "</style>"), collapse = "\n")
                }
            }
            return(knitr::asis_output(htmlOutput))
        }
        else if (is.null(chunkId)) {
            if (includeSource) {
                attributes <- list(class = .rs.rnb.engineToCodeClass(context$engine))
                if (isTRUE(context$tidy)) {
                  args <- c(list(text = code, output = FALSE), 
                    context$tidy.opts)
                  formatted <- do.call(formatR::tidy_source, 
                    args)
                  code <- formatted$text.tidy
                }
                if (!is.null(context$indent)) {
                  return(.rs.rnb.renderVerbatimConsoleInput(code, 
                    tolower(context$engine), ""))
                }
                else {
                  return(rmarkdown::html_notebook_output_code(code, 
                    attributes = attributes))
                }
            }
            return(knitr::asis_output(""))
        }
        chunkData <- .rs.coalesceCsvOutput(rnbData$chunk_data[[chunkId]])
        outputList <- .rs.enumerate(chunkData, function(fileName, 
            fileContents) {
            metadata <- NULL
            metadataName <- .rs.withChangedExtension(fileName, 
                ".metadata")
            metadataPath <- file.path(rnbData$cache_path, chunkId, 
                metadataName)
            if (file.exists(metadataPath)) 
                metadata <- .rs.fromJSON(.rs.readFile(metadataPath, 
                  encoding = "UTF-8"))
            ext <- tools::file_ext(fileName)
            handler <- .rs.rnb.outputHandlers[[ext]]
            if (!is.function(handler)) 
                return(NULL)
            handler(code = code, context = context, fileName = fileName, 
                fileContents = fileContents, metadata = metadata, 
                rnbData = rnbData, chunkId = chunkId, includeSource = includeSource)
        })
        filtered <- Filter(Negate(is.null), outputList)
        lapply(filtered, function(x) {
            if (!is.list(x)) 
                list(x)
            else x
        })
    }
    attr(result, "pre_knit") <- function() {
        options <- rnbData$chunk_info$default_chunk_options
        if (is.null(options)) 
            return()
        options[["fig.dim"]] <- as.numeric(options[["fig.dim"]])
        knitr::opts_chunk$set(options)
        invisible(NULL)
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletionsFiles
function (token) 
{
    os <- reticulate::import("os", convert = TRUE)
    token <- gsub("^['\"]|['\"]$", "", token)
    expanded <- path.expand(token)
    indices <- gregexpr("/", expanded, fixed = TRUE)[[1]]
    if (!identical(c(indices), -1L)) {
        lhs <- substring(expanded, 1, tail(indices, n = 1))
        rhs <- substring(expanded, tail(indices, n = 1) + 1)
        files <- paste(lhs, list.files(lhs), sep = "")
    }
    else {
        lhs <- "."
        rhs <- expanded
        files <- list.files(os$getcwd())
    }
    completions <- .rs.python.completions(expanded, files)
    attr(completions, "token") <- token
    info <- file.info(completions)
    attr(completions, "types") <- ifelse(info$isdir, 16, 15)
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.package_skeleton
function (packageName, packageDirectory, sourceFiles, usingRcpp) 
{
    Encoding(packageDirectory) <- "UTF-8"
    sourceFiles <- as.character(sourceFiles)
    packageDirectory <- path.expand(packageDirectory)
    if (!grepl("^[[:alpha:]][[:alnum:].]*", packageName)) 
        return(.rs.error("Invalid package name: the package name must start ", 
            "with a letter and follow with only alphanumeric characters"))
    if (file.exists(packageDirectory)) {
        containedFiles <- list.files(packageDirectory)
        if (length(containedFiles)) {
            return(.rs.error("Folder '", packageDirectory, "' ", 
                "already exists and is not empty"))
        }
    }
    else {
        if (!dir.create(packageDirectory, recursive = TRUE)) 
            return(.rs.error("Failed to create directory '", 
                packageDirectory, "'"))
    }
    getDevtoolsOption <- function(optionName, default, collapse = " ") {
        devtoolsDesc <- getOption("devtools.desc")
        if (!length(devtoolsDesc)) 
            return(default)
        option <- devtoolsDesc[[optionName]]
        if (is.null(option)) 
            return(default)
        paste(option, collapse = collapse)
    }
    Author <- getDevtoolsOption("Author", "Who wrote it")
    Maintainer <- getDevtoolsOption("Maintainer", "The package maintainer <yourself@somewhere.net>")
    License <- getDevtoolsOption("License", "What license is it under?", 
        ", ")
    DESCRIPTION <- list(Package = packageName, Type = "Package", 
        Title = "What the Package Does (Title Case)", Version = "0.1.0", 
        Author = Author, Maintainer = Maintainer, Description = c("More about what it does (maybe more than one line)", 
            "Use four spaces when indenting paragraphs within the Description."), 
        License = License, Encoding = "UTF-8", LazyData = "true")
    NAMESPACE <- c("exportPattern(\"^[[:alpha:]]+\")")
    if (usingRcpp) {
        dir.create(file.path(packageDirectory, "src"), showWarnings = FALSE)
        rcppImportsStatement <- "Rcpp"
        ip <- installed.packages()
        if ("Rcpp" %in% rownames(ip)) 
            rcppImportsStatement <- sprintf("Rcpp (>= %s)", ip["Rcpp", 
                "Version"])
        DESCRIPTION$Imports <- c(DESCRIPTION$Imports, rcppImportsStatement)
        DESCRIPTION$LinkingTo <- c(DESCRIPTION$LinkingTo, "Rcpp")
        if (.rs.isPackageVersionInstalled("Rcpp", "0.12.11")) 
            registration <- ", .registration = TRUE"
        else registration <- ""
        NAMESPACE <- c(NAMESPACE, "importFrom(Rcpp, evalCpp)", 
            sprintf("useDynLib(%s%s)", packageName, registration))
    }
    if (length(getOption("devtools.desc.suggests"))) 
        DESCRIPTION$Suggests <- getOption("devtools.desc.suggests")
    if (length(getOption("devtools.desc"))) {
        devtools.desc <- getOption("devtools.desc")
        for (i in seq_along(devtools.desc)) {
            name <- names(devtools.desc)[[i]]
            value <- devtools.desc[[i]]
            DESCRIPTION[[name]] <- value
        }
    }
    if ("testthat" %in% DESCRIPTION$Suggests) {
        dir.create(file.path(packageDirectory, "tests"))
        dir.create(file.path(packageDirectory, "tests", "testthat"))
        if ("devtools" %in% rownames(installed.packages())) {
            ns <- asNamespace("devtools")
            if (exists("render_template", envir = ns)) {
                tryCatch(writeLines(devtools:::render_template("testthat.R", 
                  list(name = packageName)), file.path(packageDirectory, 
                  "tests", "testthat.R")), error = function(e) NULL)
            }
        }
    }
    if (grepl("MIT\\s+\\+\\s+file\\s+LICEN[SC]E", DESCRIPTION$License, 
        perl = TRUE)) {
        holder <- if (!is.null(getOption("devtools.name"))) 
            Author
        else "<Copyright holder>"
        msg <- c(paste("YEAR:", format(Sys.time(), "%Y")), paste("COPYRIGHT HOLDER:", 
            holder))
        cat(msg, file = file.path(packageDirectory, "LICENSE"), 
            sep = "\n")
    }
    dir.create(file.path(packageDirectory, "R"), showWarnings = FALSE)
    dir.create(file.path(packageDirectory, "man"))
    if ((!length(getOption("devtools.desc"))) && (!length(sourceFiles))) {
        sysname <- Sys.info()[["sysname"]]
        buildShortcut <- if (sysname == "Darwin") 
            "Cmd + Shift + B"
        else "Ctrl + Shift + B"
        checkShortcut <- if (sysname == "Darwin") 
            "Cmd + Shift + E"
        else "Ctrl + Shift + E"
        testShortcut <- if (sysname == "Darwin") 
            "Cmd + Shift + T"
        else "Ctrl + Shift + T"
        helloWorld <- .rs.trimCommonIndent("\n         # Hello, world!\n         #\n         # This is an example function named 'hello' \n         # which prints 'Hello, world!'.\n         #\n         # You can learn more about package authoring with RStudio at:\n         #\n         #   http://r-pkgs.had.co.nz/\n         #\n         # Some useful keyboard shortcuts for package authoring:\n         #\n         #   Install Package:           '%s'\n         #   Check Package:             '%s'\n         #   Test Package:              '%s'\n         \n         hello <- function() {\n           print(\"Hello, world!\")\n         }\n      ", 
            buildShortcut, checkShortcut, testShortcut)
        cat(helloWorld, file = file.path(packageDirectory, "R", 
            "hello.R"), sep = "\n")
        helloWorldRd <- .rs.trimCommonIndent("\n         \\name{hello}\n         \\alias{hello}\n         \\title{Hello, World!}\n         \\usage{\n         hello()\n         }\n         \\description{\n         Prints 'Hello, world!'.\n         }\n         \\examples{\n         hello()\n         }\n      ")
        cat(helloWorldRd, file = file.path(packageDirectory, 
            "man", "hello.Rd"), sep = "\n")
        if (usingRcpp) {
            if (!file.exists(file.path(packageDirectory, "src"))) 
                dir.create(file.path(packageDirectory, "src"))
            helloWorldCpp <- .rs.trimCommonIndent("\n            #include <Rcpp.h>\n            using namespace Rcpp;\n            \n            // This is a simple function using Rcpp that creates an R list\n            // containing a character vector and a numeric vector.\n            //\n            // Learn more about how to use Rcpp at:\n            //\n            //   http://www.rcpp.org/\n            //   http://adv-r.had.co.nz/Rcpp.html\n            //\n            // and browse examples of code using Rcpp at:\n            // \n            //   http://gallery.rcpp.org/\n            //\n\n            // [[Rcpp::export]]\n            List rcpp_hello() {\n              CharacterVector x = CharacterVector::create(\"foo\", \"bar\");\n              NumericVector y   = NumericVector::create(0.0, 1.0);\n              List z            = List::create(x, y);\n              return z;\n            }\n\n         ")
            helloWorldDoc <- .rs.trimCommonIndent("\n            \\name{rcpp_hello}\n            \\alias{rcpp_hello}\n            \\title{Hello, Rcpp!}\n            \\usage{\n            rcpp_hello()\n            }\n            \\description{\n            Returns an \\R \\code{list} containing the character vector\n            \\code{c(\"foo\", \"bar\")} and the numeric vector \\code{c(0, 1)}.\n            }\n            \\examples{\n            rcpp_hello()\n            }\n         ")
            cat(helloWorldCpp, file = file.path(packageDirectory, 
                "src", "rcpp_hello.cpp"), sep = "\n")
            cat(helloWorldDoc, file = file.path(packageDirectory, 
                "man", "rcpp_hello.Rd"), sep = "\n")
        }
    }
    else if (length(sourceFiles)) {
        sourceFileExtensions <- tolower(gsub(".*\\.", "", sourceFiles, 
            perl = TRUE))
        sourceDirs <- .rs.swap(sourceFileExtensions, R = c("r", 
            "q", "s"), src = c("c", "cc", "cpp", "h", "hpp"), 
            vignettes = c("rmd", "rnw"), man = "rd", data = c("rda", 
                "rdata"), default = "")
        copyPaths <- gsub("/+", "/", file.path(packageDirectory, 
            sourceDirs, basename(sourceFiles)))
        dirPaths <- dirname(copyPaths)
        success <- unlist(lapply(dirPaths, function(path) {
            if (isTRUE(file.info(path)$isdir)) 
                return(TRUE)
            dir.create(path, recursive = TRUE, showWarnings = FALSE)
        }))
        if (!all(success)) 
            return(.rs.error("Failed to create package directory structure"))
        success <- file.copy(sourceFiles, copyPaths)
        if (!all(success)) 
            return(.rs.error("Failed to copy one or more source files"))
    }
    DESCRIPTION <- lapply(DESCRIPTION, function(field) {
        paste(field, collapse = "\n    ")
    })
    names <- names(DESCRIPTION)
    values <- unlist(DESCRIPTION)
    text <- paste(names, ": ", values, sep = "", collapse = "\n")
    cat(text, file = file.path(packageDirectory, "DESCRIPTION"), 
        sep = "\n")
    cat(NAMESPACE, file = file.path(packageDirectory, "NAMESPACE"), 
        sep = "\n")
    RprojPath <- file.path(packageDirectory, paste(packageName, 
        ".Rproj", sep = ""))
    if (!.Call("rs_writeProjectFile", RprojPath, PACKAGE = "(embedding)")) 
        return(.rs.error("Failed to create package .Rproj file"))
    Rproj <- readLines(RprojPath)
    appendNewLineIndex <- grep("AutoAppendNewline:", Rproj, fixed = TRUE)
    if (length(appendNewLineIndex)) 
        Rproj[appendNewLineIndex] <- "AutoAppendNewline: Yes"
    else Rproj <- c(Rproj, "AutoAppendNewline: Yes")
    stripTrailingWhitespace <- grep("StripTrailingWhitespace:", 
        Rproj, fixed = TRUE)
    if (length(stripTrailingWhitespace)) 
        Rproj[stripTrailingWhitespace] <- "StripTrailingWhitespace: Yes"
    else Rproj <- c(Rproj, "StripTrailingWhitespace: Yes")
    cat(Rproj, file = RprojPath, sep = "\n")
    scratchPaths <- .Call("rs_computeScratchPaths", RprojPath, 
        PACKAGE = "(embedding)")
    scratchPath <- scratchPaths$scratch_path
    if (!is.null(scratchPath) && file.exists(file.path(packageDirectory, 
        "R", "hello.R"))) {
        .Call("rs_addFirstRunDoc", scratchPath, "R/hello.R", 
            PACKAGE = "(embedding)")
    }
    if (usingRcpp && .rs.isPackageVersionInstalled("Rcpp", "0.10.1") && 
        require(Rcpp, quietly = TRUE)) {
        Rcpp::compileAttributes(packageDirectory)
        if (!is.null(scratchPath) && file.exists(file.path(packageDirectory, 
            "src/rcpp_hello.cpp"))) {
            .Call("rs_addFirstRunDoc", scratchPath, "src/rcpp_hello.cpp", 
                PACKAGE = "(embedding)")
        }
    }
    .rs.success()
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.show_custom_help_topic
function (helpHandler, topic, source) 
{
    helpHandlerFunc <- tryCatch(eval(parse(text = helpHandler)), 
        error = function(e) NULL)
    if (!is.function(helpHandlerFunc)) 
        return()
    if (identical(helpHandler, "reticulate:::help_handler")) {
        text <- paste(source, topic, sep = ".")
        .Call("rs_showPythonHelp", text, PACKAGE = "(embedding)")
        return()
    }
    url <- helpHandlerFunc("url", topic, source)
    if (!is.null(url) && nzchar(url)) 
        utils::browseURL(url)
}
<environment: 0x000001883f4b86b8>

$.rs.getTemplateYamlFile
function (path) 
{
    templateYaml <- file.path(path, "template.yaml")
    skeletonPath <- file.path(path, "skeleton")
    if (!file.exists(templateYaml)) {
        templateYaml <- file.path(path, "template.yml")
        if (!file.exists(templateYaml)) 
            return(NULL)
    }
    paths <- file.path(skeletonPath, c("skeleton.rmd", "skeleton.Rmd"))
    if (!any(file.exists(paths))) 
        return(NULL)
    multiFile <- length(list.files(skeletonPath)) > 1
    list(template_yaml = .rs.scalar(templateYaml), multi_file = .rs.scalar(multiFile))
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsRMarkdownParams
function (token, type, documentId) 
{
    if (exists("params", envir = .GlobalEnv)) 
        return(NULL)
    params <- .rs.getKnitParamsForDocument(documentId)
    if (!length(params)) 
        return(.rs.emptyCompletions())
    names <- vapply(params, FUN.VALUE = character(1), USE.NAMES = FALSE, 
        function(x) {
            x$name
        })
    completions <- .rs.selectFuzzyMatches(names, token)
    .rs.makeCompletions(token = token, results = completions)
}
<environment: 0x000001883f4b86b8>

$.rs.initDataCapture
function (outputFolder, options) 
{
    pagedOption <- if (!is.null(options[["paged.print"]])) 
        options[["paged.print"]]
    else getOption("paged.print")
    if (identical(pagedOption, FALSE)) {
        return()
    }
    overridePrint <- function(x, options, className, nRow, nCol) {
        original <- x
        options <- if (is.null(options)) 
            list()
        else options
        optionRowNames <- options[["rownames.print"]]
        options[["rownames.print"]] <- if (is.null(optionRowNames)) 
            (.row_names_info(x, type = 1) > 0)
        else optionRowNames
        options[["rows.total"]] <- nrow(x)
        options[["cols.total"]] <- ncol(x)
        output <- tempfile(pattern = "_rs_rdf_", tmpdir = outputFolder, 
            fileext = ".rdf")
        max.print <- if (is.null(options$max.print)) 
            getOption("max.print", 1000)
        else options$max.print
        cols.max.print <- if (is.null(options$cols.max.print)) 
            getOption("cols.max.print", 1000)
        else options$cols.max.print
        if (NCOL(x) > cols.max.print) {
            x <- x[, c(1:cols.max.print)]
        }
        x <- as.data.frame(head(x, max.print))
        save(x, options, file = output)
        metadata <- list(classes = className, nrow = nRow, ncol = nCol, 
            summary = list())
        if ("tibble" %in% loadedNamespaces()) {
            metadata$summary <- as.list(tibble::tbl_sum(original))
        }
        .Call("rs_recordData", output, metadata, PACKAGE = "(embedding)")
        invisible(original)
    }
    overrides <- .rs.dataCaptureOverrides()
    lapply(names(overrides), function(overrideName) {
        overrideMap <- overrides[[overrideName]]
        overrideFun <- function(x, ...) {
            o <- overrideMap(x, options)
            if (!is.null(o)) {
                overridePrint(o$x, o$options, o$className, o$nRow, 
                  o$nCol)
            }
        }
        .rs.addS3Override(overrideName, overrideFun)
    })
    assign("dplyr_tibble_print_original", getOption("dplyr.tibble.print"), 
        envir = as.environment("tools:rstudio"))
    options(dplyr.tibble.print = function(x, n, width, ...) {
        isSQL <- "tbl_sql" %in% class(x)
        n <- if (isSQL) 
            getOption("sql.max.print", 1000)
        else getOption("max.print", 1000)
        print(as.data.frame(head(x, n)))
    })
    .rs.addS3Override("print.knitr_kable", function(x, ...) {
        print(knitr::asis_output(x))
        invisible(x)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.api.getSourceEditorContext
function (id = NULL) 
{
    .Call("rs_getEditorContext", 2L, id, PACKAGE = "(embedding)")
}
<environment: 0x000001883fd281d8>

$.rs.api.registerChunkCallback
function (chunkCallback) 
{
    if (length(.rs.notebookChunkCallbacks) != 0) 
        stop("Callback is already registered.")
    if (!is.function(chunkCallback)) 
        stop("'chunkCallback' must be a function")
    if (length(formals(chunkCallback)) != 2) 
        stop("'chunkCallback' must contain two parameters: chunkName and chunkCode")
    data <- chunkCallback
    handle <- .Call("rs_createUUID", PACKAGE = "(embedding)")
    assign(handle, value = data, envir = .rs.notebookChunkCallbacks)
    return(handle)
}
<environment: 0x000001883fe2c398>

$.rs.getProjectTemplateRegistry
function () 
{
    .Call("rs_getProjectTemplateRegistry", PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.asBuildPath
function (path) 
{
    if (.Platform$OS.type == "windows") {
        path <- normalizePath(path)
        if (grepl(" ", path, fixed = TRUE)) 
            path <- utils::shortPathName(path)
        path <- gsub("\\\\", "/", path)
    }
    return(path)
}
<environment: 0x000001883f4b86b8>

$.rs.createNotebookFromCacheData
function (rnbData, inputFile, outputFile = NULL, envir = .GlobalEnv) 
{
    if (is.null(outputFile)) 
        outputFile <- .rs.withChangedExtension(inputFile, ext = ".nb.html")
    encoding <- getOption("encoding")
    properties <- .rs.getSourceDocumentProperties(inputFile, 
        FALSE)
    if (!is.null(properties$encoding)) 
        encoding <- properties$encoding
    knitr:::chunk_counter(reset = TRUE)
    if (!is.null(rnbData$external_chunks)) 
        knitr:::knit_code$restore(rnbData$external_chunks)
    outputOptions <- list(output_source = .rs.rnb.outputSource(rnbData))
    if (exists("eval_lang", envir = asNamespace("knitr"))) {
        override <- function(x, envir = knit_global()) {
            if (identical(x, as.name("T"))) 
                return(TRUE)
            else if (identical(x, as.name("F"))) 
                return(FALSE)
            else if (is.language(x)) 
                return(NULL)
            else return(x)
        }
        original <- .rs.replaceBinding("eval_lang", "knitr", 
            override)
        on.exit(.rs.replaceBinding("eval_lang", "knitr", original), 
            add = TRUE)
    }
    renderMessages <- list()
    tryCatch({
        withCallingHandlers({
            rmarkdown::render(input = inputFile, output_format = "html_notebook", 
                output_options = outputOptions, output_file = outputFile, 
                quiet = TRUE, envir = envir, encoding = encoding)
        }, message = function(...) {
            args <- list(...)
            renderMessages <<- c(renderMessages, args[[1]])
        })
    }, error = function(e) {
        messages <- list(e$message)
        lapply(renderMessages, function(m) {
            if (typeof(m) != "character") 
                return()
            result <- regexec("Quitting from lines ([0-9]+)-([0-9]+) ", 
                text = m)
            if (result[[1]][[1]] < 0) 
                return()
            groups <- regmatches(m, result)[[1]]
            messages <<- c(messages, paste("See line ", (strtoi(groups[[2]]) - 
                1), sep = ""))
        })
        stop(paste(messages, collpase = ". ", sep = ""))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.enqueueClientEvent
function (type, data) 
{
    data <- list(type = .rs.scalar(type), data = data)
    .rs.enqueClientEvent("reticulate_event", data)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.analyze_project
function (directory = .rs.getProjectDirectory()) 
{
    .rs.lintDirectory(directory)
}
<environment: 0x000001883f4b86b8>

$.rs.canonicalizePath
function (path, winslash = "/") 
{
    file.path(normalizePath(dirname(path), winslash = winslash, 
        mustWork = FALSE), basename(path), fsep = winslash)
}
<environment: 0x000001883f4b86b8>

$.rs.viewHook
function (original, x, title) 
{
    expr <- deparse(substitute(x), backtick = TRUE)
    if (missing(title)) 
        title <- paste(expr[1])
    expr <- paste(expr, collapse = " ")
    name <- ""
    env <- emptyenv()
    if (.rs.isViewOverride()) {
        name <- title
    }
    else if (is.name(substitute(x))) {
        name <- paste(deparse(substitute(x)))
        env <- .rs.findViewingEnv(name)
    }
    if (is.function(x)) {
        srcref <- .rs.getSrcref(x)
        if (!is.null(srcref)) {
            srcfile <- attr(srcref, "srcfile", exact = TRUE)
            filename <- .rs.nullCoalesce(srcfile$filename, "")
            if (!identical(filename, "~/.active-rstudio-document") && 
                file.exists(filename)) {
                .Call("rs_jumpToFunction", normalizePath(filename, 
                  winslash = "/"), srcref[[1]], srcref[[5]], 
                  TRUE, PACKAGE = "(embedding)")
                return(invisible(NULL))
            }
        }
        title <- sub("^[^:]+:::?", "", title)
        namespace <- .rs.environmentName(environment(x))
        if (identical(namespace, "R_EmptyEnv") || identical(namespace, 
            "")) 
            namespace <- "viewing"
        else if (identical(namespace, "R_GlobalEnv")) 
            namespace <- ".GlobalEnv"
        invisible(.Call("rs_viewFunction", x, title, namespace, 
            PACKAGE = "(embedding)"))
        return(invisible(NULL))
    }
    else if (inherits(x, "vignette")) {
        file.edit(file.path(x$Dir, "doc", x$File))
        return(invisible(NULL))
    }
    if (.rs.dataViewer.shouldUseObjectExplorer(x)) {
        view <- .rs.explorer.viewObject(x, title = title, envir = env)
        return(invisible(view))
    }
    if (inherits(x, "pandas.core.frame.DataFrame")) 
        x <- reticulate::py_to_r(x)
    coerced <- x
    eval(expr = substitute(as.data.frame(coerced, optional = TRUE)), 
        envir = globalenv())
    cacheKey <- .rs.addCachedData(force(x), name)
    invisible(.Call("rs_viewData", x, expr, title, name, env, 
        cacheKey, FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.suggest_topics
function (query) 
{
    pkgpaths <- path.package(quiet = TRUE)
    topics <- lapply(pkgpaths, function(pkgpath) tryCatch({
        if (exists(pkgpath, envir = .rs.topicsEnv)) 
            return(get(pkgpath, envir = .rs.topicsEnv))
        aliases <- file.path(pkgpath, "help/aliases.rds")
        index <- file.path(pkgpath, "help/AnIndex")
        value <- if (file.exists(aliases)) {
            names(readRDS(aliases))
        }
        else if (file.exists(index)) {
            data <- read.table(index, sep = "\t")
            data[, 1]
        }
        assign(pkgpath, value, envir = .rs.topicsEnv)
    }, error = function(e) NULL))
    flat <- unlist(topics, use.names = FALSE)
    scores <- .rs.scoreMatches(tolower(flat), tolower(query))
    ordered <- flat[order(scores, nchar(flat))]
    matches <- unique(ordered[.rs.isSubsequence(tolower(ordered), 
        tolower(query))])
    if (nzchar(query)) {
        first <- .rs.escapeForRegex(substring(query, 1L, 1L))
        pattern <- sprintf("^[.]*[%s]", first)
        matches <- grep(pattern, matches, value = TRUE, perl = TRUE)
    }
    matches
}
<environment: 0x000001883f4b86b8>

$.rs.python.findPythonInterpretersInKnownLocations
function () 
{
    pythonPaths <- character()
    roots <- if (.rs.platform.isWindows) {
        localAppData <- local({
            path <- Sys.getenv("LOCALAPPDATA", unset = NA)
            if (!is.na(path)) 
                return(path)
            profile <- Sys.getenv("USERPROFILE", unset = NA)
            if (!is.na(profile)) 
                return(file.path(profile, "AppData\\Local"))
            ""
        })
        drive <- Sys.getenv("SYSTEMDRIVE", unset = "C:")
        suffixes <- c("/", "/Program Files", "/Program Files (x86)")
        c(paste0(drive, suffixes), file.path(localAppData, "Programs/Python"))
    }
    else {
        c("/opt/python", "/opt/local/python", "/usr/local/opt/python")
    }
    roots <- c(roots, getOption("rstudio.python.installationPath"))
    suffixes <- if (.rs.platform.isWindows) {
        c("Scripts/python.exe", "python.exe")
    }
    else {
        c("bin/python3", "bin/python")
    }
    paths <- vapply(roots, function(root) {
        paths <- file.path(root, suffixes)
        paths[file.exists(paths)][1]
    }, FUN.VALUE = character(1))
    exists <- !is.na(paths)
    pythonPaths <- c(pythonPaths, paths[exists])
    roots <- roots[!exists]
    roots <- list.files(roots, full.names = TRUE)
    paths <- vapply(roots, function(root) {
        paths <- file.path(root, suffixes)
        paths[file.exists(paths)][1]
    }, FUN.VALUE = character(1))
    exists <- !is.na(paths)
    pythonPaths <- c(pythonPaths, paths[exists])
    lapply(pythonPaths, .rs.python.getPythonInfo, strict = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.createChildContext
function (context, name, access, tags) 
{
    recursive <- context$recursive
    if (is.numeric(recursive)) 
        recursive <- recursive - 1
    .rs.explorer.createContext(name = name, access = access, 
        tags = tags, recursive = recursive, start = 1, end = .rs.explorer.defaultRowLimit)
}
<environment: 0x000001883f4b86b8>

$.rs.isFunction
function (val) 
{
    is.function(val) || identical(.rs.getSingleClass(val), "C++Function")
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectPythonList
function (object, context = .rs.explorer.createContext()) 
{
    lapply(seq_along(object) - 1L, function(i) {
        if (.rs.reticulate.replIsActive()) {
            name <- sprintf("[%i]", i)
            access <- sprintf("#[%i]", i)
            tags <- c(.rs.explorer.tags$VIRTUAL)
        }
        else {
            name <- sprintf("[%i]", i)
            access <- sprintf("#[%iL]", i)
            tags <- c(.rs.explorer.tags$VIRTUAL)
        }
        childContext <- .rs.explorer.createChildContext(context, 
            name, access, tags)
        .rs.explorer.inspectObject(object[[i]], childContext)
    })
}
<environment: 0x000001883f4b86b8>

$.rs.python.findPythonCondaEnvironments
function () 
{
    conda <- .rs.python.findCondaBinary()
    if (!file.exists(conda)) 
        return(NULL)
    args <- c("env", "list", "--json", "--quiet")
    tmp <- tempfile()
    output <- system2(conda, args, stdout = TRUE, stderr = tmp)
    status <- .rs.nullCoalesce(attr(output, "status", exact = TRUE), 
        0L)
    if (!identical(status, 0L)) {
        errors <- paste(readLines(tmp), collapse = "\n")
        .rs.stopf("Error executing %s %s:\n%s", conda, paste(args, 
            collapse = " "), errors)
    }
    json <- .rs.fromJSON(paste(output, collapse = "\n"))
    envList <- unlist(json$envs)
    if (.rs.platform.isWindows) 
        envList <- chartr("\\", "/", envList)
    ignorePatterns <- c("/revdep/", "/basilisk/", "/renv/python/condaenvs/")
    pattern <- sprintf("(?:%s)", paste(ignorePatterns, collapse = "|"))
    envList <- grep(pattern, envList, value = TRUE, invert = TRUE)
    pythonSuffix <- if (.rs.platform.isWindows) 
        "python.exe"
    else "bin/python"
    pythonPaths <- file.path(envList, pythonSuffix)
    pythonPaths <- Filter(file.exists, pythonPaths)
    pythonPaths <- unique(normalizePath(pythonPaths, winslash = "/"))
    lapply(pythonPaths, .rs.python.getCondaEnvironmentInfo)
}
<environment: 0x000001883f4b86b8>

$.rs.initSecureDownload
function () 
{
    method <- getOption("download.file.method")
    if (!is.null(method)) {
        if (!.rs.isDownloadMethodSecure(method)) {
            .rs.insecureDownloadWarning(paste("The download.file.method option is \"", 
                method, "\" ", "however that method cannot provide secure (HTTPS) downloads ", 
                "on this platform. ", "This option was likely specified in .Rprofile or ", 
                "Rprofile.site so if you wish to change it you may need ", 
                "to edit one of those files.", sep = ""))
        }
    }
    else {
        secureMethod <- .rs.secureDownloadMethod()
        if (nzchar(secureMethod)) {
            options(download.file.method = secureMethod)
            if (secureMethod == "curl") 
                options(download.file.extra = .rs.downloadFileExtraWithCurlArgs())
        }
        else {
            .rs.insecureDownloadWarning(paste("Unable to set a secure (HTTPS) download.file.method (no", 
                "compatible method available in this installation of R)."))
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getR6ClassSymbols
function (callString) 
{
    parsed <- .rs.tryParseCall(callString)
    if (is.null(parsed)) 
        return(character())
    symbols <- c("self", "public", "private", "super")
    public <- .rs.extractElement(parsed, "public")
    if (!is.null(public)) 
        symbols <- c(symbols, names(public)[-1])
    symbols
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsVignettes
function (token) 
{
    doGetCompletionsVignettes <- function(token, vignettes) {
        vignettes <- sort(vignettes)
        .rs.makeCompletions(token = token, results = .rs.selectFuzzyMatches(vignettes, 
            token), quote = TRUE, type = .rs.acCompletionTypes$VIGNETTE, 
            excludeOtherCompletions = TRUE)
    }
    if (!is.null(vignettes <- .rs.get("vignettes"))) 
        return(doGetCompletionsVignettes(token, vignettes$results[, 
            "Item"]))
    vignettes <- vignette()
    .rs.assign("vignettes", vignettes)
    doGetCompletionsVignettes(token, vignettes$results[, "Item"])
}
<environment: 0x000001883f4b86b8>

$.rs.deparseFunction
function (func, useSource, asString) 
{
    if (useSource) {
        srcref <- attr(func, "srcref", exact = TRUE)
        if (!is.null(srcref)) {
            code <- as.character(srcref, useSource = TRUE)
            if (asString) 
                return(paste(code, collapse = "\n"))
            else return(code)
        }
    }
    control <- c("keepInteger", "keepNA")
    if (useSource) 
        control <- append(control, "useSource")
    code <- deparse(func, width.cutoff = 59, control = control)
    if (!useSource || is.null(attr(func, "srcref", exact = TRUE))) {
        replaceText <- "\t"
        if (isTRUE(.rs.readUiPref("use_spaces_for_tab"))) {
            replaceText <- paste(rep(" ", .rs.readUiPref("num_spaces_for_tab")), 
                collapse = "")
        }
        lines <- unlist(strsplit(code, "\n", fixed = TRUE))
        for (l in seq_along(lines)) {
            line <- lines[[l]]
            pos <- 1
            for (lvl in seq_len(20)) {
                indent <- if (lvl <= 4) 
                  "    "
                else "  "
                if (substring(line, pos, pos + (nchar(indent) - 
                  1)) == indent) {
                  line <- paste(substring(line, 0, pos - 1), 
                    replaceText, substring(line, pos + nchar(indent)), 
                    sep = "")
                  pos <- pos + nchar(replaceText)
                }
                else {
                  break
                }
            }
            lines[[l]] <- line
        }
        if (!asString) 
            return(lines)
        else code <- lines
    }
    if (asString) 
        paste(code, collapse = "\n")
    else code
}
<bytecode: 0x0000018840daca38>
<environment: 0x000001883f4b86b8>

$.rs.dataCaptureOverrides
function (outputFolder, libraryFolder) 
{
    defaultOverride <- function(x, options) list(x = x, options = options, 
        className = class(x), nRow = .rs.scalar(nrow(x)), nCol = .rs.scalar(ncol(x)))
    c(print.data.frame = defaultOverride, print.tbl_df = defaultOverride, 
        print.paged_df = defaultOverride, print.grouped_df = defaultOverride, 
        print.rowwise_df = defaultOverride, print.tbl_sql = defaultOverride, 
        print.data.table = function(x, options) {
            shouldPrintTable <- TRUE
            if ("data.table" %in% loadedNamespaces() && exists("shouldPrint", 
                envir = asNamespace("data.table"))) {
                shouldPrint <- get("shouldPrint", envir = asNamespace("data.table"))
                shouldPrintTable <- tryCatch(shouldPrint(x) || 
                  !inherits(x, "data.table"), error = function(e) TRUE)
            }
            if (!shouldPrintTable) {
                return(NULL)
            }
            list(x = x, options = options, className = class(x), 
                nRow = .rs.scalar(nrow(x)), nCol = .rs.scalar(ncol(x)))
        }, print.tbl_lazy = function(x, options) {
            tblLazyData <- lapply(dplyr::tbl_vars(x), function(e) character(0))
            names(tblLazyData) <- dplyr::tbl_vars(x)
            lazyFrame <- do.call("data.frame", tblLazyData)
            list(x = lazyFrame, options = options, className = class(x), 
                nRow = "?", nCol = "?")
        })
}
<environment: 0x000001883f4b86b8>

$.rs.enqueEditorClientEvent
function (type, data) 
{
    eventData <- list(type = .rs.scalar(type), data = data)
    .rs.enqueClientEvent("editor_command", eventData)
}
<environment: 0x000001883f4b86b8>

$.rs.usingUtf8Charset
function () 
{
    l10n_info()$`UTF-8` || identical(utils::localeToCharset(), 
        "UTF-8")
}
<environment: 0x000001883f4b86b8>

$.rs.sourceFileFromRef
function (srcref) 
{
    if (!is.null(srcref)) {
        fileattr <- attr(srcref, "srcfile")
        enc2utf8(fileattr$filename)
    }
    else ""
}
<environment: 0x000001883f4b86b8>

$.rs.restartR
function (afterRestartCommand = "") 
{
    afterRestartCommand <- paste(as.character(afterRestartCommand), 
        collapse = "\n")
    .Call("rs_restartR", afterRestartCommand, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleDriverIniPath
function (name, driverPath) 
{
    dir(driverPath, pattern = paste(tolower(name), ".*\\.ini", 
        sep = ""), recursive = TRUE, full.names = T)
}
<environment: 0x000001883f4b86b8>

$.rs.callWithRDS
function (functionName, inputLocation, outputLocation) 
{
    params = readRDS(inputLocation)
    result <- do.call(functionName, params)
    saveRDS(file = outputLocation, object = result)
}
<environment: 0x000001883f4b86b8>

$.rs.detectFreeVars_Leaf
function (e, w) 
{
    if (typeof(e) == "symbol" && nchar(as.character(e)) > 0 && 
        !exists(as.character(e), envir = w$assigned)) 
        return(as.character(e))
    else return(character(0))
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.removeCacheEntry
function (id) 
{
    cache <- .rs.explorer.getCache()
    entry <- cache[[id]]
    if (exists(id, envir = cache)) 
        rm(list = id, envir = cache)
    if (.rs.reticulate.isPythonInitialized()) {
        pyid <- paste("_rstudio_viewer", id, sep = "_")
        cache <- .rs.reticulate.explorerCache()
        item <- reticulate::py_get_item(cache, pyid, silent = TRUE)
        if (!is.null(item)) 
            reticulate::py_del_item(cache, pyid)
    }
    id
}
<environment: 0x000001883f4b86b8>

$.rs.randomString
function (prefix = "", postfix = "", candidates = c(letters, 
    LETTERS, 0:9), n = 16L) 
{
    sampled <- sample(candidates, n, TRUE)
    paste(prefix, paste(sampled, collapse = ""), postfix, sep = "")
}
<environment: 0x000001883f4b86b8>

$.rs.findDataFrame
function (envName, objName, cacheKey, cacheDir) 
{
    env <- NULL
    if (Encoding(cacheDir) == "unknown") 
        Encoding(cacheDir) <- "UTF-8"
    if (!is.null(objName) && nchar(objName) > 0) {
        if (is.null(envName) || identical(envName, "R_GlobalEnv") || 
            nchar(envName) == 0) {
            env <- globalenv()
        }
        else {
            env <- .rs.safeAsEnvironment(envName)
            if (is.null(env)) 
                env <- emptyenv()
        }
        if (exists(objName, where = env, inherits = FALSE)) {
            dataFrame <- .rs.toDataFrame(get(objName, envir = env, 
                inherits = FALSE), objName, TRUE)
            if (!is.null(dataFrame)) 
                return(dataFrame)
        }
    }
    if (exists(cacheKey, where = .rs.CachedDataEnv, inherits = FALSE)) 
        return(get(cacheKey, envir = .rs.CachedDataEnv, inherits = FALSE))
    cacheFile <- file.path(cacheDir, paste(cacheKey, "Rdata", 
        sep = "."))
    if (file.exists(cacheFile)) {
        status <- try(load(cacheFile, envir = .rs.CachedDataEnv), 
            silent = TRUE)
        if (inherits(status, "try-error")) 
            return(NULL)
        if (exists(cacheKey, where = .rs.CachedDataEnv, inherits = FALSE)) 
            return(get(cacheKey, envir = .rs.CachedDataEnv, inherits = FALSE))
    }
    return(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.tutorial_stop
function (url) 
{
    tutorial <- .rs.tutorial.registryFind(url)
    if (is.null(tutorial)) 
        return(FALSE)
    .rs.tutorial.stopTutorial(name = tutorial[["name"]], package = tutorial[["package"]])
    TRUE
}
<environment: 0x000001883f4b86b8>

$.rs.compile_theme
function (lines, isDark, name = "", chunkBgPropOverrideMap = list(), 
    operatorOverrideMap = list(), keywordOverrideMap = list(), 
    nodeSelectorOverrideMap = list(), commentBgOverrideMap = list(), 
    xterm16ColorMap = NULL) 
{
    stripped <- sub(" .*", "", lines)
    stripped <- grep("^\\.", stripped, value = TRUE)
    themeNameCssClass <- names(sort(c(table(stripped)), decreasing = TRUE))[[1]]
    regex <- paste("^\\s*", themeNameCssClass, "\\s*\\{\\s*$", 
        sep = "")
    content <- gsub(regex, paste(".ace_editor", ".ace_editor_theme .profvis-flamegraph", 
        ".ace_editor_theme {", sep = ", "), lines)
    regex <- paste("^\\", themeNameCssClass, "\\S*\\s+", sep = "")
    content <- gsub(regex, "", content)
    content <- .rs.setSelectionStartBorderRadius(content)
    parsed <- .rs.parseCss(lines = content)
    names(parsed)[grep("^\\.ace_editor(,.*|)$", names(parsed), 
        perl = TRUE)] <- "ace_editor"
    if (!any(grepl("^\\.ace_keyword", names(parsed)))) {
        warning("No field 'ace_keyword' in file '", paste0(name, 
            ".css"), "'; skipping", call. = FALSE)
        return(c())
    }
    key <- grep("^\\.ace_keyword\\s*$", names(parsed), value = TRUE)
    keywordColor <- NULL
    if (length(key) > 0) {
        keywordColor <- parsed[[key[[1]]]]$color
    }
    if (is.null(keywordColor)) {
        warning("No field 'color' for rule 'ace_keyword' in file '", 
            paste0(name, ".css"), "'", call. = FALSE)
        return(c())
    }
    content <- .rs.add_content(content, ".nocolor.ace_editor .ace_line span {", 
        "  color: %s !important;", "}", replace = keywordColor)
    layerName <- ".ace_marker-layer .ace_bracket"
    if (!(layerName %in% names(parsed))) {
        warning("Expected rule for '", layerName, "' in file '", 
            paste0(name, ".css"), "'; skipping", call. = FALSE)
        return(c())
    }
    borderField <- parsed[[layerName]]$border
    if (is.null(borderField)) {
        warning("No field 'border' for rule '", layerName, "' in file '", 
            paste0(name, ".css"), "'; skipping", call. = FALSE)
        return(c())
    }
    operatorBgColor <- if (isDark) 
        "rgba(128, 128, 128, 0.5)"
    else "rgba(192, 192, 192, 0.5)"
    content <- .rs.add_content(content, ".ace_bracket {", "  margin: 0 !important;", 
        "  border: 0 !important;", "  background-color: %s;", 
        "}", replace = operatorBgColor)
    background <- parsed$ace_editor$`background-color`
    if (is.null(background)) 
        background <- if (isDark) 
            "#000000"
        else "#FFFFFF"
    foreground <- parsed$ace_editor$color
    if (is.null(foreground)) 
        foreground <- if (isDark) 
            "#FFFFFF"
        else "#000000"
    mix <- .rs.get_chunk_bg_color(name, isDark, chunkBgPropOverrideMap)
    mergedColor <- .rs.mixColors(background, foreground, mix)
    content <- c(content, .rs.create_line_marker_rule(".ace_foreign_line", 
        mergedColor), .rs.createNodeSelectorRule(name, isDark, 
        nodeSelectorOverrideMap), .rs.createCommentBgRule(name, 
        isDark, commentBgOverrideMap))
    if (!any(grepl(".ace_active_debug_line", content, fixed = TRUE))) {
        debugPrimary <- "#FFDE38"
        debugBg <- .rs.mixColors(background, debugPrimary, 0.5)
        content <- c(content, .rs.create_line_marker_rule(".ace_active_debug_line", 
            debugBg))
    }
    mixingProportion <- if (isDark) 
        0.8
    else 0.9
    errorBgColor <- .rs.mixColors(background, foreground, mixingProportion)
    content <- c(content, .rs.create_line_marker_rule(".ace_find_line", 
        errorBgColor))
    content <- .rs.add_content(content, ".ace_console_error {", 
        "  background-color: %s;", "}", replace = errorBgColor)
    if (name %in% names(operatorOverrideMap)) 
        content <- .rs.add_operator_color(content, name, isDark, 
            operatorOverrideMap)
    if (name %in% names(keywordOverrideMap)) 
        content <- .rs.add_keyword_color(content, name, keywordOverrideMap)
    content <- c(content, .rs.create_terminal_rule(background, 
        foreground))
    content <- c(content, .rs.create_terminal_cursor_rules(isDark))
    content <- c(content, .rs.create_terminal_viewport_rule(background))
    content <- c(content, .rs.create_xterm_color_rules(background, 
        foreground, isDark, xterm16ColorMap = xterm16ColorMap))
    content <- c(content, .rs.themes_static_rules(isDark))
    content <- c(content, .rs.themes_rainbow_indent_guides())
    content
}
<environment: 0x000001883f4b86b8>

$.rs.getRmdOutputInfo
function (target) 
{
    lines <- readLines(target, warn = FALSE)
    properties <- .rs.getSourceDocumentProperties(target)
    if (identical(properties$encoding, "UTF-8")) 
        Encoding(lines) <- "UTF-8"
    outputFormat <- rmarkdown:::output_format_from_yaml_front_matter(lines)
    outputFormat <- rmarkdown:::create_output_format(outputFormat$name, 
        outputFormat$options)
    outputFile <- rmarkdown:::pandoc_output_file(target, outputFormat$pandoc)
    outputDir <- .Call("rs_getWebsiteOutputDir")
    if (is.null(outputDir)) 
        outputDir <- dirname(target)
    outputPath <- file.path(outputDir, outputFile)
    fileExists <- file.exists(outputPath)
    current <- fileExists && file.info(outputPath)$mtime >= file.info(target)$mtime
    list(output_file = .rs.scalar(.rs.createAliasedPath(outputPath)), 
        is_current = .rs.scalar(current), output_file_exists = .rs.scalar(fileExists))
}
<environment: 0x000001883f4b86b8>

$.rs.httpdPort
function () 
{
    if (.rs.httpdPortIsFunction()) 
        as.character(tools:::httpdPort())
    else as.character(tools:::httpdPort)
}
<environment: 0x000001883f4b86b8>

$.rs.registerFunctionEditor
function () 
{
    options(editor = .rs.editor)
}
<environment: 0x000001883f4b86b8>

$.rs.getFunctionSteps
function (fun, functionName, lineNumbers) 
{
    funBody <- body(fun)
    lineNumbers <- unique(lineNumbers)
    funStartLine <- 0
    funEndLine <- 0
    funSrcRef <- attr(fun, "srcref")
    if (!is.null(funSrcRef) && length(funSrcRef) > 3) {
        funStartLine <- funSrcRef[1]
        funEndLine <- funSrcRef[3]
    }
    else {
        return(list())
    }
    lapply(lineNumbers, function(lineNumber) {
        steps <- integer()
        if (lineNumber >= funStartLine && lineNumber <= funEndLine) {
            repeat {
                steps <- .rs.stepsAtLine(funBody, lineNumber)
                if (length(steps) > 0 || lineNumber >= funEndLine) {
                  break
                }
                lineNumber <- lineNumber + 1
            }
        }
        list(name = .rs.scalar(functionName), line = .rs.scalar(lineNumber), 
            at = .rs.scalar(paste(steps, collapse = ",")))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.api.tutorialLaunchBrowser
function (url) 
{
    .rs.tutorial.launchBrowser(url)
}
<environment: 0x000001883fe39f70>

$.rs.updateRStudioIDEPackage
function (name, archive) 
{
    pkgDir <- find.package(name)
    .rs.forceUnloadPackage(name)
    .Call("rs_installPackage", archive, dirname(pkgDir), PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.strip_color_from_field
function (css) 
{
    if (grepl("rgb", css)) {
        gsub(".*rgb", "rgb", css)
    }
    else {
        gsub(".*#", "#", css)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.mightBeShinyFunction
function (string) 
{
    result <- tryCatch(get(string, pos = 0), error = function(e) NULL)
    if (is.function(result) && !is.primitive(result)) {
        formalNames <- names(formals(result))
        if (any(c("inputId", "outputId") %in% formalNames)) 
            return(TRUE)
    }
    shinyFunctions <- .rs.getInferredCompletions("shiny")$functions
    if (string %in% names(shinyFunctions)) 
        return(TRUE)
    return(FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.getDataTableNamedArgumentCompletions
function (token, name, object, activeArg, functionCall) 
{
    completions <- .rs.getDataTableColumnsCompletions(token, 
        as.character(name), object)
    if (identical(activeArg, "j")) 
        completions <- .rs.appendCompletions(completions, .rs.getDataTableJCompletions(token))
    if (activeArg %in% c("by", "keyby")) 
        completions <- .rs.appendCompletions(completions, .rs.getDataTableByCompletions(token))
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.getUseMethodGeneric
function (x) 
{
    if (is.function(x)) 
        x <- body(x)
    if (!is.call(x)) 
        return(NULL)
    UseMethod <- as.name("UseMethod")
    generic <- NULL
    .rs.recursiveSearch(x, function(node) {
        if (!is.call(node) || length(node) < 2 || length(node) > 
            3) 
            return(FALSE)
        lhs <- node[[1]]
        if (!identical(lhs, UseMethod)) 
            return(FALSE)
        matched <- tryCatch(match.call(function(generic, object) {
        }, node), error = function(e) NULL)
        if (is.character(matched[["generic"]])) {
            generic <<- matched[["generic"]]
            return(TRUE)
        }
        FALSE
    })
    generic
}
<environment: 0x000001883f4b86b8>

$.rs.tutorial.registryFind
function (url) 
{
    keys <- ls(envir = .rs.tutorial.registry)
    for (key in keys) {
        tutorial <- .rs.tutorial.registry[[key]]
        match <- identical(url, tutorial[["shiny_url"]]) || identical(url, 
            tutorial[["browser_url"]])
        if (match) 
            return(tutorial)
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.showHelpTopicArgument
function (functionName) 
{
    topic <- functionName
    pkgName <- NULL
    if (grepl(":{2,3}", functionName, perl = TRUE)) {
        splat <- strsplit(functionName, ":{2,3}", perl = TRUE)[[1]]
        topic <- splat[[2]]
        pkgName <- splat[[1]]
    }
    call <- .rs.makeHelpCall(topic, pkgName)
    print(eval(call, envir = parent.frame()))
}
<environment: 0x000001883f4b86b8>

$.rs.format_css_color
function (color) 
{
    sprintf("rgb(%s, %s, %s)", color[1], color[2], color[3])
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.describeObjectContentsImpl
function (object) 
{
    if (inherits(object, "pandas.core.frame.DataFrame")) {
        text <- reticulate::py_to_r(object$to_string(max_rows = 150L, 
            show_dimensions = FALSE))
        strsplit(text, "\n", fixed = TRUE)[[1]]
    }
    else {
        list()
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalActivate
function (id = NULL, show = TRUE) 
{
    if (!is.null(id) && (!is.character(id) || (length(id) != 
        1))) 
        stop("'id' must be NULL or a character vector of length one")
    if (!is.logical(show)) 
        stop("'show' must be TRUE or FALSE")
    .Call("rs_terminalActivate", id, show)
    invisible(NULL)
}
<environment: 0x000001883fdb8870>

$.rs.registerHistoryFunctions
function () 
{
    .rs.registerReplaceHook("loadhistory", "utils", function(original, 
        file = ".Rhistory") {
        invisible(.Call("rs_loadHistory", file))
    })
    .rs.registerReplaceHook("savehistory", "utils", function(original, 
        file = ".Rhistory") {
        invisible(.Call("rs_saveHistory", file))
    })
    .rs.registerReplaceHook("timestamp", "utils", function(original, 
        stamp = date(), prefix = "##------ ", suffix = " ------##", 
        quiet = FALSE) {
        stamp <- paste(prefix, stamp, suffix, sep = "")
        lapply(stamp, function(s) {
            invisible(.Call("rs_timestamp", s))
        })
        if (!quiet) 
            cat(stamp, sep = "\n")
        invisible(stamp)
    }, namespace = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.isSubsequence
function (strings, string) 
{
    .Call("rs_isSubsequence", strings, string)
}
<environment: 0x000001883f4b86b8>

$.rs.listInferredPackages
function (documentId) 
{
    .Call("rs_listInferredPackages", documentId)
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletionsImportsFrom
function (module, token) 
{
    pasted <- paste(module, token, sep = ".")
    completions <- .rs.python.getCompletionsImports(pasted)
    if (length(completions)) {
        prefix <- paste(module, ".", sep = "")
        completions <- sub(prefix, "", completions, fixed = TRUE)
    }
    attr(completions, "token") <- token
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalContext
function (id) 
{
    if (is.null(id) || !is.character(id) || (length(id) != 1)) 
        stop("'id' must be a single element character vector")
    .Call("rs_terminalContext", id)
}
<environment: 0x000001883fdaa100>

$.rs.rpc.get_issue_url
function (id) 
{
    project <- .rs.getProjectDirectory()
    if (is.null(project)) {
        return(.rs.scalar(""))
    }
    DESCRIPTION <- file.path(project, "DESCRIPTION")
    if (!file.exists(DESCRIPTION)) {
        return(.rs.scalar(""))
    }
    BugReports <- tryCatch(read.dcf(DESCRIPTION, fields = "BugReports"), 
        error = function(e) NA, warning = function(w) NA)
    if (is.na(BugReports)) {
        return(.rs.scalar(""))
    }
    if (!is.character(BugReports) || length(BugReports) != 1L) {
        return(.rs.scalar(""))
    }
    if (grepl("^(https?://|www.)", BugReports)) {
        .rs.scalar(paste0(BugReports, "/", sub("#", "", id)))
    }
    else {
        .rs.scalar("")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.getCachedAvailablePackages
function (contribUrl) 
{
    .Call("rs_getCachedAvailablePackages", contribUrl, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.valueAsString
function (val) 
{
    tryCatch(.rs.valueAsStringImpl(val), error = function(e) "NO_VALUE")
}
<environment: 0x000001883f4b86b8>

$.rs.detachConflicts
function () 
{
    pos <- which(search() == ".conflicts")
    if (length(pos) == 0) 
        return(NULL)
    envirs <- lapply(pos, as.environment)
    for (envir in envirs) {
        symbols <- ls(envir = envir, all.names = TRUE)
        rm(list = symbols, envir = envir)
    }
    envirs
}
<environment: 0x000001883f4b86b8>

$.rs.api.writeRStudioPreference
function (name, value) 
{
    .rs.writeUiPref(name, value)
}
<environment: 0x000001883fd5f630>

$.rs.listBuilder
function () 
{
    (function() {
        capacity_ <- 1024
        index_ <- 0
        data_ <- vector("list", capacity_)
        append <- function(data) {
            index_ <<- index_ + 1
            if (index_ > capacity_) {
                capacity_ <<- capacity_ * 2
                data_[capacity_] <<- list(NULL)
            }
            if (is.null(data)) 
                data_[index_] <<- list(NULL)
            else data_[[index_]] <<- data
        }
        data <- function() {
            data_[seq_len(index_)]
        }
        clear <- function() {
            capacity_ <<- 1024
            index_ <<- 0
            data_ <<- vector("list", capacity_)
        }
        empty <- function() {
            index_ == 0
        }
        list(append = append, clear = clear, empty = empty, data = data)
    })()
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.init_default_user_library
function () 
{
    .rs.initDefaultUserLibrary()
}
<environment: 0x000001883f4b86b8>

$.rs.formatDataColumnDefault
function (col, ...) 
{
    as.character(col)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_cran_actives
function () 
{
    data.frame(name = names(getOption("repos")), host = "", url = as.character(getOption("repos")), 
        country = "", ok = TRUE, stringsAsFactors = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.rsconnectDeployList
function (target, asMultipleDoc, quartoSrcFile) 
{
    max_size <- getOption("rsconnect.max.bundle.size", 1048576000)
    dirlist <- .rs.makeDeploymentList(target, asMultipleDoc, 
        quartoSrcFile, max_size)
    list(dir_list = if (dirlist$totalSize >= max_size) NULL else .rs.summarizeDir(dirlist$contents, 
        5), max_size = .rs.scalar(max_size), dir_size = .rs.scalar(dirlist$totalSize))
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.replHook
function (buffer, contents, trimmed) 
{
    on.exit(.rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$REPL_ITERATION, 
        list()), add = TRUE)
    if (buffer$empty()) {
        if (grepl("^[?]", trimmed)) {
            text <- substring(trimmed, 2)
            .Call("rs_showPythonHelp", text, PACKAGE = "(embedding)")
            return(TRUE)
        }
        reHelp <- "help\\s*\\((.*)\\)"
        if (grepl(reHelp, trimmed)) {
            text <- .rs.trimWhitespace(gsub(reHelp, "\\1", trimmed))
            .Call("rs_showPythonHelp", text, PACKAGE = "(embedding)")
            return(TRUE)
        }
        pattern <- "^View\\s*\\((.*)\\)$"
        matches <- regmatches(trimmed, regexec(pattern, trimmed))
        if (length(matches) && length(matches[[1]]) == 2) {
            name <- gsub("^\\s*|\\s*$", "", matches[[1]][[2]])
            object <- reticulate::py_eval(name, convert = FALSE)
            .rs.reticulate.viewHook(object, name)
            return(TRUE)
        }
    }
    FALSE
}
<environment: 0x000001883f4b86b8>

$.rs.connectionReadPackages
function () 
{
    rawConnections <- .rs.fromJSON(.Call("rs_availableConnections"))
    pacakgeConnections <- lapply(rawConnections, function(con) {
        tryCatch({
            ns <- asNamespace(con$package)
            connectionType <- if (nchar(con$shinyapp) == 0) 
                "Snippet"
            else "Shiny"
            snippetFile <- file.path("rstudio", "connections", 
                paste(con$name, ".R", sep = ""))
            snippet <- ""
            if (nchar(con$shinyapp) == 0) {
                snippetPath <- system.file(snippetFile, package = con$package)
                if (!file.exists(snippetPath)) {
                  warning("The file \"", con$name, ".R\" does not exist under \"rstudio/connections\" for ", 
                    "package \"", con$package, "\".")
                }
                else {
                  snippet <- paste(readLines(snippetPath), collapse = "\n")
                }
            }
            else {
                if (!exists(con$shinyapp, envir = ns, mode = "function")) {
                  warning("The function \"", con$shinyapp, "\" does not exist. ", 
                    "Check the ShinyApp DCF field in the ", con$package, 
                    " package.")
                }
            }
            iconData <- if (nchar(con$icon) > 0) {
                iconPath <- system.file(con$icon, package = con$package)
                if (file.exists(iconPath)) {
                  paste0("data:image/png;base64,", .rs.base64encodeFile(iconPath))
                }
            }
            else {
                .Call("rs_connectionIcon", con$name)
            }
            list(package = .rs.scalar(con$package), version = .rs.scalar(NULL), 
                name = .rs.scalar(con$name), type = .rs.scalar(connectionType), 
                newConnection = .rs.scalar(paste(con$package, 
                  "::", con$shinyapp, "()", sep = "")), snippet = .rs.scalar(snippet), 
                help = .rs.scalar(con$help), iconData = .rs.scalar(iconData), 
                licensed = .rs.scalar(FALSE), source = .rs.scalar("Package"), 
                hasInstaller = .rs.scalar(FALSE))
        }, error = function(e) {
            warning(e$message)
            NULL
        })
    })
    names(pacakgeConnections) <- NULL
    pacakgeConnections
}
<environment: 0x000001883f4b86b8>

$.rs.api.getThemeInfo
function () 
{
    global <- .rs.readUiPref("global_theme")
    theme <- .rs.readUserState("theme")
    if (is.null(theme)) 
        theme <- list(name = "Textmate (default)", isDark = FALSE)
    global <- switch(if (is.null(global)) "" else global, alternate = "Sky", 
        default = "Modern", "Classic")
    foreground <- "#000000"
    background <- "#FFFFFF"
    colors <- .Call("rs_getThemeColors", PACKAGE = "(embedding)")
    if (!is.null(colors)) {
        foreground <- colors$foreground
        background <- colors$background
    }
    list(editor = theme$name, global = global, dark = theme$isDark, 
        foreground = foreground, background = background)
}
<bytecode: 0x000001883c7cb920>
<environment: 0x000001883fde1798>

$.rs.getHelpDataFrame
function (name, src, envir = parent.frame()) 
{
    out <- .rs.getHelp(name, src)
    data <- NULL
    title <- name
    pos <- match(src, search(), nomatch = -1L)
    if (pos >= 0) {
        data <- tryCatch(get(name, pos = pos), error = function(e) NULL)
    }
    if (is.null(data)) {
        title <- paste0(src, "$", name)
        data <- .rs.getAnywhere(title, envir)
    }
    if (is.null(data)) 
        return(out)
    if (is.null(out)) {
        ncol <- ncol(data)
        out <- list(html = paste0("<h2>", name, "</h2><h3>Description</h3><p>", 
            nrow(data), " obs. of ", ncol, " variable", if (ncol > 
                1) "s", "</p>"), signature = "-", pkgname = src, 
            help = FALSE)
    }
    .rs.assignCachedData("completion_popup_dataframe", data, 
        "")
    out$view <- paste0("grid_resource/gridviewer.html?env=_rs_no_env&cache_key=completion_popup_dataframe&max_cols=50")
    out
}
<environment: 0x000001883f4b86b8>

$.rs.packageHelpEncodingEnv
<environment: 0x000001883f4c0b58>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.evaluateChunkOptions
function (code) 
{
    opts <- list()
    Encoding(code) <- "UTF-8"
    code <- unlist(strsplit(code, "\n", fixed = TRUE))
    rmdChunkOpts <- code[[1]]
    yamlChunkOpts <- c()
    for (line in code[-1]) {
        match <- unlist(regmatches(line, regexec(.rs.reYamlOptChunkBegin(), 
            line)))
        if (length(match) == 0) 
            break
        yamlChunkOpts <- c(yamlChunkOpts, match)
    }
    if (length(yamlChunkOpts) > 0) {
        opts <- tryCatch(.rs.parseYamlOpt(yamlChunkOpts), error = function(e) {
            warning("Failed to parse chunk options in body:\n", 
                e)
        })
    }
    matches <- unlist(regmatches(rmdChunkOpts, regexec(.rs.reRmdChunkBegin(), 
        rmdChunkOpts)))
    if (length(matches) > 1) 
        rmdChunkOpts <- matches[[2]]
    tryCatch({
        setupIndicator <- "r setup"
        if (identical(substring(rmdChunkOpts, 1, nchar(setupIndicator)), 
            setupIndicator)) {
            opts$include <- FALSE
        }
        opts$engine <- unlist(strsplit(rmdChunkOpts, split = "(\\s|,)+"))[[1]]
        rmdChunkOpts <- substring(rmdChunkOpts, nchar(opts$engine) + 
            1)
        opts <- .rs.mergeLists(opts, eval(substitute(knitr:::parse_params(rmdChunkOpts)), 
            envir = .GlobalEnv))
        opts <- opts[unique(names(opts))]
        opts <- lapply(opts, function(opt) {
            if (identical(opt, as.name("T"))) 
                TRUE
            else if (identical(opt, as.name("F"))) 
                FALSE
            else opt
        })
        names <- vapply(opts, is.name, TRUE)
        opts[names] <- as.character(opts[names])
        fields <- list(warning = TRUE, message = TRUE, error = FALSE)
        .rs.enumerate(fields, function(key, default) {
            if (is.null(opts[[key]])) 
                next
            opts[[key]] <<- tryCatch(as.logical(opts[[key]]), 
                error = function(e) default)
        })
    }, error = function(e) {
    })
    .rs.scalarListFromList(opts, expressions = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.userPrompt
function (type, caption, message, yesLabel = NULL, noLabel = NULL, 
    includeCancel = FALSE, yesIsDefault = TRUE) 
{
    if (identical(type, "info")) 
        type <- 1
    else if (identical(type, "warning")) 
        type <- 2
    else if (identical(type, "error")) 
        type <- 3
    else if (identical(type, "question")) 
        type <- 4
    else stop("Invalid type specified")
    result <- .Call("rs_userPrompt", type, caption, message, 
        yesLabel, noLabel, includeCancel, yesIsDefault, PACKAGE = "(embedding)")
    if (result == 0) 
        "yes"
    else if (result == 1) 
        "no"
    else if (result == 2) 
        "cancel"
    else stop("Invalid result")
}
<environment: 0x000001883f4b86b8>

$.rs.reticulateEvents
$.rs.reticulateEvents$PYTHON_INITIALIZED
[1] "python_initialized"

$.rs.reticulateEvents$REPL_INITIALIZED
[1] "repl_initialized"

$.rs.reticulateEvents$REPL_ITERATION
[1] "repl_iteration"

$.rs.reticulateEvents$REPL_BUSY
[1] "repl_busy"

$.rs.reticulateEvents$REPL_TEARDOWN
[1] "repl_teardown"

attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.odbcBundleRegistryRemove
function (entries) 
{
    validateEntry <- function(entry) {
        tryCatch({
            regEntry <- readRegistry(entry$path, "HLM", view = .rs.odbcOsBitness())
            if (!is.null(entry$key)) 
                is.null(regEntry[[entry$key]])
            else FALSE
        }, error = function(e) {
            TRUE
        })
    }
    if (all(sapply(entries, function(e) validateEntry(e)))) 
        return()
    bitness <- .rs.odbcOsBitness()
    for (entry in entries) {
        fullPath <- file.path("HKEY_LOCAL_MACHINE", entry$path, 
            fsep = "\\")
        if (!is.null(entry$key)) {
            regArgs <- list("DELETE", shQuote(fullPath), "/v", 
                shQuote(entry$key), "/f", paste("/reg:", bitness, 
                  sep = ""))
        }
        else {
            regArgs <- list("DELETE", shQuote(fullPath), "/f", 
                paste("/reg:", bitness, sep = ""))
        }
        system2("REG", args = regArgs)
    }
    if (all(sapply(entries, function(e) validateEntry(e)))) 
        return()
    addReg <- tempfile(fileext = ".reg")
    lineEntries <- sapply(entries, function(entry) {
        fullPath <- file.path("HKEY_LOCAL_MACHINE", entry$path, 
            fsep = "\\")
        if (is.null(entry$key)) {
            paste("[-", fullPath, "]", sep = "")
        }
        else {
            c(paste("[", fullPath, "]", sep = ""), paste("\"", 
                entry$key, "\"=-", sep = ""), "")
        }
    })
    lines <- c("REGEDIT4", "", unlist(lineEntries))
    writeLines(lines, addReg)
    system2("explorer", addReg)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.isFunction
function (object) 
{
    inherits(object, c("python.builtin.builtin_function_or_method", 
        "python.builtin.function", "python.builtin.instancemethod"))
}
<environment: 0x000001883f4b86b8>

$.rs.getPlumberViewerType
function () 
{
    viewer <- getOption("plumber.docs.callback", getOption("plumber.swagger.url"))
    if (identical(viewer, FALSE)) 
        return("none")
    else if (identical(viewer, TRUE)) 
        return("browser")
    else if (is.function(viewer) && is.character(attr(viewer, 
        "plumberViewerType"))) 
        return(attr(viewer, "plumberViewerType"))
    return("user")
}
<environment: 0x000001883f4b86b8>

$.rs.getPackageVersion
function (packageName) 
{
    package_version(utils:::packageDescription(packageName, fields = "Version"))
}
<environment: 0x000001883f4b86b8>

$.rs.unquoteImpl
function (strings) 
{
    if (!is.character(strings)) 
        return(strings)
    parsed <- parse(text = strings)
    vapply(parsed, as.character, FUN.VALUE = character(1))
}
<environment: 0x000001883f4b86b8>

$.rs.libPathsString
function () 
{
    paste(.libPaths(), collapse = .Platform$path.sep)
}
<environment: 0x000001883f4b86b8>

$.rs.reticulate.describeObjectValue
function (object) 
{
    if (inherits(object, "pandas.core.frame.DataFrame")) {
        builtins <- reticulate::import_builtins(convert = TRUE)
        rows <- builtins$len(object)
        columns <- builtins$len(object$columns)
        fmt <- "DataFrame: [%i rows x %i columns]"
        sprintf(fmt, rows, columns)
    }
    else if (inherits(object, "__main__.R")) {
        "[R interface object]"
    }
    else {
        pprint <- reticulate::import("pprint", convert = TRUE)
        printer <- pprint$PrettyPrinter(indent = 1L, width = as.integer(getOption("width")), 
            depth = 1L)
        formatted <- printer$pformat(object)
        .rs.truncate(formatted)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.explorer_begin_inspect
function (id, name) 
{
    object <- .rs.explorer.getCachedObject(id = id, extractingCode = NULL, 
        refresh = TRUE)
    context <- .rs.explorer.createContext(name = name, access = NULL, 
        tags = character(), recursive = 1, start = 1, end = .rs.explorer.defaultRowLimit)
    result <- .rs.explorer.inspectObject(object, context)
    result
}
<environment: 0x000001883f4b86b8>

$.rs.getAllOutputFormats
function (input_dir, encoding) 
{
    index <- .rs.inputDirToIndexFile(input_dir)
    if (!is.null(index)) 
        rmarkdown:::enumerate_output_formats(input = index, envir = parent.frame(), 
            encoding = encoding)
    else character()
}
<environment: 0x000001883f4b86b8>

$.rs.logWarningMessage
function (message) 
{
    .Call("rs_logWarningMessage", message, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.resolveFormalsImplS3Dispatch
function (token, object, functionName, functionCall, matchedCall, 
    envir) 
{
    ok <- length(functionCall) > 1 && .rs.isS3Generic(object)
    if (!ok) 
        return(NULL)
    dispatchArgumentName <- names(formals(object)[1])
    dispatchArgumentSymbol <- matchedCall[[dispatchArgumentName]]
    if (is.null(dispatchArgumentSymbol)) 
        return(NULL)
    objectForDispatch <- .rs.getAnywhere(matchedCall[[dispatchArgumentName]], 
        envir = envir)
    if (is.null(objectForDispatch)) 
        return(NULL)
    functionName <- sub("^.*:{2,3}", "", functionName)
    classes <- class(objectForDispatch)
    for (class in c(classes, "default")) {
        call <- substitute(utils::getS3method(functionName, class), 
            list(functionName = functionName, class = class))
        method <- tryCatch(eval(call, envir = envir), error = function(e) NULL)
        if (is.null(method)) 
            next
        formals <- .rs.getFunctionArgumentNames(method)
        methods <- rep.int(paste(functionName, class, sep = "."), 
            length(formals))
        data <- list(formals = formals, methods = methods)
        return(data)
    }
    NULL
}
<bytecode: 0x000001883bee0e60>
<environment: 0x000001883f4b86b8>

$.rs.listPackagesPackrat
function (dir) 
{
    libraryList <- .rs.listInstalledPackages()
    packratStatus <- .rs.quietPackratStatus(dir)
    if (!is.data.frame(packratStatus)) 
        return(libraryList)
    sep <- if (tolower(.Platform$OS.type) == "windows") 
        "\\"
    else "/"
    projectPath <- paste(normalizePath(dir), "packrat", "lib", 
        "", sep = sep)
    libraryPaths <- normalizePath(as.character(libraryList[, 
        "library"]))
    libraryList["in.project.library"] <- substr(libraryPaths, 
        1, nchar(projectPath)) == projectPath
    resolvedLinks <- normalizePath(by(libraryList, 1:nrow(libraryList), 
        function(pkg) {
            system.file(package = pkg$name, lib.loc = pkg$library)
        }))
    if (tolower(.Platform$OS.type) == "windows") {
        .Library <- packrat:::.packrat_mutables$get(".Library")
        if (!is.null(.Library)) {
            idx <- grep("\\lib-R\\", resolvedLinks, fixed = TRUE)
            resolvedLinks[idx] <- normalizePath(file.path(.Library, 
                basename(resolvedLinks[idx])))
        }
    }
    libraryList[, "source.library"] <- .rs.createAliasedPath(libraryList[, 
        "library"])
    libraryList[, "library"] <- .rs.createAliasedPath(dirname(resolvedLinks))
    packratList <- subset(libraryList, in.project.library)
    nonPackratList <- subset(libraryList, !in.project.library)
    mergedList <- merge(packratList, packratStatus, by.x = "name", 
        by.y = "package", all.x = TRUE, all.y = TRUE)
    mergedList[, "in.project.library"] <- rep(TRUE, nrow(mergedList))
    mergedList <- subset(mergedList, !(mergedList[, "name"] == 
        "rstudio"))
    mergedList <- subset(mergedList, !(mergedList[, "name"] == 
        "manipulate"))
    if (nrow(nonPackratList) > 0) {
        packratCols <- setdiff(colnames(mergedList), colnames(nonPackratList))
        nonPackratList[, packratCols] <- NA
        rbind(mergedList, nonPackratList)
    }
    else {
        mergedList
    }
}
<environment: 0x000001883f4b86b8>

$.rs.python.getNumpyFunctionArguments
function (object) 
{
    docs <- reticulate::py_get_attr(object, "__doc__")
    if (inherits(docs, "python.builtin.object")) 
        docs <- reticulate::py_to_r(docs)
    pieces <- strsplit(docs, "\n", fixed = TRUE)[[1]]
    first <- pieces[[1]]
    munged <- paste(gsub("[^(]*[(]", "function (", first), "{}")
    parsed <- parse(text = munged)[[1]]
    names(parsed[[2]])
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.ignore_next_loaded_package_check
function () 
{
    .rs.setVar("ignoreNextLoadedPackageCheck", TRUE)
    return(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.python.extractCurrentExpression
function (line, offset) 
{
    tokens <- .rs.python.tokenize(line, exclude = c("whitespace", 
        "comment"))
    if (length(tokens) == 0) 
        return("")
    n <- length(tokens)
    index <- n
    while (index >= 1) {
        if (tokens[[index]]$offset <= offset) 
            break
        index <- index - 1
    }
    cursor <- .rs.python.tokenCursor(tokens)
    cursor$moveToOffset(index)
    while (TRUE) {
        while (cursor$bwdToMatchingBracket()) if (!cursor$moveToPreviousToken()) 
            break
        if (cursor$tokenType() %in% c("operator", "keyword") || 
            cursor$tokenValue() %in% c(";", ",")) {
            cursor$moveToNextToken()
            break
        }
        if (cursor$tokenType() %in% "bracket" && cursor$cursorOffset() > 
            1) {
            peek <- tokens[[cursor$cursorOffset() - 1]]
            if (peek$type %in% c("operator", "bracket", "keyword") || 
                peek$value %in% c(";", ",")) {
                cursor$moveToNextToken()
                break
            }
        }
        if (!cursor$moveToPreviousToken()) 
            break
    }
    startOffset <- cursor$tokenOffset()
    while (TRUE) {
        if (cursor$tokenValue() %in% c("(")) {
            cursor$moveToPreviousToken()
            break
        }
        if (cursor$fwdToMatchingBracket()) 
            if (!cursor$moveToNextToken()) 
                break
        if (cursor$tokenType() %in% c("operator", "keyword") || 
            cursor$tokenValue() %in% c(";", ",")) {
            cursor$moveToPreviousToken()
            break
        }
        if (!cursor$moveToNextToken()) 
            break
    }
    endOffset <- cursor$tokenOffset() + nchar(cursor$tokenValue()) - 
        1
    substring(line, startOffset, endOffset)
}
<environment: 0x000001883f4b86b8>

$.rs.setFunctionBreakpoints
function (functionName, envir, steps) 
{
    functionName <- .rs.unquote(functionName)
    if (length(steps) == 0 || nchar(steps) == 0) {
        fun <- get(functionName, envir = envir)
        if (.rs.isTraced(fun)) {
            suppressMessages(untrace(what = functionName, where = envir))
        }
    }
    else {
        suppressMessages(trace(what = functionName, where = envir, 
            at = lapply(strsplit(as.character(steps), ","), as.numeric), 
            tracer = browser, print = FALSE))
        lockedBinding <- FALSE
        tryCatch({
            if (bindingIsLocked(functionName, envir)) {
                unlockBinding(functionName, envir)
                lockedBinding <- TRUE
            }
            body(envir[[functionName]]@.Data) <- .rs.tracedSourceRefs(body(envir[[functionName]]@.Data), 
                body(envir[[functionName]]@original))
        }, finally = {
            if (lockedBinding) {
                lockBinding(functionName, envir)
            }
        })
    }
    return(functionName)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_help
function (what, from, type) 
{
    if (!length(type)) 
        return()
    envir <- .rs.getActiveFrame()
    impl <- function() {
        if (grepl("::.", what)) {
            splat <- strsplit(what, "::", fixed = TRUE)[[1]]
            from <- splat[[1]]
            what <- splat[[2]]
        }
        if (what == "install.packages" && type == .rs.acCompletionTypes$ARGUMENT && 
            is.null(from)) 
            return(.rs.getHelp("install.packages", "utils"))
        if (type == .rs.acCompletionTypes$OPTION) 
            return(.rs.getHelp("options", "base", subset = FALSE))
        if (type %in% c(.rs.acCompletionTypes$S4_GENERIC, .rs.acCompletionTypes$S4_METHOD)) {
            if (!is.null(help <- .rs.getHelp(paste(what, "methods", 
                sep = "-"), from))) 
                return(help)
            if (!is.null(help <- .rs.getHelp(what, from))) 
                return(help)
            return()
        }
        if (type %in% c(.rs.acCompletionTypes$FUNCTION, .rs.acCompletionTypes$S4_GENERIC, 
            .rs.acCompletionTypes$S4_METHOD, .rs.acCompletionTypes$R5_METHOD)) 
            return(.rs.getHelpFunction(what, from))
        else if (type %in% c(.rs.acCompletionTypes$ARGUMENT, 
            .rs.acCompletionTypes$SECUNDARY_ARGUMENT)) 
            return(.rs.getHelpArgument(what, from, parent.frame()))
        else if (type == .rs.acCompletionTypes$PACKAGE) 
            return(.rs.getHelpPackage(what))
        else if (type == .rs.acCompletionTypes$DATATABLE_SPECIAL_SYMBOL) 
            return(.rs.getHelpDataTableSpecialSymbol(what))
        else if (type == .rs.acCompletionTypes$COLUMN) 
            return(.rs.getHelpColumn(what, from, envir))
        else if (type == .rs.acCompletionTypes$DATAFRAME) 
            return(.rs.getHelpDataFrame(what, from, envir))
        else if (length(from) && length(what)) 
            return(.rs.getHelp(what, from))
        else return()
    }
    out <- impl()
    if (is.null(out)) 
        return()
    out$type <- type
    out
}
<bytecode: 0x000001884131fe18>
<environment: 0x000001883f4b86b8>

$.rs.setLintEngine
function (engine) 
{
    if (identical(engine, "internal")) 
        .rs.setVar("r.lint.engine", .rs.internalLintEngine)
    else if (!is.function(engine)) 
        stop("'engine' must be a function taking a single argument (file path)")
    else .rs.setVar("r.lint.engine", engine)
}
<environment: 0x000001883f4b86b8>

$.rs.api.tutorialStop
function (name, package) 
{
    .rs.tutorial.stopTutorial(name, package)
}
<environment: 0x000001883fe56f70>

$.rs.readFile
function (file, binary = FALSE, encoding = NULL) 
{
    size <- file.info(file)$size
    if (binary) 
        return(readBin(file, "raw", size))
    contents <- readChar(file, size, TRUE)
    if (is.character(encoding)) 
        Encoding(contents) <- encoding
    contents
}
<environment: 0x000001883f4b86b8>

$.rs.api.bugReport
function () 
{
    .rs.bugReport(pro = FALSE)
}
<environment: 0x000001883fe59a20>

$.rs.bookdown.renderedOutputPath
function (websiteDir, outputPath) 
{
    if (tools::file_ext(outputPath) == "pdf") 
        return(outputPath)
    index <- file.path(websiteDir, "index.html")
    if (file.exists(index)) 
        return(index)
    outputPath
}
<environment: 0x000001883f4b86b8>

$.rs.invokeRpc
function (method, ...) 
{
    args <- list(...)
    .Call("rs_invokeRpc", method, .rs.scalarListFromList(args), 
        PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.listIndexedFilesAndFolders
function (term = "", inDirectory = .rs.getProjectDirectory(), 
    maxCount = 200L) 
{
    .rs.doListIndex("rs_listIndexedFilesAndFolders", term, inDirectory, 
        maxCount)
}
<environment: 0x000001883f4b86b8>

$.rs.api.selectDirectory
function (caption = "Select Directory", label = "Select", path = .rs.getProjectDirectory()) 
{
    .Call("rs_openFileDialog", 2L, caption, label, path, NULL, 
        TRUE, PACKAGE = "(embedding)")
}
<environment: 0x000001883fddafd8>

$.rs.rpc.show_help_topic
function (what, from, type) 
{
    if (is.character(from) && nzchar(from)) 
        from <- sub("^package:", "", from)
    if (type == .rs.acCompletionTypes$FUNCTION) 
        .rs.showHelpTopicFunction(what, from)
    else if (type == .rs.acCompletionTypes$ARGUMENT) 
        .rs.showHelpTopicArgument(from)
    else if (type == .rs.acCompletionTypes$PACKAGE) 
        .rs.showHelpTopicPackage(what)
    else .rs.showHelpTopic(what, from)
}
<environment: 0x000001883f4b86b8>

$.rs.trimWhitespace
function (x) 
{
    gsub("^[\\s\\n]+|[\\s\\n]+$", "", x, perl = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.addTheme
function (themePath, apply, force, globally) 
{
    fileName <- basename(themePath)
    themeLines <- readLines(themePath, encoding = "UTF-8", warn = FALSE)
    name <- .rs.getThemeName(paste0(themeLines, collapse = "\n"), 
        fileName)
    if (is.na(name) || (name == "") || is.null(name)) {
        stop("Unable to find a name for the new theme. Please check that the file \"", 
            themePath, "\" is valid.", call. = FALSE)
    }
    if (length(themeLines) == 0) {
        stop("The theme file is empty.", call. = FALSE)
    }
    dupTheme <- .rs.getThemes()[[tolower(name)]]
    if (!is.null(dupTheme) && ((globally && .rs.isGlobalTheme(dupTheme$url)) || 
        (!globally && .rs.isLocalTheme(dupTheme$url))) && !force) {
        stop("The specified theme, \"", name, "\", already exists in the target location. Please delete the existing theme and try again.", 
            call. = FALSE)
    }
    else if (!is.null(dupTheme)) {
        willBeOverridden <- if (!globally || .rs.isDefaultTheme(dupTheme$url)) 
            "The existing theme will be overridden by the new theme."
        else "The newly added theme will be overridden by the existing theme."
        warning("There is another theme with the same name, \"", 
            name, "\". ", willBeOverridden, call. = FALSE)
    }
    outputDir <- .rs.getThemeInstallDir(globally)
    if (!dir.exists(outputDir)) {
        if (globally) {
            stop("The global installation directory does not exist: \"", 
                outputDir, "\".", call. = FALSE)
        }
        if (!dir.create(outputDir, recursive = TRUE)) {
            stop("Please check file system permissions.", call. = FALSE)
        }
    }
    addedTheme <- file.path(outputDir, fileName)
    if (file.exists(addedTheme) && !force) {
        stop("A file with the same name, \"", fileName, "\", already exists in the target location. To add the theme anyway, try again with `force = TRUE`.", 
            call. = FALSE)
    }
    if (!file.copy(themePath, addedTheme, overwrite = force)) {
        msg <- "Please check file system permissions"
        if (!force) {
            msg <- paste0(msg, " or try again with `force = TRUE`.")
        }
        stop(msg, ".", call. = FALSE)
    }
    if (apply) {
        .rs.applyTheme(name, .rs.getThemes())
    }
    name
}
<environment: 0x000001883f4b86b8>

$.rs.availablePackagesState
function (reposString) 
{
    entry <- .rs.availablePackagesEnv[[reposString]]
    if (!is.null(entry)) {
        time <- attr(entry, "time", exact = TRUE)
        elapsed <- difftime(Sys.time(), time, units = "secs")
        limit <- as.numeric(Sys.getenv("R_AVAILABLE_PACKAGES_CACHE_CONTROL_MAX_AGE", 
            3600))
        if (elapsed > limit) 
            return("STALE")
        else return("CACHED")
    }
    dir <- .rs.availablePackagesPendingEnv[[reposString]]
    if (is.null(dir)) 
        return("STALE")
    info <- file.info(dir)
    time <- info$mtime
    if (is.na(time)) {
        time <- .rs.tryCatch(readRDS(file.path(dir, "time.rds")))
        if (inherits(time, "error")) 
            time <- Sys.time()
    }
    diff <- difftime(Sys.time(), time, units = "secs")
    if (diff > 120) 
        return("STALE")
    return("PENDING")
}
<environment: 0x000001883f4b86b8>

$.rs.getCustomHelpUrl
function (token) 
{
    custom <- .rs.findCustomHelpContext(token, "help_url_handler")
    if (!is.null(custom)) 
        custom$handler(custom$topic, custom$source)
    else NULL
}
<environment: 0x000001883f4b86b8>

$.rs.getFunctionImpl
function (name, envir = globalenv()) 
{
    envir <- .rs.resolveEnvironment(envir)
    parsed <- parse(text = name)[[1L]]
    fn <- if (is.symbol(parsed)) 
        get(name, envir = envir, mode = "function")
    else eval(parsed, envir = envir)
    if (!is.function(fn)) 
        return(NULL)
    fn
}
<environment: 0x000001883f4b86b8>

$.rs.create_terminal_rule
function (background, foreground) 
{
    sprintf(paste(sep = "\n", ".terminal {", "  background-color: %s;", 
        "  color: %s;", "  font-feature-settings: \"liga\" 0;", 
        "  position: relative;", "  user-select: none;", "  -ms-user-select: none;", 
        "  -webkit-user-select: none;", "}"), background, foreground)
}
<environment: 0x000001883f4b86b8>

$.rs.disableSaveCompression
function () 
{
    options(save.defaults = list(ascii = FALSE, compress = FALSE))
    options(save.image.defaults = list(ascii = FALSE, safe = TRUE, 
        compress = FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.handlerLookupError
function (path, query = NULL, ...) 
{
    payload = paste("<h3>R Custom HTTP Handler Not Found</h3>", 
        "<p>Unable to locate custom HTTP handler for", "<i>", 
        .rs.htmlEscape(path), "</i>", "<p>Is the package which implements this HTTP handler loaded?</p>")
    list(payload, "text/html", character(), 404)
}
<environment: 0x000001883f4b86b8>

$.rs.autoDownloadMethod
function () 
{
    if (capabilities("http/ftp")) 
        "internal"
    else if (nzchar(Sys.which("wget"))) 
        "wget"
    else if (nzchar(Sys.which("curl"))) 
        "curl"
    else ""
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.detect_free_vars
function (code) 
{
    globals <- new.env(parent = emptyenv())
    assign("T", T, envir = globals)
    assign("F", T, envir = globals)
    w <- codetools:::makeCodeWalker(assigned = globals, assignedGlobals = globals, 
        call = .rs.detectFreeVars_Call, leaf = .rs.detectFreeVars_Leaf)
    freeVars <- character(0)
    for (e in parse(text = code)) freeVars <- c(freeVars, codetools:::walkCode(e, 
        w))
    return(unique(freeVars))
}
<environment: 0x000001883f4b86b8>

$.rs.invokeShinyWindowExternal
function (url) 
{
    invisible(.Call("rs_shinyviewer", url, getwd(), "browser", 
        NULL, PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"shinyViewerType")
[1] "browser"

$.rs.knitParams
function (content) 
{
    if (!("knitr" %in% loadedNamespaces())) 
        if (!requireNamespace("knitr", quietly = TRUE)) 
            return(NULL)
    if (!("knit_params" %in% getNamespaceExports(asNamespace("knitr")))) 
        return(NULL)
    Encoding(content) <- "UTF-8"
    knitr::knit_params(content)
}
<environment: 0x000001883f4b86b8>

$.rs.lastCharacterIs
function (value, ending) 
{
    identical(tail(strsplit(value, "")[[1]], n = 1), ending)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsLibraryContextArgumentNames
function (token, string, numCommas, functionCall, completions) 
{
    pkg <- NULL
    args <- NULL
    for (i in seq_along(completions)) {
        if (string[[1]] %in% names(completions[[i]]$functions)) {
            pkg <- names(completions)[[i]]
            args <- completions[[i]]$functions[[string[[1]]]]
            break
        }
    }
    if (is.null(pkg)) 
        return(.rs.emptyCompletions())
    argsText <- paste(args, collapse = ", ")
    dummyFunction <- tryCatch(suppressWarnings(eval(parse(text = paste("function(", 
        argsText, ") {}", sep = "")))), error = function(e) NULL)
    if (is.null(dummyFunction)) 
        return(.rs.emptyCompletions())
    matchedCall <- .rs.matchCall(dummyFunction, functionCall, 
        numCommas = numCommas)
    if (is.null(matchedCall)) 
        return(.rs.emptyCompletions())
    formals <- .rs.resolveFormals(token, dummyFunction, string[[1]], 
        functionCall, matchedCall, envir = environment())
    if (is.null(formals)) 
        return(.rs.emptyCompletions())
    results <- .rs.selectFuzzyMatches(formals$formals, token)
    if (length(results)) 
        results <- paste(results, "= ")
    .rs.makeCompletions(token = token, results = results, packages = paste(pkg, 
        string[[1]], sep = "::"), type = .rs.acCompletionTypes$ARGUMENT, 
        fguess = string[[1]])
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_custom_parameter_help
function (helpHandler, source, language) 
{
    if (identical(language, "Python")) 
        return(.rs.python.getParameterHelp(source))
    helpHandlerFunc <- tryCatch(eval(parse(text = helpHandler)), 
        error = function(e) NULL)
    if (!is.function(helpHandlerFunc)) 
        return()
    results <- helpHandlerFunc("parameter", NULL, source)
    if (!is.null(results)) {
        results$type <- .rs.acCompletionTypes$ARGUMENT
        results$arg_descriptions <- sapply(results$arg_descriptions, 
            .rs.markdownToHTML)
    }
    results
}
<environment: 0x000001883f4b86b8>

$.rs.prependToPath
function (entry) 
{
    oldPath <- Sys.getenv("PATH")
    newPath <- paste(normalizePath(entry), oldPath, sep = .Platform$path.sep)
    Sys.setenv(PATH = newPath)
}
<environment: 0x000001883f4b86b8>

$.rs.notebookVersion
[1] "1.0"

$.rs.createNotebookGraphicsDevice
function (filename, height, width, units, pixelRatio, extraArgs) 
{
    if (units == "px") {
        height <- height * pixelRatio
        width <- width * pixelRatio
    }
    args <- list(filename = filename, width = width, height = height, 
        units = units, res = 96 * pixelRatio)
    if (nchar(extraArgs) > 0) {
        if (identical(substr(extraArgs, 1, 1), ",")) 
            extraArgs <- substring(extraArgs, 2)
        extraList <- NULL
        tryCatch({
            extraList <- eval(parse(text = paste("list(", extraArgs, 
                ")")))
        }, error = function(e) {
        })
        if (is.list(extraList)) 
            args <- c(args, extraList)
    }
    gdBackend <- getOption("RStudioGD.backend")
    if (!identical(gdBackend, "default")) {
        args$type <- gdBackend
    }
    if (identical(args$type, "ragg")) {
        device <- ragg::agg_png(filename = filename, width = width, 
            height = height, units = units, res = 96 * pixelRatio)
        return(device)
    }
    require(grDevices, quietly = TRUE)
    do.call(what = png, args = args)
}
<environment: 0x000001883f4b86b8>

$.rs.api.userDictionariesPath
function () 
{
    .Call("rs_dictionariesPath", "user", PACKAGE = "(embedding)")
}
<environment: 0x000001883fe0d3c8>

$.rs.rpc.has_shinytest_dependencies
function () 
{
    if (.rs.isPackageInstalled("shinytest")) {
        if (!exists("dependenciesInstalled", envir = asNamespace("shinytest"))) {
            .rs.scalar(TRUE)
        }
        else {
            shinytestDepsInstalled <- get("dependenciesInstalled", 
                envir = asNamespace("shinytest"))()
            .rs.scalar(shinytestDepsInstalled)
        }
    }
    else {
        .rs.scalar(FALSE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.validateConnection
function (connection) 
{
    .rs.validateParams(connection, c("type", "host", "displayName", 
        "connectCode"), "character")
    .rs.validateParams(connection, "icon", "character", optional = TRUE)
    .rs.validateParams(connection, c("disconnect", "listObjects", 
        "listColumns", "previewObject"), "function")
}
<environment: 0x000001883f4b86b8>

$.rs.validateAndNormalizeEncoding
function (encoding) 
{
    iconvList <- toupper(iconvlist())
    encodingUpper <- toupper(encoding)
    if (encodingUpper %in% iconvList) {
        return(encodingUpper)
    }
    else {
        encodingUpper <- gsub("[_]", "-", encodingUpper)
        if (encodingUpper %in% iconvList) 
            return(encodingUpper)
        else return("")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.python.getCompletionsImports
function (token) 
{
    pieces <- strsplit(token, ".", fixed = TRUE)[[1]]
    if (grepl("[.]$", token)) 
        pieces <- c(pieces, "")
    if (length(pieces) < 2) {
        completions <- .rs.python.listModules()
        return(.rs.python.completions(token, completions))
    }
    module <- paste(head(pieces, n = -1), collapse = ".")
    imported <- tryCatch(reticulate::import(module), error = identity)
    if (inherits(imported, "error")) 
        return(.rs.emptyCompletions())
    exports <- sort(unique(names(imported)))
    postfix <- pieces[length(pieces)]
    completions <- .rs.python.completions(postfix, exports)
    if (length(completions)) {
        prefix <- paste(pieces[-length(pieces)], collapse = ".")
        completions <- paste(prefix, completions, sep = ".")
    }
    attr(completions, "token") <- token
    attr(completions, "types") <- 21
    completions
}
<environment: 0x000001883f4b86b8>

$.rs.loadPackage
function (packageName, lib) 
{
    if (nzchar(lib)) {
        libPaths <- .libPaths()
        .libPaths(c(lib, libPaths))
        on.exit(.libPaths(libPaths), add = TRUE)
    }
    library(packageName, character.only = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.removeS3Override
function (name) 
{
    table <- .BaseNamespaceEnv[[".__S3MethodsTable__."]]
    if (!exists(name, envir = table)) 
        return(invisible(NULL))
    if (!isTRUE(attr(get(name, envir = table), ".rs.S3Override", 
        exact = TRUE))) {
        return(invisible(NULL))
    }
    if (exists(name, envir = .rs.S3Originals)) {
        assign(name, get(name, envir = .rs.S3Originals), envir = table)
    }
    else {
        rm(list = name, envir = table)
    }
    if (exists(name, envir = .rs.S3Overrides)) 
        rm(list = name, envir = .rs.S3Overrides)
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.spinScript
function (script, signature) 
{
    rmd <- knitr::spin(script, knit = FALSE, format = "Rmd")
    cat(signature, file = rmd, append = TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.api.versionInfo
function () 
{
    info <- list()
    info$citation <- .Call("rs_rstudioCitation", PACKAGE = "(embedding)")
    info$mode <- .Call("rs_rstudioProgramMode", PACKAGE = "(embedding)")
    info$edition <- .Call("rs_rstudioEdition", PACKAGE = "(embedding)")
    info$version <- .Call("rs_rstudioVersion", PACKAGE = "(embedding)")
    info$version <- package_version(info$version)
    info$long_version <- .Call("rs_rstudioLongVersion", PACKAGE = "(embedding)")
    info$release_name <- .Call("rs_rstudioReleaseName", PACKAGE = "(embedding)")
    info
}
<environment: 0x000001883fcda478>

$.rs.withCache
function (name, expr) 
{
    cache <- .rs.getVar(name)
    if (!is.null(cache)) 
        return(cache)
    result <- force(expr)
    .rs.setVar(name, result)
    result
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.objectDesc
function (object) 
{
    output <- ""
    more <- FALSE
    trailing <- " ..."
    n <- 6L
    if (inherits(object, "python.builtin.object")) {
        output <- .rs.reticulate.describeObjectValue(object)
        more <- FALSE
    }
    else if (is.primitive(object)) {
        output <- paste(capture.output(print(object)), collapse = " ")
        output <- sub("function ", "function", output)
        more <- FALSE
    }
    else if (is.function(object)) {
        fmls <- formals(object)
        pieces <- .rs.enumerate(fmls, function(key, value) {
            if (identical(value, quote(expr = ))) 
                return(key)
            value <- if (is.call(value)) 
                format(value)
            else if (is.symbol(value)) 
                as.character(value)
            else value
            paste(key, value, sep = " = ")
        })
        output <- sprintf("function(%s) { ... }", paste(pieces, 
            collapse = ", "))
        more <- FALSE
    }
    else if (is.factor(object)) {
        fmt <- "%s with %i %s: %s"
        header <- head(levels(object), n)
        collapse <- if (is.ordered(object)) 
            " < "
        else ", "
        output <- sprintf(fmt, if (is.ordered(object)) 
            "Ordered factor"
        else "Factor", length(levels(object)), if (length(levels(object)) == 
            1) 
            "level"
        else "levels", paste(.rs.surround(header, with = "\""), 
            collapse = collapse))
        more <- length(levels(object)) > n
        trailing <- if (is.ordered(object)) 
            " < ..."
        else ", ..."
    }
    else if (is.character(object)) {
        header <- head(object, n)
        output <- paste(encodeString(header, quote = "'"), collapse = " ")
        more <- length(object) > n
    }
    else if (is.call(object)) {
        output <- paste(format(object), collapse = " ")
        more <- FALSE
    }
    else if (is.symbol(object)) {
        output <- if (identical(object, quote(expr = ))) 
            "<missing>"
        else .rs.surround(object, with = "`")
        more <- FALSE
    }
    else if (is.data.frame(object)) {
        fmt <- "A %s with %s %s and %s %s"
        name <- if (inherits(object, "tbl")) 
            "tibble"
        else if (inherits(object, "data.table")) 
            "data.table"
        else "data.frame"
        output <- sprintf(fmt, name, nrow(object), if (nrow(object) == 
            1) 
            "row"
        else "rows", ncol(object), if (ncol(object) == 1) 
            "column"
        else "columns")
        more <- FALSE
    }
    else if (is.pairlist(object)) {
        output <- sprintf("Pairlist of length %i", length(object))
        more <- FALSE
    }
    else if (is.list(object)) {
        output <- sprintf("List of length %i", length(object))
        more <- FALSE
    }
    else if (is.environment(object)) {
        if (inherits(object, "R6")) {
            fmt <- "R6 object of %s %s"
            class <- setdiff(class(object), "R6")
            output <- sprintf(fmt, if (length(class) > 1) 
                "classes"
            else "class", paste(class, collapse = ", "))
            more <- FALSE
        }
        else {
            oldClass <- class(object)
            tryCatch({
                class(object) <- "environment"
                output <- capture.output(base::print(object))[[1]]
                more <- FALSE
            }, error = identity)
            class(object) <- oldClass
        }
    }
    else if (is.double(object)) {
        if (length(object) > 1) {
            header <- head(object, n)
            formatted <- format(header, digits = 3)
            output <- paste(formatted, collapse = " ")
            more <- length(object) > n
        }
        else {
            output <- format(object)
            more <- FALSE
        }
    }
    else if (is.atomic(object)) {
        output <- paste(head(object, n), collapse = " ")
        more <- length(object) > n
    }
    else if (isS4(object)) {
        output <- sprintf("S4 object of class %s", class(object))
        more <- FALSE
    }
    else if (.rs.isExternalPointer(object)) {
        output <- capture.output(base::print.default(object))
        more <- FALSE
    }
    if (length(output) == 0) {
        output <- ""
    }
    else if (is.na(output) || !is.character(output)) {
        output <- "<NA>"
    }
    else if (more || nchar(output) > 80) {
        truncated <- substring(output, 1, 80)
        output <- paste(truncated, trailing, sep = "")
    }
    output
}
<environment: 0x000001883f4b86b8>

$.rs.getUntracedFunction
function (functionName, fileName, packageName) 
{
    functionName <- .rs.unquote(functionName)
    envir <- .rs.getEnvironmentOfFunction(functionName, fileName, 
        packageName)
    if (is.null(envir)) {
        return(NULL)
    }
    .rs.untraced(get(functionName, mode = "function", envir = envir))
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectS4
function (object, context = .rs.explorer.createContext()) 
{
    children <- NULL
    if (context$recursive) {
        slots <- .rs.slotNames(object)
        children <- lapply(slots, function(slot) {
            name <- slot
            access <- paste("#", deparse(as.name(name), backtick = TRUE), 
                sep = "@")
            tags <- character()
            childContext <- .rs.explorer.createChildContext(context, 
                name, access, tags)
            value <- eval(call("@", object, slot))
            .rs.explorer.inspectObject(value, childContext)
        })
    }
    .rs.explorer.createInspectionResult(object, context, children)
}
<environment: 0x000001883f4b86b8>

$.rs.logErrorMessage
function (message) 
{
    .Call("rs_logErrorMessage", message, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.describeCall
function (call) 
{
    sanitized <- .rs.sanitizeCall(call)
    val1 <- .rs.deparse(sanitized, nlines = 1L)
    val2 <- .rs.deparse(sanitized, nlines = 2L)
    val <- if (!identical(val1, val2)) 
        paste(val1, "<...>")
    else val1
}
<environment: 0x000001883f4b86b8>

$.rs.doListIndex
function (routine, term, inDirectory, maxCount) 
{
    if (!.rs.hasFileMonitor() || is.null(inDirectory)) 
        return(NULL)
    inDirectory <- suppressWarnings(.rs.normalizePath(inDirectory))
    inDirectory <- gsub("[/\\\\]+$", "", inDirectory)
    .Call(routine, term, inDirectory, as.integer(maxCount))
}
<environment: 0x000001883f4b86b8>

$.rs.generateFunctionInformation
function (func) 
{
    formals <- formals(func)
    if (!length(formals)) 
        return(.rs.emptyFunctionInfo())
    formalNames <- names(formals)
    hasDefault <- vapply(formals, FUN.VALUE = integer(1), USE.NAMES = FALSE, 
        function(x) {
            !identical(x, quote(expr = ))
        })
    missingEnv <- new.env(parent = emptyenv())
    usedSymbolsEnv <- new.env(parent = emptyenv())
    .rs.recursiveWalk(body(func), function(node) {
        .rs.recordFunctionInformation(node, missingEnv, usedSymbolsEnv)
    })
    performsNse <- .rs.performsNonstandardEvaluation(func)
    formalInfo <- lapply(seq_along(formalNames), function(i) {
        as.integer(c(hasDefault[[i]], formalNames[[i]] == "..." || 
            exists(formalNames[[i]], envir = missingEnv), exists(formalNames[[i]], 
            envir = usedSymbolsEnv)))
    })
    list(formal_names = formalNames, formal_info = formalInfo, 
        performs_nse = I(as.integer(performsNse)))
}
<environment: 0x000001883f4b86b8>

$.rs.objectAttributes
function (object) 
{
    .Call("rs_objectAttributes", object, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.readDataCapture
function (path) 
{
    type_sum <- function(x) {
        format_sum <- switch(class(x)[[1]], ordered = "ord", 
            factor = "fctr", POSIXt = "dttm", difftime = "time", 
            Date = "date", data.frame = class(x)[[1]], tbl_df = "tibble", 
            NULL)
        if (!is.null(format_sum)) {
            format_sum
        }
        else if (!is.object(x)) {
            switch(typeof(x), logical = "lgl", integer = "int", 
                double = "dbl", character = "chr", complex = "cplx", 
                closure = "fun", environment = "env", typeof(x))
        }
        else if (!isS4(x)) {
            paste0("S3: ", class(x)[[1]])
        }
        else {
            paste0("S4: ", methods::is(x)[[1]])
        }
    }
    "%||%" <- function(x, y) {
        if (is.null(x)) 
            y
        else x
    }
    big_mark <- function(x, ...) {
        mark <- if (identical(getOption("OutDec"), ",")) 
            "."
        else ","
        formatC(x, big.mark = mark, ...)
    }
    dim_desc <- function(x) {
        dim <- dim(x) %||% length(x)
        format_dim <- vapply(dim, big_mark, character(1))
        format_dim[is.na(dim)] <- "??"
        paste0(format_dim, collapse = " × ")
    }
    is_atomic <- function(x) {
        is.atomic(x) && !is.null(x)
    }
    is_vector <- function(x) {
        is_atomic(x) || is.list(x)
    }
    paged_table_is_vector_s3 <- function(x) {
        switch(class(x)[[1]], ordered = TRUE, factor = TRUE, 
            Date = TRUE, POSIXct = TRUE, difftime = TRUE, data.frame = TRUE, 
            !is.object(x) && is_vector(x))
    }
    size_sum <- function(x) {
        if (!paged_table_is_vector_s3(x)) 
            return("")
        paste0(" [", dim_desc(x), "]")
    }
    obj_sum.default <- function(x) {
        paste0(type_sum(x), size_sum(x))
    }
    obj_sum <- function(x) {
        switch(class(x)[[1]], POSIXlt = rep("POSIXlt", length(x)), 
            list = vapply(x, obj_sum.default, character(1L)), 
            paste0(type_sum(x), size_sum(x)))
    }
    e <- new.env(parent = emptyenv())
    load(file = path, envir = e)
    cat(NULL, sep = "")
    data <- head(e$x, getOption("max.print", 1000))
    data <- if (is.null(data)) 
        as.data.frame(list())
    else data
    options <- e$options
    columnNames <- names(data)
    columnSequence <- seq_len(ncol(data))
    columns <- lapply(columnSequence, function(columnIdx) {
        column <- data[[columnIdx]]
        baseType <- class(column)[[1]]
        tibbleType <- type_sum(column)
        list(label = if (!is.null(columnNames)) columnNames[[columnIdx]] else "", 
            name = columnIdx, type = tibbleType, align = if (baseType == 
                "character" || baseType == "factor") "left" else "right")
    })
    names(data) <- as.character(columnSequence)
    addRowNames = isTRUE(options[["rownames.print"]])
    if (addRowNames) {
        columns <- c(list(list(label = "", name = "_rn_", type = "", 
            align = "left")), columns)
        data$`_rn_` <- rownames(data)
    }
    columns <- unname(columns)
    is_list_not_vctrs <- function(x) is.list(x) && !inherits(x, 
        "vctrs_vctr")
    is_list <- vapply(data, is_list_not_vctrs, logical(1))
    data[is_list] <- lapply(data[is_list], function(x) {
        summary <- obj_sum(x)
        paste0("<", summary, ">")
    })
    needsEncodeFix <- .Platform$OS.type == "windows" && getRversion() == 
        "3.6.0"
    data <- as.data.frame(lapply(data, function(y) {
        if (typeof(y) == "character") {
            y[y == "NA"] <- "__NA__"
        }
        y <- encodeString(format(y))
        if (needsEncodeFix) {
            y <- gsub("^\002\xff\xfe", "", y)
            y <- gsub("\003\xff\xfe$", "", y)
        }
        gsub("^\\s+|\\s+$", "", y)
    }), stringsAsFactors = FALSE, optional = TRUE)
    pagedTableOptions <- list(columns = list(min = options[["cols.min.print"]], 
        max = if (is.null(options[["cols.print"]])) 10 else options[["cols.print"]], 
        total = options[["cols.total"]]), rows = list(min = if (is.null(options[["rows.print"]])) 10 else options[["rows.print"]], 
        max = if (is.null(options[["rows.print"]])) 10 else options[["rows.print"]], 
        total = options[["rows.total"]]), pages = options[["pages.print"]])
    list(columns = columns, data = if (length(data) == 0) list() else data, 
        options = pagedTableOptions)
}
<environment: 0x000001883f4b86b8>

$.rs.pathPackage
function (package = NULL, quiet = FALSE) 
{
    if (is.null(package)) 
        package <- .packages()
    if (length(package) == 0L) 
        return(character())
    s <- search()
    searchpaths <- lapply(seq_along(s), function(i) attr(as.environment(i), 
        "path"))
    searchpaths[[length(s)]] <- system.file()
    pkgs <- paste0("package:", package)
    pos <- match(pkgs, s)
    if (any(m <- is.na(pos))) {
        if (!quiet) {
            if (all(m)) 
                stop("none of the packages are loaded")
            else warning(sprintf(ngettext(as.integer(sum(m)), 
                "package %s is not loaded", "packages %s are not loaded"), 
                paste(package[m], collapse = ", ")), domain = NA)
        }
        pos <- pos[!m]
    }
    unlist(searchpaths[pos], use.names = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.addS3Override
function (name, method) 
{
    table <- .BaseNamespaceEnv[[".__S3MethodsTable__."]]
    if (exists(name, envir = table)) {
        assign(name, get(name, envir = table), envir = .rs.S3Originals)
    }
    attr(method, ".rs.S3Override") <- TRUE
    assign(name, method, envir = table)
    assign(name, method, envir = .rs.S3Overrides)
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.forceUnloadPackageImpl
function (package) 
{
    .rs.beforePackageUnloaded(package)
    searchPathName <- paste("package", package, sep = ":")
    if (searchPathName %in% search()) {
        detach(name = searchPathName, unload = TRUE, character.only = TRUE, 
            force = TRUE)
    }
    else if (package %in% loadedNamespaces()) {
        unloadNamespace(package)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.shellViewPdf
function (path) 
{
    sysName <- Sys.info()[["sysname"]]
    if (identical(sysName, "Windows")) {
        shell.exec(path)
    }
    else {
        if (identical(sysName, "Darwin")) 
            cmd <- paste("open", "-a", "Preview")
        else cmd <- shQuote(getOption("pdfviewer"))
        system(paste(cmd, shQuote(path)), wait = FALSE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.executeDebugSource
function (fileName, encoding, breaklines, local) 
{
    envir <- if (isTRUE(local)) {
        sys.frames()[[1]]
    }
    else if (identical(local, FALSE)) {
        .GlobalEnv
    }
    else if (is.environment(local)) {
        local
    }
    else {
        stop("'local' must be TRUE, FALSE or an environment")
    }
    env <- new.env(parent = emptyenv())
    env$fun <- .rs.makeSourceEquivFunction(fileName, encoding, 
        envir)
    breakSteps <- character()
    if (length(breaklines) > 0) {
        steps <- .rs.getFunctionSteps(env$fun, "fun", breaklines)
        breakSteps <- unlist(lapply(steps, function(step) step$at))
        suppressWarnings(.rs.setFunctionBreakpoints("fun", env, 
            lapply(steps, function(step) {
                step$at
            })))
    }
    env$fun()
    env$fun <- .rs.removeBreakpoints(env$fun)
    breakSteps <- breakSteps[nchar(breakSteps) > 6]
    for (steps in breakSteps) {
        step <- as.numeric(strsplit(breakSteps, ",")[[1]][3])
        op <- deparse(body(env$fun)[[2]][[2]][[step]][[1]])
        if (op == "<-" || op == "=") 
            eval(body(env$fun)[[2]][[2]][[step]], envir = globalenv())
    }
    return(NULL)
}
<environment: 0x000001883f4b86b8>
attr(,"hideFromDebugger")
[1] TRUE

$.rs.reticulate.resolveModule
function (module) 
{
    if (inherits(module, "python.builtin.object")) 
        return(module)
    if (module %in% c("main", "__main__")) 
        reticulate::import_main(convert = FALSE)
    else if (module %in% c("builtins", "__builtins__")) 
        reticulate::import_builtins(convert = FALSE)
    else reticulate::import(module, convert = FALSE)
}
<environment: 0x000001883f4b86b8>

$.rs.readApiPref
function (prefName) 
{
    .rs.readPrefInternal("rs_readApiPref", prefName)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.assemble_data_import
function (dataImportOptions) 
{
    tryCatch({
        dataImportOptions$canCacheData <- dataImportOptions$mode == 
            "xls"
        dataImportOptions$cacheDataWorkingDir <- dataImportOptions$mode == 
            "xls"
        result <- .rs.assembleDataImport(dataImportOptions)
        Encoding(result$importCode) <- "UTF-8"
        Encoding(result$previewCode) <- "UTF-8"
        return(result)
    }, error = function(e) {
        return(list(error = e))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.installBuildTools
function (action) 
{
    fmt <- .rs.trimWhitespace("\n%s requires installation of additional build tools.\n\nDo you want to install the additional tools now?\n")
    response <- .rs.userPrompt("question", "Install Build Tools", 
        sprintf(fmt, action))
    if (!identical(response, "yes")) 
        return(FALSE)
    .Call("rs_installBuildTools", PACKAGE = "(embedding)")
    return(TRUE)
}
<environment: 0x000001883f4b86b8>

$.rs.packageHelpEncodingImpl
function (packagePath) 
{
    desc <- .rs.readPackageDescription(packagePath)
    .rs.nullCoalesce(desc$Encoding, .rs.packageHelpEncodingDefault())
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.copy_profile
function (fromPath, toPath) 
{
    tryCatch({
        file.copy(fromPath, toPath, overwrite = TRUE)
        return(list())
    }, error = function(e) {
        return(list(error = .rs.scalar(e$message)))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.quarto.servePort
function () 
{
    if (requireNamespace("quarto", quietly = TRUE)) {
        if (!is.null(quarto:::quarto$serve_ps) && quarto:::quarto$serve_ps$is_alive()) {
            if (is.numeric(quarto:::quarto$serve_port)) {
                quarto:::quarto$serve_port
            }
            else {
                0
            }
        }
        else {
            0
        }
    }
    else {
        0
    }
}
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.connectionClosed
function (type, host, ...) 
{
    tryCatch(.rs.connectionObserver.connectionClosedImpl(type, 
        host, ...), error = .rs.connectionObserver.connectionError)
}
<environment: 0x000001883f4b86b8>

$.rs.odbcIsWow
function () 
{
    identical(tolower(Sys.info()["sysname"])[[1]], "windows") && 
        identical(.rs.odbcOsBitness(), "32") && nchar(Sys.getenv("ProgramW6432")) > 
        0
}
<environment: 0x000001883f4b86b8>

$.rs.lintDirectory
function (directory = .rs.getProjectDirectory()) 
{
    .Call("rs_lintDirectory", directory)
}
<environment: 0x000001883f4b86b8>

$.rs.isCRANReposFromSettings
function () 
{
    !is.null(attr(getOption("repos"), "RStudio"))
}
<environment: 0x000001883f4b86b8>

$.rs.namedVectorAsList
function (vector) 
{
    values <- unlist(vector, use.names = FALSE)
    if (!length(values)) 
        return(list(names = NULL, values = NULL))
    vectorNames <- names(vector)
    names <- unlist(lapply(seq_along(vector), function(i) {
        rep.int(vectorNames[i], length(vector[[i]]))
    }))
    list(names = names, values = values)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_function_steps
function (functionName, fileName, packageName, lineNumbers) 
{
    .rs.getSteps(functionName, fileName, packageName, lineNumbers)
}
<environment: 0x000001883f4b86b8>

$.rs.swap
function (vector, ..., default) 
{
    dotArgs <- list(...)
    nm <- names(dotArgs)
    to <- unlist(lapply(seq_along(dotArgs), function(i) rep(nm[i], 
        each = length(dotArgs[[i]]))))
    from <- unlist(dotArgs)
    tmp <- to[match(vector, from)]
    tmp[is.na(tmp)] <- default
    tmp
}
<environment: 0x000001883f4b86b8>

$.rs.endsWith
function (strings, string) 
{
    if (!length(string)) 
        string <- ""
    nstrings <- nchar(strings)
    nstring <- nchar(string)
    (nstrings >= nstring) & (substring(strings, nstrings - nstring + 
        1, nstrings) == string)
}
<environment: 0x000001883f4b86b8>

$.rs.readPrefInternal
function (method, prefName) 
{
    if (missing(prefName) || is.null(prefName)) 
        stop("No preference name supplied")
    .Call(method, prefName, PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.assignCachedData
function (cacheKey, obj, objName) 
{
    frame <- .rs.toDataFrame(obj, objName, TRUE)
    if (!is.null(frame)) 
        assign(cacheKey, frame, .rs.CachedDataEnv)
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsPythonVirtualEnvironments
function (token) 
{
    home <- Sys.getenv("WORKON_HOME", unset = "~/.virtualenvs")
    candidates <- list.files(home)
    results <- .rs.selectFuzzyMatches(candidates, token)
    .rs.makeCompletions(token = token, results = results, quote = TRUE, 
        type = .rs.acCompletionTypes$STRING)
}
<environment: 0x000001883f4b86b8>

$.rs.slotNames
function (object) 
{
    if (!isS4(object)) 
        return(character())
    slots <- methods::slotNames(object)
    if (is.character(slots)) 
        return(slots)
    slots <- names(attributes(object))
    setdiff(slots, "class")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleOdbcinstPathWithOdbcinst
function () 
{
    config <- system2("odbcinst", "-j", stdout = TRUE)
    odbciniEntry <- config[grepl("odbcinst.ini", config)]
    gsub("^[^/\\\\]*", "", odbciniEntry)
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalExitCode
function (id) 
{
    if (is.null(id) || !is.character(id) || (length(id) != 1)) 
        stop("'id' must be a single element character vector")
    .Call("rs_terminalExitCode", id, PACKAGE = "(embedding)")
}
<environment: 0x000001883fdc6aa0>

$.rs.reticulate.replInitialize
function () 
{
    info <- .rs.getVar("python.activeInterpreterInfo")
    if (is.null(info)) {
        config <- reticulate::py_config()
        info <- .rs.python.describeInterpreter(config$python)
        .rs.setVar("python.activeInterpreterInfo", info)
    }
    .rs.reticulate.enqueueClientEvent(.rs.reticulateEvents$REPL_INITIALIZED, 
        info)
}
<environment: 0x000001883f4b86b8>

$.rs.environmentCallFrameName
function (env) 
{
    numCalls <- length(sys.calls())
    result <- list()
    for (i in 1:numCalls) {
        if (identical(sys.frame(i), env)) {
            calldesc <- paste(deparse(sys.call(i)[[1]]), "()", 
                sep = "")
            result <- list(name = .rs.scalar(calldesc), frame = .rs.scalar(i), 
                local = .rs.scalar(TRUE))
            break
        }
    }
    if (identical(result, list())) 
        list(name = .rs.scalar("unknown"), frame = .rs.scalar(0L))
    else result
}
<environment: 0x000001883f4b86b8>

$.rs.getFunctionSourceCode
function (functionName, fileName, packageName) 
{
    functionName <- .rs.unquote(functionName)
    paste(capture.output(.rs.getFunctionSourceRefs(functionName, 
        fileName, packageName)), collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_rsconnect_account_list
function () 
{
    accounts <- list()
    tryCatch({
        accountFrame <- rsconnect::accounts()
        if (is.character(accountFrame)) 
            accountFrame <- data.frame(name = accountFrame, server = "shinyapps.io")
        accounts <- .rs.scalarListFromFrame(accountFrame)
    }, error = function(e) {
    })
    accounts
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_package_citations
function (packageName, libraryPath) 
{
    toPerson <- function(author) {
        list(given = author[["given"]], family = .rs.scalar(author[["family"]]), 
            email = .rs.scalar(author[["email"]]), role = .rs.scalar(author[["role"]]))
    }
    cites <- citation(packageName)
    lapply(unclass(cites), function(cite) {
        list(type = .rs.scalar(attr(cite, "bibtype")), title = .rs.scalar(cite[["title"]]), 
            url = .rs.scalar(cite[["url"]]), note = .rs.scalar(cite[["note"]]), 
            doi = .rs.scalar(cite[["doi"]]), publisher = .rs.scalar(cite[["publisher"]]), 
            institution = .rs.scalar(cite[["institution"]]), 
            address = .rs.scalar(cite[["address"]]), journal = .rs.scalar(cite[["journal"]]), 
            year = .rs.scalar(cite[["year"]]), booktitle = .rs.scalar(cite[["booktitle"]]), 
            chapter = .rs.scalar(cite[["chapter"]]), number = .rs.scalar(cite[["number"]]), 
            volume = .rs.scalar(cite[["volume"]]), pages = .rs.scalar(cite[["pages"]]), 
            series = .rs.scalar(cite[["series"]]), school = .rs.scalar(cite[["school"]]), 
            author = lapply(unclass(cite[["author"]]), toPerson), 
            editor = lapply(unclass(cite[["editor"]]), toPerson))
    })
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsNativeRoutine
function (token, interface) 
{
    loadedDLLs <- getLoadedDLLs()
    routines <- lapply(loadedDLLs, getDLLRegisteredRoutines)
    isDynamic <- unlist(lapply(loadedDLLs, `[[`, "dynamicLookup"))
    dynRoutines <- c(routines[isDynamic], routines["(embedding)"])
    dynRoutineNames <- lapply(dynRoutines, function(x) {
        names(x[[interface]])
    })
    if (is.null(names(dynRoutineNames))) 
        return(.rs.emptyCompletions())
    dynResults <- .rs.namedVectorAsList(dynRoutineNames)
    dynIndices <- .rs.fuzzyMatches(dynResults$values, token)
    .rs.makeCompletions(token = token, results = dynResults$values[dynIndices], 
        packages = dynResults$names[dynIndices], quote = TRUE, 
        type = .rs.acCompletionTypes$STRING)
}
<environment: 0x000001883f4b86b8>

$.rs.python.findPythonVirtualEnvironments
function () 
{
    home <- Sys.getenv("WORKON_HOME", unset = "~/.virtualenvs")
    roots <- list.files(home, full.names = TRUE)
    lapply(roots, .rs.python.getVirtualEnvironmentInfo)
}
<environment: 0x000001883f4b86b8>

$.rs.which
function (names) 
{
    scopes = search()
    sapply(names, function(name) {
        for (scope in scopes) {
            if (exists(name, where = scope, inherits = F)) 
                return(scope)
        }
        return("")
    })
}
<environment: 0x000001883f4b86b8>

$.rs.getThemeName
function (themeLines, fileName) 
{
    tmThemeNameRegex <- "<key>name</key>\\s*<string>([^>]*)</string>"
    rsthemeNameRegex <- "rs-theme-name\\s*:\\s*([^\\*]+?)\\s*(?:\\*|$)"
    nameRegex <- tmThemeNameRegex
    nameLine <- themeLines[grep(tmThemeNameRegex, themeLines, 
        perl = TRUE, ignore.case = TRUE)]
    if (length(nameLine) == 0) {
        nameRegex <- rsthemeNameRegex
        nameLine <- themeLines[grep(rsthemeNameRegex, themeLines, 
            perl = TRUE, ignore.case = TRUE)]
    }
    if (length(nameLine) == 0) {
        regmatches(basename(fileName), regexec("^([^\\.]*)(?:\\.[^\\.]*)?", 
            basename(fileName), perl = TRUE))[[1]][2]
    }
    else {
        sub("^\\s*(.+?)\\s*$", "\\1", regmatches(nameLine, regexec(nameRegex, 
            nameLine, perl = TRUE))[[1]][2], perl = TRUE)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.availablePackagesPendingEnv
<environment: 0x000001883fe1d640>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.createNotebookFromCache
function (rmdPath, outputPath = NULL) 
{
    result <- list(succeeded = .rs.scalar(TRUE))
    tryCatch({
        cachePath <- .rs.rnb.cachePathFromRmdPath(rmdPath)
        rnbData <- .rs.readRnbCache(rmdPath, cachePath)
        .rs.createNotebookFromCacheData(rnbData, rmdPath, outputPath)
    }, error = function(e) {
        result <<- list(succeeded = .rs.scalar(FALSE), error_message = .rs.scalar(e$message))
    })
    result
}
<environment: 0x000001883f4b86b8>

$.rs.sanitizeCall
function (object) 
{
    if (missing(object)) {
        return(object)
    }
    else if (is.call(object)) {
        callee <- object[[1L]]
        long <- is.name(callee) && length(object) > 20
        if (long) 
            return(as.call(list(callee, quote(...))))
        for (i in seq_along(object)) {
            sanitized <- .rs.sanitizeCall(object[[i]])
            if (!missing(sanitized) && !is.null(sanitized)) 
                object[[i]] <- sanitized
        }
        object
    }
    else if (is.pairlist(object)) {
        object
    }
    else if (!is.language(object)) {
        if (!is.object(object) && length(object) == 1) {
            object
        }
        else {
            type <- .rs.explorer.objectType(object)
            as.name(sprintf("<%s>", type))
        }
    }
    else {
        object
    }
}
<environment: 0x000001883f4b86b8>

$.rs.showSecureDownloadWarning
function () 
{
    is.na(Sys.getenv("RSTUDIO_DISABLE_SECURE_DOWNLOAD_WARNING", 
        unset = NA))
}
<environment: 0x000001883f4b86b8>

$.rs.recode
function (data, ..., envir = parent.frame()) 
{
    dots <- eval(substitute(alist(...)))
    for (expr in dots) {
        if (length(expr) != 3) 
            stop("malformed recoding in .rs.recode()", call. = FALSE)
        lhs <- eval(expr[[2]], envir = envir)
        rhs <- eval(expr[[3]], envir = envir)
        data[data == lhs] <- rhs
    }
    data
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_package_install_context
function () 
{
    repos = getOption("repos")
    cranMirrorConfigured <- !is.null(repos) && !any(repos == 
        "@CRAN@")
    selectedRepositoryNames <- names(repos)
    if (is.null(selectedRepositoryNames)) 
        selectedRepositoryNames <- "CRAN"
    if (identical(.Platform$OS.type, "windows")) 
        packageArchiveExtension <- ".zip; .tar.gz"
    else if (identical(substr(.Platform$pkgType, 1L, 10L), "mac.binary")) 
        packageArchiveExtension <- ".tgz; .tar.gz"
    else packageArchiveExtension <- ".tar.gz"
    defaultLibraryPath = .libPaths()[1L]
    if (!identical(.Platform$OS.type, "windows")) 
        defaultLibraryPath <- .rs.normalizePath(defaultLibraryPath)
    list(cranMirrorConfigured = cranMirrorConfigured, selectedRepositoryNames = selectedRepositoryNames, 
        packageArchiveExtension = packageArchiveExtension, defaultLibraryPath = defaultLibraryPath, 
        defaultLibraryWriteable = .rs.defaultLibPathIsWriteable(), 
        writeableLibraryPaths = .rs.writeableLibraryPaths(), 
        defaultUserLibraryPath = .rs.defaultUserLibraryPath(), 
        devModeOn = .rs.devModeOn())
}
<environment: 0x000001883f4b86b8>

$.rs.api.writePreference
function (name, value) 
{
    .rs.writeApiPref(name, value)
}
<environment: 0x000001883fd5e810>

$.rs.onAvailablePackagesCached
function (reposString) 
{
    .rs.availablePackagesEnv[[reposString]]
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalRunning
function (id) 
{
    if (is.null(id) || !is.character(id)) 
        stop("'id' must be a character vector")
    .Call("rs_terminalRunning", id)
}
<environment: 0x000001883fdad320>

$.rs.rpc.discover_package_dependencies
function (docId, fileType) 
{
    available <- .rs.availablePackages()
    ready <- !is.null(available$value)
    packages <- .rs.discoverPackageDependencies(docId, fileType)
    list(ready = .rs.scalar(ready), packages = packages)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionObserver.traceback
function () 
{
    .rs.getVar("connectionObserver.lastTraceback")
}
<environment: 0x000001883f4b86b8>

$.rs.odbcOsBitness
function () 
{
    if (grepl("64", Sys.info()["machine"])) {
        "64"
    }
    else {
        "32"
    }
}
<environment: 0x000001883f4b86b8>

$.rs.onAvailablePackagesPending
function (reposString) 
{
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.engineToCodeClass
function (engine) 
{
    engine <- tolower(engine)
    switch(engine, rcpp = "cpp", sh = "bash", engine)
}
<environment: 0x000001883f4b86b8>

$.rs.addins.removeShinyResponseFilter
function () 
{
    options(shiny.http.response.filter = .rs.addins.savedShinyResponseFilter)
    rm(".rs.addins.savedShinyResponseFilter", envir = .rs.toolsEnv())
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.ensure_file_exists
function (path) 
{
    if (!file.exists(path)) 
        if (!file.create(path, recursive = TRUE)) 
            return(.rs.scalar(FALSE))
    .rs.scalar(identical(file.info(path)$isdir, FALSE))
}
<environment: 0x000001883f4b86b8>

$.rs.stan.copySourceDatabaseToTempfile
function (file) 
{
    properties <- .rs.getSourceDocumentProperties(file, includeContents = TRUE)
    if (is.null(properties) || is.null(properties$contents)) 
        return(NULL)
    dir <- tempfile("rstudio-stan-diagnostics-")
    if (!dir.create(dir, showWarnings = FALSE)) 
        return(NULL)
    newPath <- file.path(dir, basename(file))
    status <- tryCatch(writeLines(properties$contents, con = newPath, 
        useBytes = TRUE), error = identity)
    if (inherits(status, "error") || !file.exists(newPath)) 
        return(NULL)
    newPath
}
<environment: 0x000001883f4b86b8>

$.rs.saveCachedData
function (cacheDir) 
{
    if (Encoding(cacheDir) == "unknown") 
        Encoding(cacheDir) <- "UTF-8"
    if (!exists(".rs.CachedDataEnv")) 
        return(invisible(NULL))
    lapply(ls(.rs.CachedDataEnv), function(cacheKey) {
        save(list = cacheKey, file = file.path(cacheDir, paste(cacheKey, 
            "Rdata", sep = ".")), envir = .rs.CachedDataEnv)
    })
    suppressWarnings(rm(list = ls(.rs.CachedDataEnv), where = .rs.CachedDataEnv))
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.pendingActions
function (action, dir) 
{
    capture.output(msgs <- tryCatch({
        suppressWarnings(packrat:::getActionMessages(action, 
            dir))
    }, error = function(e) {
        NULL
    }))
    if (!is.null(msgs)) {
        for (i in seq_along(msgs)) {
            msgs[[i]][is.na(msgs[[i]])] <- "<missing>"
        }
    }
    msgs
}
<environment: 0x000001883f4b86b8>

$.rs.getDataTableByCompletions
function (token) 
{
    .rs.getDataTableSpecialSymbolsCompletions(token, ".EACHI")
}
<environment: 0x000001883f4b86b8>

$.rs.bugReport
function (pro = NULL) 
{
    rstudioInfo <- .rs.api.versionInfo()
    rstudioVersion <- format(rstudioInfo$long_version)
    rstudioEdition <- sprintf("%s [%s]", if (rstudioInfo$mode == 
        "desktop") 
        "Desktop"
    else "Server", if (is.null(rstudioInfo$edition)) 
        "Open Source"
    else toupper(rstudioInfo$edition))
    rInfo <- utils::sessionInfo()
    rVersion <- rInfo$R.version$version.string
    rVersion <- sub("^R version", "", rVersion, fixed = TRUE)
    osVersion <- rInfo$running
    rInfoText <- local({
        op <- options(width = 78)
        on.exit(options(op), add = TRUE)
        paste(capture.output(print(rInfo)), collapse = "\n")
    })
    template <- .rs.heredoc("\n      ### System details\n\n          RStudio Edition : %s\n          RStudio Version : %s\n          OS Version      : %s\n          R Version       : %s\n  \n      ### Steps to reproduce the problem\n      \n      ### Describe the problem in detail\n      \n      ### Describe the behavior you expected\n      \n      ---\n      \n      <details>\n      \n      <summary>Session Info</summary>\n      \n      ``` r\n      %s\n      ```\n      \n      </details>\n   ")
    rendered <- sprintf(template, rstudioVersion, rstudioEdition, 
        osVersion, rVersion, rInfoText)
    if (rstudioInfo$mode == "desktop") {
        text <- paste(rendered, collapse = "\n")
        .Call("rs_clipboardSetText", text, PACKAGE = "(embedding)")
        writeLines(.rs.heredoc("\n         * The bug report template has been written to the clipboard.\n         * Please paste the clipboard contents into the issue comment section,\n         * and then fill out the rest of the issue details.\n         *\n      "))
    }
    else {
        header <- .rs.heredoc("\n         <!--\n         Please copy the following text to your clipboard,\n         and then click 'Cancel' to close the dialog.\n         -->\n      ")
        text <- c(header, "", rendered)
        file <- tempfile("rstudio-bug-report-", fileext = ".html")
        on.exit(unlink(file), add = TRUE)
        writeLines(text, con = file)
        utils::file.edit(file)
    }
    if (is.null(pro)) 
        pro <- !is.null(rstudioInfo$edition)
    url <- if (pro) {
        "https://github.com/rstudio/rstudio-pro/issues/new"
    }
    else {
        "https://github.com/rstudio/rstudio/issues/new"
    }
    fmt <- " * Navigating to '%s' in 3 seconds ... "
    msg <- sprintf(fmt, url)
    writeLines(msg)
    Sys.sleep(3)
    utils::browseURL(url)
}
<environment: 0x000001883f4b86b8>

$.rs.heredoc
function (text) 
{
    trimmed <- gsub("^\\s*\\n|\\n\\s*$", "", text)
    lines <- strsplit(trimmed, "\n", fixed = TRUE)[[1L]]
    indent <- regexpr("[^[:space:]]", lines)
    common <- min(setdiff(indent, -1L))
    paste(substring(lines, common), collapse = "\n")
}
<environment: 0x000001883f4b86b8>

$.rs.getCompletionsData
function (token) 
{
    availableData <- suppressWarnings(data()$results)
    indices <- intersect(which(.rs.fuzzyMatches(availableData[, 
        "Item"], token)), grep(" ", availableData[, "Item"], 
        fixed = TRUE, invert = TRUE))
    results <- availableData[indices, "Item"]
    packages <- availableData[indices, "Package"]
    .rs.makeCompletions(token, results, packages, quote = TRUE, 
        type = .rs.acCompletionTypes$DATASET)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectFunction
function (object, context = .rs.explorer.createContext()) 
{
    children <- NULL
    if (is.primitive(object)) {
        children <- list()
    }
    else if (context$recursive) {
        parts <- list(formals = formals(object), body = body(object), 
            environment = environment(object))
        children <- .rs.enumerate(parts, function(key, value) {
            name <- key
            access <- sprintf("%s(#)", name)
            tags <- .rs.explorer.tags$VIRTUAL
            childContext <- .rs.explorer.createChildContext(context, 
                name, access, tags)
            .rs.explorer.inspectObject(value, childContext)
        })
    }
    .rs.explorer.createInspectionResult(object, context, children)
}
<environment: 0x000001883f4b86b8>

$.rs.loadedPackagesAndDependencies
function (pkgs) 
{
    defaultNamespaces <- c("base", "datasets", "graphics", "grDevices", 
        "methods", "stats", "tools", "utils")
    if (identical(defaultNamespaces, loadedNamespaces()) && length(.dynLibs()) == 
        4) 
        return(character())
    packagesLoaded <- function(pkgList) {
        loaded <- pkgList[pkgList %in% loadedNamespaces()]
        libs <- .dynLibs()
        libnames <- vapply(libs, "[[", character(1), "name")
        loaded <- c(loaded, pkgList[pkgList %in% libnames])
        loaded
    }
    loaded <- packagesLoaded(pkgs)
    avail <- available.packages()
    deps <- suppressMessages(suppressWarnings(utils:::getDependencies(pkgs, 
        available = avail)))
    loaded <- c(loaded, packagesLoaded(deps))
    unique(loaded)
}
<environment: 0x000001883f4b86b8>

$.rs.simulateSourceRefs
function (var) 
{
    fun <- attr(var, "_rs_callfun")
    call <- attr(var, "_rs_callobj")
    calltext <- attr(var, "_rs_calltext")
    linepref <- attr(var, "_rs_lastline")
    if (is.null(fun) || (is.null(call) && is.null(calltext))) 
        return(c(0L, 0L, 0L, 0L, 0L, 0L))
    lines <- .rs.deparseFunction(fun, FALSE, FALSE)
    indents <- nchar(sub("\\S.*", "", lines))
    slines <- sub("\\s+$", "", sub("^\\s+", "", lines))
    nchars <- 0
    offsets <- integer(length(slines))
    for (i in 1:length(slines)) {
        nchars <- nchars + nchar(slines[i]) + 1
        offsets[i] <- nchars
    }
    singleline <- paste(slines, collapse = " ")
    if (is.null(calltext)) {
        calltext <- .rs.deparse(call, nlines = 200L)
    }
    else {
        calltext <- unlist(strsplit(calltext, "\n", fixed = TRUE))
    }
    calltext <- sub("\\s+$", "", sub("^\\s+", "", calltext))
    calltext <- paste(calltext, collapse = " ")
    if (Encoding(calltext) == "unknown") 
        Encoding(calltext) <- "UTF-8"
    if (identical(calltext, "NULL")) 
        return(c(0L, 0L, 0L, 0L, 0L, 0L))
    pos <- gregexpr(calltext, singleline, fixed = TRUE)[[1]]
    if (length(pos) > 1) {
        best <- which(pos > offsets[linepref])
        if (length(best) == 0) {
            best <- which.min(abs(linepref - pos))
        }
        else best <- best[1]
        endpos <- pos[best] + attr(pos, "match.length")[best]
        pos <- pos[best]
    }
    else {
        endpos <- pos + attr(pos, "match.length")
    }
    if (length(pos) == 0 || pos < 0) 
        return(c(0L, 0L, 0L, 0L, 0L, 0L))
    firstline <- which(offsets >= pos, arr.ind = TRUE)[1]
    lastline <- which(offsets >= endpos, arr.ind = TRUE)[1]
    if (is.na(lastline)) 
        lastline <- length(offsets)
    firstchar <- pos - (if (firstline == 1) 
        0
    else offsets[firstline - 1])
    firstchar <- firstchar + indents[firstline]
    if (substr(calltext, 1, 1) == "{" && substr(calltext, nchar(calltext), 
        nchar(calltext)) == "}" && lastline - firstline > 5) {
        lastline <- firstline
        lastchar <- offsets[firstline] - pos
    }
    else {
        lastchar <- endpos - (if (lastline == 1) 
            0
        else offsets[lastline - 1])
        lastchar <- lastchar + indents[lastline]
    }
    result <- as.integer(c(firstline, firstchar, lastline, lastchar, 
        firstchar, lastchar))
    return(result)
}
<bytecode: 0x000001884153d408>
<environment: 0x000001883f4b86b8>

$.rs.api.terminalList
function () 
{
    .Call("rs_terminalList")
}
<environment: 0x000001883fdb5a60>

$.rs.rpc.get_output_preview
function (path, encoding, header, sep, decimal, quote, comment) 
{
    nrows <- 20
    output <- .rs.parseDataFile(path, encoding = encoding, header = header, 
        sep = sep, dec = decimal, quote = quote, comment = comment, 
        nrows = nrows)
    list(output = output, outputNames = names(output), header = header, 
        encoding = encoding, separator = sep, quote = quote, 
        comment = comment, defaultStringsAsFactors = ifelse(getRversion() >= 
            "4.2.0", FALSE, default.stringsAsFactors()))
}
<environment: 0x000001883f4b86b8>

$.rs.getS4MethodNamespaceName
function (method) 
{
    env <- environment(method)
    if (identical(env, baseenv())) 
        return("package:base")
    else if (identical(env, globalenv())) 
        return(".GlobalEnv")
    else {
        envName <- environmentName(env)
        if (envName %in% search()) 
            return(envName)
        else paste("package:", envName, sep = "")
    }
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.encode
function (data) 
{
    .rs.base64encode(.rs.toJSON(data, unbox = TRUE))
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletionsFields
function (token, conn, ctx) 
{
    conn <- .rs.sql.asDBIConnection(conn)
    if (is.null(conn)) 
        return(.rs.emptyCompletions(language = "SQL"))
    tables <- ctx$tables
    if (grepl(".", token, fixed = TRUE)) {
        parts <- .rs.strsplit(token, ".", fixed = TRUE)
        tables <- parts[[length(parts) - 1]]
        token <- parts[[length(parts) - 0]]
    }
    Reduce(.rs.appendCompletions, lapply(tables, function(table) {
        if (table %in% names(ctx$aliases)) 
            table <- ctx$aliases[[table]]
        schema <- ctx$schemas[[match(table, ctx$tables)]]
        fields <- .rs.tryCatch(.rs.db.listFields(conn, schema = schema, 
            table = table))
        if (inherits(fields, "error")) 
            return(.rs.emptyCompletions(language = "SQL"))
        fields <- setdiff(fields, token)
        .rs.makeCompletions(token = token, results = .rs.selectFuzzyMatches(fields, 
            token), packages = table, type = .rs.acCompletionTypes$DATASET)
    }))
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleInstall
function (name, url, placeholder, installPath, libraryPattern = NULL, 
    md5 = NULL, version = "") 
{
    installPath <- file.path(normalizePath(installPath, mustWork = FALSE), 
        tolower(name))
    bundleTemp <- tempfile()
    on.exit(unlink(bundleTemp, recursive = TRUE), add = TRUE)
    message("Installing")
    message("  Driver: ", name)
    message("  Version: ", version)
    message("  Path: ", installPath)
    message("Checking prerequisites")
    .rs.odbcBundleCheckPrereqs()
    message("Downloading bundle")
    bundleFileTemp <- .rs.odbcBundleDownload(url, placeholder, 
        bundleTemp)
    message("Validating bundle")
    .rs.odbcBundleValidate(bundleFileTemp, md5)
    message("Extracting bundle")
    .rs.odbcBundleExtract(bundleFileTemp, installPath)
    message("Inspecting driver")
    driverPath <- .rs.odbcBundleFindDriver(name, installPath, 
        libraryPattern)
    message("Registering driver")
    .rs.odbcBundleRegister(name, driverPath, version, installPath)
    message("")
    message("Installation complete")
    invisible(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.register_user_token
function (serverName, accountName, userId, token, privateKey) 
{
    rsconnect:::registerUserToken(serverName = serverName, accountName = accountName, 
        userId = userId, token = token, privateKey = privateKey)
}
<environment: 0x000001883f4b86b8>

$.rs.hookedPackages
  [1] "abind"         "askpass"       "backports"     "base"          "base64enc"     "BiocManager"   "BiocVersion"   "bit"          
  [9] "bit64"         "bitops"        "blob"          "boot"          "brew"          "brio"          "broom"         "bslib"        
 [17] "cachem"        "callr"         "car"           "carData"       "checkmate"     "chron"         "class"         "cli"          
 [25] "clipr"         "cluster"       "codetools"     "collegeIncome" "colorspace"    "commonmark"    "compiler"      "cpp11"        
 [33] "crayon"        "credentials"   "cubature"      "curl"          "data.table"    "datasets"      "DBI"           "deldir"       
 [41] "desc"          "devtools"      "diffobj"       "digest"        "downlit"       "dplyr"         "ellipsis"      "evaluate"     
 [49] "fansi"         "farver"        "fastmap"       "fontawesome"   "forcats"       "foreign"       "Formula"       "fs"           
 [57] "generics"      "gert"          "GGally"        "ggplot2"       "ggplot2movies" "gh"            "gitcreds"      "glue"         
 [65] "graphics"      "grDevices"     "grid"          "gridExtra"     "gsubfn"        "gtable"        "highr"         "HistData"     
 [73] "Hmisc"         "hms"           "htmlTable"     "htmltools"     "htmlwidgets"   "httpuv"        "httr"          "httr2"        
 [81] "ini"           "installr"      "interp"        "isoband"       "jpeg"          "jquerylib"     "jsonlite"      "kernlab"      
 [89] "KernSmooth"    "knitr"         "labeling"      "later"         "lattice"       "latticeExtra"  "lifecycle"     "lme4"         
 [97] "lobstr"        "lubridate"     "magrittr"      "manipulate"    "markdown"      "MASS"          "matahari"      "Matrix"       
[105] "MatrixModels"  "memoise"       "methods"       "mgcv"          "mime"          "miniUI"        "minqa"         "munsell"      
[113] "nlme"          "nloptr"        "nnet"          "numDeriv"      "openssl"       "packrat"       "parallel"      "pbkrtest"     
[121] "pillar"        "pkgbuild"      "pkgconfig"     "pkgdown"       "pkgload"       "plogr"         "plyr"          "png"          
[129] "praise"        "prettyunits"   "processx"      "profvis"       "progress"      "promises"      "proto"         "pryr"         
[137] "ps"            "purrr"         "quantmod"      "quantreg"      "R6"            "ragg"          "rappdirs"      "rcmdcheck"    
[145] "RColorBrewer"  "Rcpp"          "RcppEigen"     "RCurl"         "readr"         "rematch2"      "remotes"       "repdoc"       
[153] "reshape"       "reshape2"      "rhdf5"         "rhdf5filters"  "Rhdf5lib"      "rJava"         "rlang"         "rmarkdown"    
[161] "RMySQL"        "roxygen2"      "rpart"         "rprojroot"     "rsconnect"     "RSQLite"       "rstudioapi"    "rversions"    
[169] "sass"          "scales"        "sessioninfo"   "shiny"         "sourcetools"   "SparseM"       "spatial"       "splines"      
[177] "sqldf"         "ssanv"         "stats"         "stats4"        "stringi"       "stringr"       "survival"      "swirl"        
[185] "sys"           "systemfonts"   "tcltk"         "testthat"      "textshaping"   "tibble"        "tidyr"         "tidyselect"   
[193] "timechange"    "tinytex"       "tools"         "translations"  "TTR"           "tzdb"          "urlchecker"    "usethis"      
[201] "UsingR"        "utf8"          "utils"         "vctrs"         "viridis"       "viridisLite"   "vroom"         "waldo"        
[209] "whisker"       "withr"         "xfun"          "xlsx"          "xlsxjars"      "XML"           "xml2"          "xopen"        
[217] "xtable"        "xts"           "yaml"          "zip"           "zoo"          
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.setNotebookMargins
function () 
{
    par(mar = c(5.1, 4.1, 2.1, 2.1))
}
<environment: 0x000001883f4b86b8>

$.rs.db.listFields
function (conn, schema = NULL, table = NULL) 
{
    if (length(schema) && nzchar(schema)) {
        if ("odbc" %in% loadedNamespaces() && inherits(conn, 
            "OdbcConnection")) {
            columns <- odbc:::connection_sql_columns(conn@ptr, 
                schema_name = schema, table_name = table)
            return(columns[["name"]])
        }
        return(DBI::dbListFields(conn, DBI::Id(schema = schema, 
            table = table)))
    }
    DBI::dbListFields(conn, table)
}
<environment: 0x000001883f4b86b8>

$.rs.findBreakpointSteps
function (funBody) 
{
    if (typeof(funBody) != "language") {
        return(NULL)
    }
    for (idx in 1:length(funBody)) {
        if (is.call(funBody[[idx]]) && identical(as.character(funBody[[idx]][[1]])[[1]], 
            ".doTrace")) {
            return(idx + 1)
        }
        nestedSteps <- .rs.findBreakpointSteps(funBody[[idx]])
        if (!is.null(nestedSteps)) {
            return(c(idx, nestedSteps))
        }
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.terminalSend
function (id, text) 
{
    if (!is.character(text)) 
        stop("'text' should be a character vector", call. = FALSE)
    if (is.null(id) || !is.character(id) || length(id) != 1) 
        stop("'id' must be a character vector of length one")
    .Call("rs_terminalSend", id, text)
    invisible(NULL)
}
<environment: 0x000001883fd95570>

$.rs.explorer.createHandle
function (object, name, title, language, envir) 
{
    entry <- list(object = object, name = name, title = title, 
        language = language, envir = envir)
    id <- .rs.explorer.setCacheEntry(entry)
    list(id = .rs.scalar(id), name = .rs.scalar(name), title = .rs.scalar(title), 
        language = .rs.scalar(language))
}
<environment: 0x000001883f4b86b8>

$.rs.makeSourceEquivFunction
function (filename, encoding, envir = globalenv()) 
{
    content <- suppressWarnings(parse(filename, encoding = encoding))
    fun <- function() {
        evalq({
            1
        }, envir = envir)
    }
    for (i in 1:length(content)) {
        body(fun)[[2]][[2]][[i + 1]] <- content[[i]]
    }
    refs <- attr(content, "srcref")
    lastref <- length(refs)
    attr(body(fun), "srcfile") <- attr(content, "srcfile")
    ref <- structure(c(refs[[1]][1], refs[[1]][2], refs[[lastref]][3], 
        refs[[lastref]][[4]], refs[[1]][5], refs[[lastref]][6], 
        refs[[1]][1], refs[[lastref]][3]), srcfile = attr(content, 
        "srcfile"), class = "srcref")
    attr(body(fun), "srcref")[[2]] <- ref
    linerefs <- list(attr(content, "srcref")[[1]])
    for (i in 1:length(content)) {
        linerefs[[i + 1]] <- attr(content, "srcref")[[i]]
    }
    attr(body(fun)[[2]][[2]], "srcref") <- linerefs
    attr(fun, "srcref") <- ref
    return(fun)
}
<environment: 0x000001883f4b86b8>

$.rs.initDefaultUserLibrary
function () 
{
    userdir <- .rs.defaultUserLibraryPath()
    dir.create(userdir, showWarnings = FALSE, recursive = TRUE)
    .libPaths(c(userdir, .libPaths()))
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectorRegistry
<environment: 0x000001883d3c5460>
attr(,".Environment")
<environment: 0x000001883f4b86b8>
attr(,".Environment")attr(,"name")
[1] "tools:rstudio"

$.rs.internal.convertTheme
function (themePath) 
{
    Encoding(themePath) <- "UTF-8"
    warnings <- c()
    tryCatch(withCallingHandlers(.rs.convertTheme(themePath, 
        add = TRUE, outputLocation = NULL, apply = FALSE, force = TRUE, 
        globally = FALSE), warning = function(w) {
        warnings <<- conditionMessage(w)
        invokeRestart("muffleWarning")
    }), error = function(e) {
        if (length(warnings) > 0) 
            e$message <- paste(e$message, paste0(warnings, collapse = "\n    "), 
                sep = "\nAlso, warnings:\n    ")
        e
    })
}
<environment: 0x000001883f4b86b8>

$.rs.python.getPythonDescription
function (pythonPath) 
{
    .rs.python.execute(pythonPath, "import sys; print(sys.version)")
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.outputSourceConsole
function (fileName, fileContents, context, includeSource, ...) 
{
    Encoding(fileContents) <- "UTF-8"
    parsed <- .rs.rnb.readConsoleData(fileContents)
    if (!includeSource) 
        parsed <- parsed[parsed$type != 0, ]
    if (identical(context$results, "hide")) 
        parsed <- parsed[parsed$type != 1, ]
    attributes <- list(class = .rs.rnb.engineToCodeClass(context$engine))
    rendered <- .rs.rnb.renderConsoleData(parsed, attributes = attributes, 
        context)
    return(rendered)
}
<environment: 0x000001883f4b86b8>

$.rs.findNext
function (regex, content, start = 1, end = length(content)) 
{
    matches <- grep(regex, content, perl = TRUE)
    matches[(matches > start) & (matches < end)][1]
}
<environment: 0x000001883f4b86b8>

$.rs.callSummary
function (val) 
{
    call <- .rs.nullCoalesce(attr(val, "_rs_call", exact = TRUE), 
        val)
    call <- .rs.sanitizeCall(call)
    .rs.deparse(call)
}
<environment: 0x000001883f4b86b8>

$.rs.python.interpreterInfo
function (path, type) 
{
    path <- enc2utf8(path)
    path <- chartr("\\", "/", path)
    valid <- TRUE
    version <- "[unknown]"
    description <- "[unknown]"
    version <- tryCatch(.rs.python.getPythonVersion(path), error = function(e) {
        valid <<- FALSE
        conditionMessage(e)
    })
    description <- tryCatch(.rs.python.getPythonDescription(path), 
        error = function(e) {
            valid <<- FALSE
            conditionMessage(e)
        })
    list(path = .rs.createAliasedPath(path), type = type, version = version, 
        description = description, valid = valid, reason = NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.hasConnectAccount
function () 
{
    tryCatch({
        accounts <- rsconnect::accounts()
        subset(accounts, !(server %in% c("shinyapps.io", "rstudio.cloud", 
            "posit.cloud")))
        .rs.scalar(nrow(accounts) > 0)
    }, error = function(e) {
        FALSE
    })
}
<environment: 0x000001883f4b86b8>

$.rs.odbcBundleRegisterWindows
function (name, driverPath, version, installPath) 
{
    .rs.odbcBundleRegistryAdd(list(list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", "ODBC Drivers", fsep = "\\"), 
        key = name, value = "installed"), list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", name, fsep = "\\"), key = "Driver", 
        value = driverPath), list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", name, fsep = "\\"), key = "Setup", 
        value = driverPath), list(path = file.path("SOFTWARE", 
        "ODBC", "ODBCINST.INI", name, fsep = "\\"), key = "Version", 
        value = version), list(path = file.path("SOFTWARE", "ODBC", 
        "ODBCINST.INI", name, fsep = "\\"), key = "Installer", 
        value = "RStudio")))
}
<environment: 0x000001883f4b86b8>

$.rs.saveGraphicsSnapshot
function (snapshot, filename) 
{
    plot = snapshot
    attr(plot, "version") <- as.character(getRversion())
    class(plot) <- "recordedplot"
    save(plot, file = filename)
}
<environment: 0x000001883f4b86b8>

$.rs.invokeShinyTutorialViewer
function (url, meta) 
{
    invisible(.Call("rs_shinyviewer", url, getwd(), "tutorial", 
        meta, PACKAGE = "(embedding)"))
}
<environment: base>
attr(,"shinyViewerType")
[1] "tutorial"

$.rs.rpc.show_vignette
function (topic, package) 
{
    print(utils::vignette(topic, package))
}
<environment: 0x000001883f4b86b8>

$.rs.suspendSession
function (force = FALSE, exitStatus = 0L) 
{
    .Call("rs_suspendSession", as.logical(force), as.integer(exitStatus), 
        PACKAGE = "(embedding)")
}
<environment: 0x000001883f4b86b8>

$.rs.api.selectFile
function (caption = "Select File", label = "Select", path = .rs.getProjectDirectory(), 
    filter = NULL, existing = TRUE) 
{
    .Call("rs_openFileDialog", 1L, caption, label, path, filter, 
        existing, PACKAGE = "(embedding)")
}
<environment: 0x000001883fde4998>

$.rs.getDollarNamesMethod
function (object, excludeBaseClasses = FALSE, envir = globalenv()) 
{
    classAndSuper <- function(cl) {
        super <- tryCatch(methods::selectSuperClasses(cl), error = function(e) NULL)
        c(cl, super)
    }
    classes <- unlist(lapply(class(object), classAndSuper), recursive = TRUE)
    classes <- if (excludeBaseClasses) 
        setdiff(classes, c("list", "environment"))
    else c(classes, mode(object))
    for (class in classes) {
        method <- if ("envir" %in% names(formals(utils::getS3method))) {
            utils::getS3method(f = ".DollarNames", class = class, 
                optional = TRUE, envir = envir)
        }
        else {
            utils::getS3method(f = ".DollarNames", class = class, 
                optional = TRUE)
        }
        if (!is.null(method)) 
            return(method)
    }
    NULL
}
<environment: 0x000001883f4b86b8>

$.rs.activateGraphicsDevice
function () 
{
    invisible(.Call("rs_activateGD"))
}
<environment: 0x000001883f4b86b8>

$.rs.valueDescription
function (obj) 
{
    tryCatch(.rs.valueDescriptionImpl(obj), error = function(e) "")
}
<environment: 0x000001883f4b86b8>

$.rs.isTraced
function (fun) 
{
    isS4(fun) && class(fun) == "functionWithTrace"
}
<environment: 0x000001883f4b86b8>

$.rs.getSecondaryRepos
function (cran = getOption("repos")[[1]], custom = TRUE) 
{
    result <- list(repos = list())
    rCranReposUrl <- .Call("rs_getCranReposUrl", PACKAGE = "(embedding)")
    isDefault <- identical(rCranReposUrl, NULL) || nchar(rCranReposUrl) == 
        0
    if (isDefault) {
        slash <- if (.rs.lastCharacterIs(cran, "/")) 
            ""
        else "/"
        rCranReposUrl <- paste(slash, "../../__api__/repos", 
            sep = "")
    }
    else {
        custom <- TRUE
    }
    if (.rs.startsWith(rCranReposUrl, "..") || .rs.startsWith(rCranReposUrl, 
        "/..")) {
        rCranReposUrl <- .rs.completeUrl(cran, rCranReposUrl)
    }
    if (custom) {
        conf <- tempfile(fileext = ".conf")
        result <- tryCatch({
            download.file(rCranReposUrl, conf, method = "curl", 
                extra = "-H 'Accept: text/ini'", quiet = TRUE)
            result$repos <- .rs.parseSecondaryReposIni(conf)
            if (length(result$repos) == 0) {
                result$repos <- .rs.parseSecondaryReposJson(conf)
            }
            result
        }, error = function(e) {
            list(error = .rs.scalar(paste("Failed to process repos list from ", 
                rCranReposUrl, ". ", e$message, ".", sep = "")))
        })
    }
    result
}
<environment: 0x000001883f4b86b8>

$.rs.python.findPythonInterpreters
function () 
{
    interpreters <- unname(c(.rs.python.findPythonProjectInterpreters(), 
        .rs.python.findPythonSystemInterpreters(), .rs.python.findPythonInterpretersInKnownLocations(), 
        .rs.python.findPythonPyenvInterpreters(), .rs.python.findPythonVirtualEnvironments(), 
        .rs.python.findPythonCondaEnvironments()))
    default <- Sys.getenv("RETICULATE_PYTHON", unset = "")
    list(python_interpreters = .rs.scalarListFromList(interpreters), 
        default_interpreter = .rs.scalar(default))
}
<environment: 0x000001883f4b86b8>

$.rs.executeFunctionInChildProcess
function (callback, data = list(), workingDir = NULL, libPaths = .libPaths(), 
    ...) 
{
    scriptDir <- tempfile("rstudio-script-")
    dir.create(scriptDir, recursive = TRUE, showWarnings = FALSE)
    owd <- setwd(scriptDir)
    on.exit({
        setwd(owd)
        unlink(scriptDir, recursive = TRUE)
    }, add = TRUE)
    rlibs <- Sys.getenv("R_LIBS", unset = NA)
    Sys.setenv(R_LIBS = paste(libPaths, collapse = .Platform$path.sep))
    on.exit({
        if (is.na(rlibs)) Sys.unsetenv("R_LIBS") else Sys.setenv(R_LIBS = rlibs)
    }, add = TRUE)
    bundle <- list(callback = callback, data = data, workingDir = workingDir)
    script <- quote({
        originalWorkingDir <- getwd()
        bundle <- readRDS("bundle.rds")
        workingDir <- bundle[["workingDir"]]
        if (!is.null(workingDir)) {
            dir.create(workingDir, recursive = TRUE, showWarnings = FALSE)
            owd <- setwd(workingDir)
            on.exit(setwd(owd), add = TRUE)
        }
        callback <- bundle[["callback"]]
        data <- bundle[["data"]]
        result <- do.call(callback, data)
        setwd(originalWorkingDir)
        saveRDS(object = result, file = "output.rds")
    })
    suppressWarnings(saveRDS(bundle, file = "bundle.rds"))
    writeLines(deparse(script), con = "script.R")
    exe <- if (Sys.info()[["sysname"]] == "Windows") 
        "R.exe"
    else "R"
    r <- file.path(R.home("bin"), exe)
    args <- c("--vanilla", "-s", "-f", shQuote("script.R"))
    system2(r, args, ...)
    if (file.exists("output.rds")) 
        readRDS("output.rds")
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletions
function (line, conn, ctx) 
{
    parts <- .rs.strsplit(line, "\\s+")
    token <- tail(parts, n = 1L)
    matches <- gregexpr("[-+*/%&|^=><]", token)[[1]]
    if (!identical(c(matches), -1L)) 
        token <- substring(token, tail(matches, n = 1L) + 1)
    if (grepl(".", token, fixed = TRUE)) {
        if (.rs.sql.isTableScopedKeyword(ctx$contextKeyword)) 
            return(.rs.sql.getCompletionsTables(token, conn, 
                ctx))
        else return(.rs.sql.getCompletionsFields(token, conn, 
            ctx))
    }
    if (.rs.sql.isTableScopedKeyword(ctx$contextKeyword)) {
        completions <- Reduce(.rs.appendCompletions, list(.rs.sql.getCompletionsTables(token, 
            conn, ctx), .rs.sql.getCompletionsSchemas(token, 
            conn, ctx)))
        return(completions)
    }
    Reduce(.rs.appendCompletions, list(.rs.sql.getCompletionsKeywords(token, 
        conn, ctx), .rs.sql.getCompletionsFields(token, conn, 
        ctx), .rs.sql.getCompletionsTables(token, conn, ctx), 
        .rs.sql.getCompletionsIdentifiers(token, conn, ctx)))
}
<environment: 0x000001883f4b86b8>

$.rs.parseSecondaryReposJson
function (conf) 
{
    lines <- readLines(conf)
    repos <- list()
    entries <- .rs.fromJSON(paste(lines, collpse = "\n"))
    for (entry in entries) {
        url <- if (is.null(entry$url)) 
            ""
        else url
        repo <- list(name = .rs.scalar(entry$name), url = .rs.scalar(url), 
            host = .rs.scalar("Custom"), country = .rs.scalar(""))
        if (identical(tolower(as.character(repo$name)), "cran")) {
            repo$name <- .rs.scalar("CRAN")
            repos <- append(list(repo), repos, 1)
        }
        else {
            repos[[length(repos) + 1]] <- repo
        }
    }
    repos
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.viewObject
function (object, title = NULL, envir = .GlobalEnv) 
{
    if (is.null(title)) {
        call <- match.call()
        title <- paste(deparse(call$object, width.cutoff = 500), 
            collapse = " ")
    }
    language <- if (.rs.reticulate.replIsActive()) 
        "Python"
    else "R"
    name <- .rs.explorer.objectName(object, title)
    handle <- .rs.explorer.createHandle(object, name, title, 
        language, envir)
    .rs.explorer.fireEvent(.rs.explorer.types$NEW, handle)
}
<environment: 0x000001883f4b86b8>

$.rs.formatDataColumnList
function (col, ...) 
{
    limit <- .rs.readUserPref("data_viewer_max_cell_size")
    if (is.null(limit)) {
        limit <- 50L
    }
    formatted <- as.character(col)
    large <- nchar(formatted) > limit
    formatted <- substr(formatted, 1, limit)
    formatted <- paste0(formatted, ifelse(large, " [...]", ""))
    formatted
}
<environment: 0x000001883f4b86b8>

$.rs.sql.getCompletionsSchemas
function (token, conn, ctx) 
{
    conn <- .rs.sql.asDBIConnection(conn)
    if (is.null(conn)) 
        return(.rs.emptyCompletions(language = "SQL"))
    schemas <- .rs.tryCatch(.rs.db.listSchemas(conn))
    if (inherits(schemas, "error")) 
        return(.rs.emptyCompletions(language = "SQL"))
    schemas <- setdiff(schemas, token)
    results <- .rs.selectFuzzyMatches(schemas, token)
    .rs.makeCompletions(token = token, results = results, packages = "schema", 
        type = .rs.acCompletionTypes$ENVIRONMENT)
}
<environment: 0x000001883f4b86b8>

$.rs.api.executeCommand
function (commandId, quiet = FALSE) 
{
    .Call("rs_executeAppCommand", commandId, quiet, PACKAGE = "(embedding)")
}
<environment: 0x000001883fe14118>

$.rs.getPackageRStudioProtocol
function (name) 
{
    path <- system.file("rstudio/rstudio-protocol", package = name)
    if (path != "") {
        tryCatch(expr = {
            return(as.integer(read.dcf(path, all = TRUE)$Version))
        }, warning = function(e) {
        }, error = function(e) {
        })
    }
    needsUnloadAfter <- !(name %in% loadedNamespaces())
    rpv <- ".RStudio_protocol_version"
    env <- asNamespace(name)
    if (exists(rpv, envir = env, mode = "integer")) {
        version <- get(rpv, envir = env)
    }
    else {
        version <- 0L
    }
    if (needsUnloadAfter) 
        unloadNamespace(name)
    version
}
<environment: 0x000001883f4b86b8>

$.rs.rpc.get_packrat_status
function (dir) 
{
    .rs.quietPackratStatus(dir)
}
<environment: 0x000001883f4b86b8>

$.rs.objectsOnSearchPath
function (token = "", caseInsensitive = FALSE, excludeGlobalEnv = FALSE) 
{
    search <- search()
    startIdx <- 1
    range <- 1:length(search)
    if (excludeGlobalEnv) {
        startIdx <- 2
        search <- search[-1]
        range <- range[-1]
    }
    if (nzchar(token)) {
        token <- .rs.escapeForRegex(token)
        if (caseInsensitive) 
            token <- .rs.asCaseInsensitiveRegex(token)
        pattern <- paste("^", token, sep = "")
        objects <- lapply(range, function(i) {
            ls(pos = i, all.names = TRUE, pattern = pattern)
        })
    }
    else {
        objects <- lapply(range, function(i) {
            ls(pos = i, all.names = TRUE)
        })
    }
    names(objects) <- search
    objects
}
<bytecode: 0x000001883bc7acb8>
<environment: 0x000001883f4b86b8>

$.rs.reticulate.matplotlib.showHook
function (...) 
{
    size <- dev.size(units = "in")
    width <- size[1]
    height <- size[2]
    dpi <- 92
    ratio <- .Call("rs_devicePixelRatio", PACKAGE = "(embedding)")
    dpi <- dpi * ratio
    path <- tempfile("matplotlib-plot-", fileext = ".png")
    plt <- reticulate::import("matplotlib.pyplot", convert = TRUE)
    figure <- plt$gcf()
    figure$set_dpi(dpi)
    figure$set_size_inches(width, height)
    plt$savefig(path, dpi = figure$dpi)
    data <- png::readPNG(path, native = TRUE, info = TRUE)
    opar <- par(xaxt = "n", yaxt = "n", xaxs = "i", yaxs = "i", 
        mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0), xpd = NA)
    on.exit(par(opar), add = TRUE)
    plot.new()
    graphics::rasterImage(data, 0, 0, 1, 1)
}
<environment: 0x000001883f4b86b8>

$.rs.connectionListColumns
function (type, host, ...) 
{
    connection <- .rs.findActiveConnection(type, host)
    if (!is.null(connection)) 
        listColumnsCode <- connection$listColumns(...)
    else NULL
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.saveHtmlToCache
function (x, ...) 
{
    ctx <- .rs.rnb.getHtmlCaptureContext()
    htmlfile <- tempfile("_rs_html_", tmpdir = ctx$outputFolder, 
        fileext = ".html")
    depfile <- tempfile("_rs_html_deps_", tmpdir = ctx$outputFolder, 
        fileext = ".json")
    rendered <- htmltools::renderTags(x)
    htmldeps <- rendered$dependencies
    html <- rendered$html
    if (length(htmldeps)) {
        cat(.rs.toJSON(htmldeps, unbox = TRUE), file = depfile, 
            sep = "\n")
        htmltools::save_html(x, file = htmlfile, libdir = ctx$libraryFolder)
    }
    else {
        cat(as.character(html), file = htmlfile, sep = "\n")
    }
    .rs.recordHtmlWidget(x, htmlfile, depfile)
}
<environment: 0x000001883f4b86b8>

$.rs.themes_static_rules
function (isDark) 
{
    content <- paste(".editor_dark.ace_editor_theme a {", "   color: #FFF !important;", 
        "}", "", ".ace_layer {", "   z-index: 3;", "}", "", ".ace_layer.ace_print-margin-layer {", 
        "   z-index: 2;", "}", "", ".ace_layer.ace_marker-layer {", 
        "   z-index: 1;", "}", sep = "\n")
    if (isDark) {
        content <- c(content, paste(".rstudio-themes-dark-menus .ace_editor.ace_autocomplete {", 
            "   background: #2f3941;", "   border: solid 1px #4e5c68 !important;", 
            "   color: #f0f0f0;", "}", "", ".rstudio-themes-dark-menus .ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line,", 
            ".rstudio-themes-dark-menus .ace_editor.ace_autocomplete .ace_marker-layer .ace_line-hover {", 
            "   background: rgba(255, 255, 255, 0.15);", "   border: none", 
            "}", sep = "\n"))
    }
    content
}
<environment: 0x000001883f4b86b8>

$.rs.isViewOverride
function () 
{
    for (i in seq_along(sys.calls())) {
        if (identical(deparse(sys.call(i)[[1]]), "View")) {
            return(!identical(deparse(body(sys.function(i))[[1]]), 
                ".rs.callAs"))
        }
    }
    FALSE
}
<environment: 0x000001883f4b86b8>

$.rs.rnb.resolveActiveChunkId
function (rnbData, label) 
{
    chunkDefns <- rnbData$chunk_info$chunk_definitions
    for (defn in chunkDefns) {
        if (identical(defn$chunk_label, label)) 
            return(defn$chunk_id)
    }
    return(NULL)
}
<environment: 0x000001883f4b86b8>

$.rs.explorer.inspectObjectAttributes
function (object, context = .rs.explorer.createContext()) 
{
    . <- environment()
    if (inherits(.$object, "python.builtin.object")) {
        attributes <- reticulate::dict()
        builtins <- reticulate::import_builtins(convert = TRUE)
        keys <- builtins$dir(object)
        for (key in keys) {
            attr <- reticulate::py_get_attr(object, key, silent = TRUE)
            reticulate::py_set_item(attributes, key, attr)
        }
        name <- "(attributes)"
        access <- "#"
        tags <- c(.rs.explorer.tags$ATTRIBUTES, .rs.explorer.tags$VIRTUAL)
        childContext <- .rs.explorer.createChildContext(context, 
            name, access, tags)
        .rs.explorer.inspectObject(attributes, childContext)
    }
    else {
        attributes <- attributes(.$object)
        name <- "(attributes)"
        access <- "attributes(#)"
        tags <- c(.rs.explorer.tags$ATTRIBUTES, .rs.explorer.tags$VIRTUAL)
        childContext <- .rs.explorer.createChildContext(context, 
            name, access, tags)
        .rs.explorer.inspectObject(attributes, childContext)
    }
}
<environment: 0x000001883f4b86b8>

$.rs.api.sourceMarkers
function (name, markers, basePath = NULL, autoSelect = c("none", 
    "first", "error")) 
{
    if (!is.character(name)) 
        stop("name parameter is specified or invalid: ", name, 
            call. = FALSE)
    autoSelect = match.arg(autoSelect)
    if (!is.null(basePath)) 
        basePath <- .rs.normalizePath(basePath, mustWork = TRUE)
    if (is.data.frame(markers)) {
        cols <- colnames(markers)
        if (!"type" %in% cols || !is.character(markers$type)) 
            stop("markers type field is unspecified or invalid", 
                call. = FALSE)
        if (!"file" %in% cols || !is.character(markers$file)) 
            stop("markers file field is unspecified or invalid", 
                call. = FALSE)
        if (!"line" %in% cols || !is.numeric(markers$line)) 
            stop("markers line field is unspecified or invalid", 
                call. = FALSE)
        if (!"column" %in% cols || !is.numeric(markers$column)) 
            stop("markers column field is unspecified or invalid", 
                call. = FALSE)
        if (!"message" %in% cols || !is.character(markers$message)) 
            stop("markers message field is unspecified or invalid", 
                call. = FALSE)
        markers$file <- .rs.normalizePath(markers$file, mustWork = TRUE)
    }
    else if (is.list(markers)) {
        markers <- lapply(markers, function(marker) {
            markerTypes <- c("error", "warning", "box", "info", 
                "style", "usage")
            if (is.null(marker$type) || (!marker$type %in% markerTypes)) 
                stop("Invalid marker type (", marker$type, ")", 
                  call. = FALSE)
            if (!is.character(marker$file)) 
                stop("Marker file is unspecified or invalid: ", 
                  marker$file, call. = FALSE)
            if (!is.numeric(marker$line)) 
                stop("Marker line is unspecified or invalid", 
                  marker$line, call. = FALSE)
            if (!is.numeric(marker$column)) 
                stop("Marker column is unspecified or invalid", 
                  marker$line, call. = FALSE)
            if (!is.character(marker$message)) 
                stop("Marker message is unspecified or invalid: ", 
                  marker$message, call. = FALSE)
            marker$type <- .rs.scalar(marker$type)
            marker$file <- .rs.scalar(.rs.normalizePath(marker$file, 
                mustWork = TRUE))
            marker$line <- .rs.scalar(as.numeric(marker$line))
            marker$column <- .rs.scalar(as.numeric(marker$column))
            marker$message <- .rs.scalar(marker$message)
            marker
        })
    }
    else {
        stop("markers was not a data.frame or a list", call. = FALSE)
    }
    if (is.null(basePath)) 
        basePath <- ""
    else if (!is.character(basePath)) 
        stop("basePath parameter is not of type character", call. = FALSE)
    invisible(.Call("rs_sourceMarkers", name, markers, basePath, 
        autoSelect, PACKAGE = "(embedding)"))
}
<environment: 0x000001883fd06918>

$.rs.getConnectionObject
function (type, host) 
{
    name <- .rs.getConnectionObjectName(type, host)
    get(name, envir = globalenv())
}
<environment: 0x000001883f4b86b8>

$.rs.cutpoints
function (data) 
{
    diffed <- diff(c(data[1], data))
    which(diffed != 0)
}
<environment: 0x000001883f4b86b8>

$.rs.acContextTypes
$.rs.acContextTypes$UNKNOWN
[1] 0

$.rs.acContextTypes$FUNCTION
[1] 1

$.rs.acContextTypes$SINGLE_BRACKET
[1] 2

$.rs.acContextTypes$DOUBLE_BRACKET
[1] 3

$.rs.acContextTypes$NAMESPACE_EXPORTED
[1] 4

$.rs.acContextTypes$NAMESPACE_ALL
[1] 5

$.rs.acContextTypes$DOLLAR
[1] 6

$.rs.acContextTypes$AT
[1] 7

$.rs.acContextTypes$FILE
[1] 8

$.rs.acContextTypes$CHUNK
[1] 9

$.rs.acContextTypes$ROXYGEN
[1] 10

$.rs.acContextTypes$HELP
[1] 11

$.rs.acContextTypes$ARGUMENT
[1] 12

$.rs.acContextTypes$PACKAGE
[1] 13

$.rs.acContextTypes$PLUMBER
[1] 14


$.rs.python.getHelp
function (topic, source) 
{
    object <- .rs.tryCatch(reticulate::py_eval(source, convert = FALSE))
    if (inherits(object, "error")) 
        return(NULL)
    handler <- reticulate:::help_completion_handler.python.builtin.object
    .rs.tryCatch(reticulate::py_suppress_warnings(handler(topic, 
        object)))
}
<environment: 0x000001883f4b86b8>

 [ reached getOption("max.print") -- omitted 265 entries ]
